[{"categories":["导航"],"content":"影视大全 五杀电影院 在线之家 中国高清网 妮可动漫 ","date":"2020-01-01","objectID":"/%E8%B1%86%E9%A5%BC%E5%AF%BC%E8%88%AA/:1:0","tags":["导航"],"title":"豆饼导航","uri":"/%E8%B1%86%E9%A5%BC%E5%AF%BC%E8%88%AA/"},{"categories":["导航"],"content":"博客精选 如有乐享 阮一峰 卢松松博客 lrepacks 福利吧 ","date":"2020-01-01","objectID":"/%E8%B1%86%E9%A5%BC%E5%AF%BC%E8%88%AA/:2:0","tags":["导航"],"title":"豆饼导航","uri":"/%E8%B1%86%E9%A5%BC%E5%AF%BC%E8%88%AA/"},{"categories":["导航"],"content":"导航大全 龙轩导航 设计导航 ","date":"2020-01-01","objectID":"/%E8%B1%86%E9%A5%BC%E5%AF%BC%E8%88%AA/:3:0","tags":["导航"],"title":"豆饼导航","uri":"/%E8%B1%86%E9%A5%BC%E5%AF%BC%E8%88%AA/"},{"categories":["python"],"content":" import threading import time import inspect import ctypes def _async_raise(tid, exctype): \"\"\"raises the exception, performs cleanup if needed\"\"\" tid = ctypes.c_long(tid) if not inspect.isclass(exctype): exctype = type(exctype) res = ctypes.pythonapi.PyThreadState_SetAsyncExc(tid, ctypes.py_object(exctype)) if res == 0: raise ValueError(\"invalid thread id\") elif res != 1: # \"\"\"if it returns a number greater than one, you're in trouble, # and you should call it again with exc=NULL to revert the effect\"\"\" ctypes.pythonapi.PyThreadState_SetAsyncExc(tid, None) raise SystemError(\"PyThreadState_SetAsyncExc failed\") def stop_thread(thread): _async_raise(thread.ident, SystemExit) def test(): while True: for i in range(1,1000): time.sleep(0.1) print(str(i)) def test1(): while True: for i in range(200,1000): time.sleep(0.1) print(str(i)) if __name__ == \"__main__\": t = threading.Thread(target=test) t1 = threading.Thread(target=test1) t.start() t1.start() time.sleep(5.2) print(\"t thread sleep finish\") print(\"t2 thread sleep finish\") stop_thread(t) stop_thread(t1) ","date":"2022-05-19","objectID":"/python%E7%BB%88%E6%AD%A2%E8%BF%90%E8%A1%8C%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B/:0:0","tags":["python","线程"],"title":"python线程操作","uri":"/python%E7%BB%88%E6%AD%A2%E8%BF%90%E8%A1%8C%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B/"},{"categories":["经验"],"content":"APIs are awesome, but they’re also extremely hard to design. When creating an API from scratch, you need to get many details right. From basic security considerations to using the right HTTP methods, implementing authentication, deciding which requests and responses you should accept and return, … the list goes on. Api 很棒，但是设计起来也非常困难。在从头创建 API 时，您需要获得许多正确的细节。从基本的安全考虑到使用正确的 HTTP 方法，实现身份验证，决定应该接受和返回哪些请求和响应… … 这个列表还在继续。 In this post, I’m trying my best to compress everything I know about what makes a good API. An API, that your consumers will enjoy using. All tips are language-agnostic, so they apply to any framework or technology. 在这篇文章中，我尽我所能压缩我所知道的关于如何创建一个好的 API 的所有信息。一个 API，你的消费者会喜欢使用它。所有的技巧都与语言无关，因此它们适用于任何框架或技术。 ","date":"2022-03-10","objectID":"/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%8E%A5%E5%8F%A3/:0:0","tags":["经验"],"title":"如何设计更好的接口","uri":"/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%8E%A5%E5%8F%A3/"},{"categories":["经验"],"content":"1. Be consistent ","date":"2022-03-10","objectID":"/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%8E%A5%E5%8F%A3/:0:1","tags":["经验"],"title":"如何设计更好的接口","uri":"/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%8E%A5%E5%8F%A3/"},{"categories":["经验"],"content":"1. 保持一致 I know it sounds logical, but it’s hard to get this one right. The best APIs I know are predictable. When a consumer uses and understands one endpoint, they can expect that another endpoint works the same way. This is important for the entire API and one of the key indicators of whether or not an API is well-designed and great to use. 我知道这听起来很合乎逻辑，但这个问题很难回答对。我所知道的最好的 api 是可以预测的。当消费者使用和理解一个端点时，他们可以期待另一个端点以同样的方式工作。这对于整个 API 来说非常重要，也是判断一个 API 是否设计良好、使用方便的关键指标之一。 Use the same casing for fields, resources, and parameters (I prefer 对字段、资源和参数使用相同的大小写(我更喜欢这样)snake_case) Use either plural or singular resource names (I prefer plural) 使用复数或单数资源名称(我更喜欢使用复数) /users/{id}, /orders/{id} or 或/user/{id}, /order/{id} Use the same authentication and authorization methods for all endpoints 对所有端点使用相同的身份验证和授权方法 Use the same HTTP headers across the API 跨 API 使用相同的 HTTP 头 For example 例如Api-Key for passing an API key 传递 API 密钥 Use the same HTTP status codes based on the type of response 根据响应类型使用相同的 HTTP 状态代码 For example 例如404 when a resource can not be found 当资源找不到的时候 Use the same HTTP methods for the same kind of actions 对同类操作使用相同的 HTTP 方法 For example 例如DELETE when deleting a resource 当删除一个资源 ","date":"2022-03-10","objectID":"/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%8E%A5%E5%8F%A3/:0:2","tags":["经验"],"title":"如何设计更好的接口","uri":"/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%8E%A5%E5%8F%A3/"},{"categories":["经验"],"content":"2. Use ISO 8601 8601 UTC dates ","date":"2022-03-10","objectID":"/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%8E%A5%E5%8F%A3/:0:3","tags":["经验"],"title":"如何设计更好的接口","uri":"/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%8E%A5%E5%8F%A3/"},{"categories":["经验"],"content":"2. 使用世界协调时日期 When dealing with date and time, APIs should always return ISO 8601-formatted strings. Displaying dates in a specific time zone is generally a concern of client applications. 在处理日期和时间时，api 应该始终返回 ISO 8601 格式的字符串。在特定时区显示日期通常是客户端应用程序关心的问题。 { \"published_at\": \"2022-03-03T21:59:08Z\" } ","date":"2022-03-10","objectID":"/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%8E%A5%E5%8F%A3/:0:4","tags":["经验"],"title":"如何设计更好的接口","uri":"/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%8E%A5%E5%8F%A3/"},{"categories":["经验"],"content":"3. Make an exception for public endpoints ","date":"2022-03-10","objectID":"/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%8E%A5%E5%8F%A3/:0:5","tags":["经验"],"title":"如何设计更好的接口","uri":"/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%8E%A5%E5%8F%A3/"},{"categories":["经验"],"content":"3. 为公共端点破例 Every endpoint should require authorization by default. Most endpoints require an authenticated user to be called, so making this the default makes sense. If an endpoint needs to be called publicly, explicitly set this endpoint to allow unauthorized requests. 默认情况下，每个端点都需要授权。大多数端点都需要调用经过身份验证的用户，因此将其设置为默认值是有意义的。如果需要公开调用某个端点，请显式设置该端点以允许未经授权的请求。 ","date":"2022-03-10","objectID":"/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%8E%A5%E5%8F%A3/:0:6","tags":["经验"],"title":"如何设计更好的接口","uri":"/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%8E%A5%E5%8F%A3/"},{"categories":["经验"],"content":"4. Provide a health check endpoint ","date":"2022-03-10","objectID":"/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%8E%A5%E5%8F%A3/:0:7","tags":["经验"],"title":"如何设计更好的接口","uri":"/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%8E%A5%E5%8F%A3/"},{"categories":["经验"],"content":"4. 提供一个健康检查终点 Provide an endpoint (for example GET /health) that determines whether or not a service is healthy. This endpoint can be called by other applications such as load balancers to act in case of a service outage. 提供一个端点(例如 GET/health) ，用于确定服务是否健康。在服务中断的情况下，负载均衡器等其他应用程序可以调用这个端点。 ","date":"2022-03-10","objectID":"/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%8E%A5%E5%8F%A3/:0:8","tags":["经验"],"title":"如何设计更好的接口","uri":"/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%8E%A5%E5%8F%A3/"},{"categories":["经验"],"content":"5. Version the API ","date":"2022-03-10","objectID":"/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%8E%A5%E5%8F%A3/:0:9","tags":["经验"],"title":"如何设计更好的接口","uri":"/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%8E%A5%E5%8F%A3/"},{"categories":["经验"],"content":"5. 对 API 进行版本化 Make sure you version your API and pass the version on each request so that consumers aren’t affected by any changes to another version. API versions can be passed using HTTP headers or query/path parameters. Even the first version of the API (1.0) should be explicitly versioned. 确保您对 API 进行了版本化，并在每个请求上传递了版本，这样使用者就不会受到对另一个版本的任何更改的影响。API 版本可以使用 HTTP 头或查询/路径参数传递。即使是 API (1.0)的第一个版本也应该显式地进行版本控制。 Some examples: 以下是一些例子: https://api.averagecompany.com/v1/health https://api.averagecompany.com/health?api_version=1.0 ","date":"2022-03-10","objectID":"/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%8E%A5%E5%8F%A3/:0:10","tags":["经验"],"title":"如何设计更好的接口","uri":"/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%8E%A5%E5%8F%A3/"},{"categories":["经验"],"content":"6. Accept API key authentication ","date":"2022-03-10","objectID":"/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%8E%A5%E5%8F%A3/:0:11","tags":["经验"],"title":"如何设计更好的接口","uri":"/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%8E%A5%E5%8F%A3/"},{"categories":["经验"],"content":"6. 接受 API/密钥认证 If an API needs to be called by a third party, it makes sense to allow authentication via API keys. API keys should be passed using a custom HTTP header (such as Api-Key). They should have an expiration date, and it must be possible to revoke active keys so that they can be invalidated in case they get compromised. Avoid checking API keys into source control (use environment variables instead). 如果需要第三方调用 API，那么允许通过 API 密钥进行身份验证是有意义的。应该使用自定义 HTTP 标头(如 API-key)传递 API 密钥。它们应该有一个过期日期，并且必须可以撤销活动密钥，以便在密钥泄露的情况下使其失效。避免将 API 键检查到源代码管理中(使用环境变量代替)。 ","date":"2022-03-10","objectID":"/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%8E%A5%E5%8F%A3/:0:12","tags":["经验"],"title":"如何设计更好的接口","uri":"/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%8E%A5%E5%8F%A3/"},{"categories":["经验"],"content":"7. Use reasonable HTTP status codes ","date":"2022-03-10","objectID":"/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%8E%A5%E5%8F%A3/:0:13","tags":["经验"],"title":"如何设计更好的接口","uri":"/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%8E%A5%E5%8F%A3/"},{"categories":["经验"],"content":"7. 使用合理的 HTTP 状态代码 Use conventional HTTP status codes to indicate the success or failure of a request. Don’t use too many, and use the same status codes for the same outcomes across the API. Some examples: 使用传统的 HTTP 状态代码来指示请求的成功或失败。不要使用太多，并且在整个 API 中对相同的结果使用相同的状态代码。以下是一些例子: 200 for general success 为了一般的成功 201 for successful creation 成功的创造 400 for bad requests from the client 因为客户提出了不好的要求 401 for unauthorized requests 未经授权的请求 403 for missing permissions 丢失许可证 404 for missing resources 寻找丢失的资源 429 for too many requests 要求太多了 5xx for internal errors (these should be avoided at all costs) 内部错误(应该不惜一切代价避免这些错误) ","date":"2022-03-10","objectID":"/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%8E%A5%E5%8F%A3/:0:14","tags":["经验"],"title":"如何设计更好的接口","uri":"/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%8E%A5%E5%8F%A3/"},{"categories":["经验"],"content":"8. Use reasonable HTTP methods ","date":"2022-03-10","objectID":"/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%8E%A5%E5%8F%A3/:0:15","tags":["经验"],"title":"如何设计更好的接口","uri":"/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%8E%A5%E5%8F%A3/"},{"categories":["经验"],"content":"8. 使用合理的 HTTP 方法 There are many HTTP methods, but the most important ones are: 有许多 HTTP 方法，但最重要的是: POST for creating resources 来创造资源 POST /users GET for reading resources (both single resources and collections) 用于阅读资源(单个资源和集合) GET /users GET /users/{id} PATCH for applying partial updates to a resource 用于对资源应用部分更新 PATCH /users/{id} PUT for applying full updates to a resource (replaces the current resource) 用于对资源应用完整更新(替换当前资源) PUT /users/{id} DELETE for deleting resources 删除资源 DELETE /users/{id} ","date":"2022-03-10","objectID":"/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%8E%A5%E5%8F%A3/:0:16","tags":["经验"],"title":"如何设计更好的接口","uri":"/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%8E%A5%E5%8F%A3/"},{"categories":["经验"],"content":"9. Use self-explanatory, simple names ","date":"2022-03-10","objectID":"/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%8E%A5%E5%8F%A3/:0:17","tags":["经验"],"title":"如何设计更好的接口","uri":"/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%8E%A5%E5%8F%A3/"},{"categories":["经验"],"content":"9. 使用不言自明的简单名字 Most endpoints are resource-oriented and should be named that way. Don’t add unnecessary information that can be inferred from elsewhere. This also applies to field names. 大多数端点是面向资源的，应该以这种方式命名。不要添加可以从其他地方推断出来的不必要的信息。这也适用于字段名。 ✅ GOOD 很好 GET /users =\u003e Retrieve users = \u003e 检索用户 DELETE /users/{id} =\u003e Delete a user = \u003e 删除用户 POST /users/{id}/notifications =\u003e Create a notification for a specific user = \u003e 为特定用户创建通知 user.first_name order.number ❌ BAD Something BAD GET /getUser POST /updateUser POST /notification/user order.ordernumber user.firstName ","date":"2022-03-10","objectID":"/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%8E%A5%E5%8F%A3/:0:18","tags":["经验"],"title":"如何设计更好的接口","uri":"/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%8E%A5%E5%8F%A3/"},{"categories":["经验"],"content":"10. Use standardized error responses ","date":"2022-03-10","objectID":"/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%8E%A5%E5%8F%A3/:0:19","tags":["经验"],"title":"如何设计更好的接口","uri":"/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%8E%A5%E5%8F%A3/"},{"categories":["经验"],"content":"10. 使用标准化的错误响应 Aside from using HTTP status codes that indicate the outcome of the request (success or error), when returning errors, always use a standardized error response that includes more detailed information on what went wrong. Consumers can always expect the same structure and act accordingly. 除了使用 HTTP 状态代码指示请求的结果(成功或错误)之外，在返回错误时，始终使用标准化的错误响应，其中包含关于出错原因的更详细的信息。消费者总是可以期待相同的结构并采取相应的行动。 // Request =\u003e GET /users/4TL011ax // Response \u003c= 404 Not Found { \"code\": \"user/not_found\", \"message\": \"A user with the ID 4TL011ax could not be found.\" } // Request =\u003e POST /users { \"name\": \"John Doe\" } // Response \u003c= 400 Bad Request { \"code\": \"user/email_required\", \"message\": \"The parameter [email] is required.\" } ","date":"2022-03-10","objectID":"/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%8E%A5%E5%8F%A3/:0:20","tags":["经验"],"title":"如何设计更好的接口","uri":"/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%8E%A5%E5%8F%A3/"},{"categories":["经验"],"content":"11. Return created resources upon POST It’s a good idea to return the created resource after creating it with a POST request. That’s mostly important because the returned, created resource will reflect the current state of the underlying data source and will contain more recent information (such as a generated ID). 在使用 POST 请求创建已创建的资源之后返回该资源是一个好主意。这一点非常重要，因为返回的、创建的资源将反映基础数据源的当前状态，并且将包含更新的信息(例如生成的 ID)。 // Request: POST /users { \"email\": \"jdoe@averagecompany.com\", \"name\": \"John Doe\" } // Response { \"id\": \"T9hoBuuTL4\", \"email\": \"jdoe@averagecompany.com\", \"name\": \"John Doe\" } ","date":"2022-03-10","objectID":"/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%8E%A5%E5%8F%A3/:0:21","tags":["经验"],"title":"如何设计更好的接口","uri":"/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%8E%A5%E5%8F%A3/"},{"categories":["经验"],"content":"12. Prefer PATCH over PUT ","date":"2022-03-10","objectID":"/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%8E%A5%E5%8F%A3/:0:22","tags":["经验"],"title":"如何设计更好的接口","uri":"/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%8E%A5%E5%8F%A3/"},{"categories":["经验"],"content":"12. 更喜欢 PATCH 而不是 PUT As mentioned earlier, PATCH requests should apply partial updates to a resource, whereas PUT replaces an existing resource entirely. It’s usually a good idea to design updates around PATCH requests, because: 如前所述，PATCH 请求应该对资源应用部分更新，而 PUT 则完全替换现有资源。围绕 PATCH 请求设计更新通常是个好主意，因为: When using 使用时PUT to update only a subset of fields for a resource, the entire resource still needs to be passed, which makes it more network-intensive and error-prone 为了只更新资源的字段子集，仍然需要传递整个资源，这使得它更加网络密集和容易出错 It’s also quite dangerous to allow any field to be updated without any restrictions 允许任何字段在没有任何限制的情况下进行更新也是相当危险的 From my experience, there barely exist any use cases in practice where a full update on a resource would make sense 根据我的经验，在实践中几乎不存在任何资源的完整更新有意义的用例 Imagine an 想象一下order resource that has an 资源，有一个id and a 和一个state It would be very dangerous to allow consumers to update the 允许消费者更新state of an 一个order A state change would much more likely be triggered by another endpoint (such as 状态更改更有可能由另一个端点触发(例如/orders/{id}/fulfill) ","date":"2022-03-10","objectID":"/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%8E%A5%E5%8F%A3/:0:23","tags":["经验"],"title":"如何设计更好的接口","uri":"/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%8E%A5%E5%8F%A3/"},{"categories":["经验"],"content":"13. Be as specific as possible ","date":"2022-03-10","objectID":"/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%8E%A5%E5%8F%A3/:0:24","tags":["经验"],"title":"如何设计更好的接口","uri":"/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%8E%A5%E5%8F%A3/"},{"categories":["经验"],"content":"13. 尽可能具体 As outlined in the previous section, it’s generally a good idea to be as specific as possible when designing endpoints, naming fields, and deciding which requests and responses to accept. If a PATCH request only accepts two fields (name and description), there is no danger of using it incorrectly and corrupting data. 如上一节所述，在设计端点、命名字段以及决定接受哪些请求和响应时，最好尽可能具体。如果一个 PATCH 请求只接受两个字段(名称和描述) ，那么就不存在错误使用和损坏数据的危险。 ","date":"2022-03-10","objectID":"/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%8E%A5%E5%8F%A3/:0:25","tags":["经验"],"title":"如何设计更好的接口","uri":"/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%8E%A5%E5%8F%A3/"},{"categories":["经验"],"content":"14. Use pagination ","date":"2022-03-10","objectID":"/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%8E%A5%E5%8F%A3/:0:26","tags":["经验"],"title":"如何设计更好的接口","uri":"/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%8E%A5%E5%8F%A3/"},{"categories":["经验"],"content":"14. 使用分页 Paginate all requests that return a collection of resources and use the same response structure. Use page_number and page_size (or similar) to control which chunk you want to retrieve. 对所有返回资源集合的请求分页，并使用相同的响应结构。使用页码和页大小(或类似)来控制要检索的块。 // Request =\u003e GET /users?page_number=1\u0026page_size=15 // Response \u003c= 200 OK { \"page_number\": 1, \"page_size\": 15, \"count\": 378, \"data\": [ // resources ], \"total_pages\": 26, \"has_previous_page\": true, \"has_next_page\": true } ","date":"2022-03-10","objectID":"/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%8E%A5%E5%8F%A3/:0:27","tags":["经验"],"title":"如何设计更好的接口","uri":"/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%8E%A5%E5%8F%A3/"},{"categories":["经验"],"content":"15. Allow expanding resources ","date":"2022-03-10","objectID":"/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%8E%A5%E5%8F%A3/:0:28","tags":["经验"],"title":"如何设计更好的接口","uri":"/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%8E%A5%E5%8F%A3/"},{"categories":["经验"],"content":"15. 允许增加资源 Allow consumers to load related data using a query parameter called expand (or similar). This is especially useful to avoid round-trips and load all data that is necessary for a specific action in one go. 允许使用者使用称为 expand (或类似)的查询参数加载相关数据。这对于避免往返和一次性加载特定操作所需的所有数据尤其有用。 // Request =\u003e GET /users/T9hoBuuTL4?expand=orders\u0026expand=orders.items // Response \u003c= 200 OK { \"id\": \"T9hoBuuTL4\", \"email\": \"jdoe@averagecompany.com\", \"name\": \"John Doe\", \"orders\": [ { \"id\": \"Hy3SSXU1PF\", \"items\": [ { \"name\": \"API course\" }, { \"name\": \"iPhone 13\" } ] }, { \"id\": \"bx1zKmJLI6\", \"items\": [ { \"name\": \"SaaS subscription\" } ] } ] } ","date":"2022-03-10","objectID":"/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%8E%A5%E5%8F%A3/:0:29","tags":["经验"],"title":"如何设计更好的接口","uri":"/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%8E%A5%E5%8F%A3/"},{"categories":["JavaScript"],"content":"你也许不需要 jQuery （You (Might) Don’t Need jQuery） 前端发展很快，现代浏览器原生 API 已经足够好用。我们并不需要为了操作 DOM、Event 等再学习一下 jQuery 的 API。同时由于 React、Angular、Vue 等框架的流行，直接操作 DOM 不再是好的模式，jQuery 使用场景大大减少。本项目总结了大部分 jQuery API 替代的方法，暂时只支持 IE10 以上浏览器。 ","date":"2022-01-19","objectID":"/%E4%BD%A0%E4%B9%9F%E8%AE%B8%E4%B8%8D%E9%9C%80%E8%A6%81-jquery/:1:0","tags":["JavaScript","编程"],"title":"你也许不需要 jQuery ","uri":"/%E4%BD%A0%E4%B9%9F%E8%AE%B8%E4%B8%8D%E9%9C%80%E8%A6%81-jquery/"},{"categories":["JavaScript"],"content":"目录 翻译 Query 选择器 CSS \u0026 Style DOM 操作 Ajax 事件 实用工具 Promises 动画 替代品 浏览器支持 ","date":"2022-01-19","objectID":"/%E4%BD%A0%E4%B9%9F%E8%AE%B8%E4%B8%8D%E9%9C%80%E8%A6%81-jquery/:2:0","tags":["JavaScript","编程"],"title":"你也许不需要 jQuery ","uri":"/%E4%BD%A0%E4%B9%9F%E8%AE%B8%E4%B8%8D%E9%9C%80%E8%A6%81-jquery/"},{"categories":["JavaScript"],"content":"Query 选择器 常用的 class、id、属性 选择器都可以使用 document.querySelector 或 document.querySelectorAll 替代。区别是 document.querySelector 返回第一个匹配的 Element document.querySelectorAll 返回所有匹配的 Element 组成的 NodeList。它可以通过 [].slice.call() 把它转成 Array 如果匹配不到任何 Element，jQuery 返回空数组 []，但 document.querySelector 返回 null，注意空指针异常。当找不到时，也可以使用 || 设置默认的值，如 document.querySelectorAll(selector) || [] 注意：document.querySelector 和 document.querySelectorAll 性能很差。如果想提高性能，尽量使用 document.getElementById、document.getElementsByClassName 或 document.getElementsByTagName。 1.0 选择器查询 // jQuery $('selector'); // Native document.querySelectorAll('selector'); 1.1 class 查询 // jQuery $('.class'); // Native document.querySelectorAll('.class'); // or document.getElementsByClassName('class'); 1.2 id 查询 // jQuery $('#id'); // Native document.querySelector('#id'); // or document.getElementById('id'); // or window['id'] 1.3 属性查询 // jQuery $('a[target=_blank]'); // Native document.querySelectorAll('a[target=_blank]'); 1.4 后代查询 // jQuery $el.find('li'); // Native el.querySelectorAll('li'); 1.5 兄弟及上下元素 兄弟元素 // jQuery $el.siblings(); // Native - latest, Edge13+ [...el.parentNode.children].filter((child) =\u003e child !== el ); // Native (alternative) - latest, Edge13+ Array.from(el.parentNode.children).filter((child) =\u003e child !== el ); // Native - IE10+ Array.prototype.filter.call(el.parentNode.children, (child) =\u003e child !== el ); 上一个元素 // jQuery $el.prev(); // Native el.previousElementSibling; 下一个元素 // next $el.next(); // Native el.nextElementSibling; 1.6 Closest Closest 获得匹配选择器的第一个祖先元素，从当前元素开始沿 DOM 树向上。 // jQuery $el.closest(queryString); // Native - Only latest, NO IE el.closest(selector); // Native - IE10+ function closest(el, selector) { const matchesSelector = el.matches || el.webkitMatchesSelector || el.mozMatchesSelector || el.msMatchesSelector; while (el) { if (matchesSelector.call(el, selector)) { return el; } else { el = el.parentElement; } } return null; } 1.7 Parents Until 获取当前每一个匹配元素集的祖先，不包括匹配元素的本身。 // jQuery $el.parentsUntil(selector, filter); // Native function parentsUntil(el, selector, filter) { const result = []; const matchesSelector = el.matches || el.webkitMatchesSelector || el.mozMatchesSelector || el.msMatchesSelector; // match start from parent el = el.parentElement; while (el \u0026\u0026 !matchesSelector.call(el, selector)) { if (!filter) { result.push(el); } else { if (matchesSelector.call(el, filter)) { result.push(el); } } el = el.parentElement; } return result; } 1.8 Form Input/Textarea // jQuery $('#my-input').val(); // Native document.querySelector('#my-input').value; 获取 e.currentTarget 在 .radio 中的数组索引 // jQuery $('.radio').index(e.currentTarget); // Native Array.prototype.indexOf.call(document.querySelectorAll('.radio'), e.currentTarget); 1.9 Iframe Contents jQuery 对象的 iframe contents() 返回的是 iframe 内的 document Iframe contents // jQuery $iframe.contents(); // Native iframe.contentDocument; Iframe Query // jQuery $iframe.contents().find('.css'); // Native iframe.contentDocument.querySelectorAll('.css'); 1.10 获取 body // jQuery $('body'); // Native document.body; 1.11 获取或设置属性 获取属性 // jQuery $el.attr('foo'); // Native el.getAttribute('foo'); 设置属性 // jQuery, note that this works in memory without change the DOM $el.attr('foo', 'bar'); // Native el.setAttribute('foo', 'bar'); 获取 data- 属性 // jQuery $el.data('foo'); // Native (use `getAttribute`) el.getAttribute('data-foo'); // Native (use `dataset` if only need to support IE 11+) el.dataset['foo']; ⬆ 回到顶部 ","date":"2022-01-19","objectID":"/%E4%BD%A0%E4%B9%9F%E8%AE%B8%E4%B8%8D%E9%9C%80%E8%A6%81-jquery/:3:0","tags":["JavaScript","编程"],"title":"你也许不需要 jQuery ","uri":"/%E4%BD%A0%E4%B9%9F%E8%AE%B8%E4%B8%8D%E9%9C%80%E8%A6%81-jquery/"},{"categories":["JavaScript"],"content":"CSS \u0026 Style 2.1 CSS Get style // jQuery $el.css(\"color\"); // Native // 注意：此处为了解决当 style 值为 auto 时，返回 auto 的问题 const win = el.ownerDocument.defaultView; // null 的意思是不返回伪类元素 win.getComputedStyle(el, null).color; Set style // jQuery $el.css({ color: \"#ff0011\" }); // Native el.style.color = '#ff0011'; Get/Set Styles 注意，如果想一次设置多个 style，可以参考 oui-dom-utils 中 setStyles 方法 Add class // jQuery $el.addClass(className); // Native el.classList.add(className); Remove class // jQuery $el.removeClass(className); // Native el.classList.remove(className); has class // jQuery $el.hasClass(className); // Native el.classList.contains(className); Toggle class // jQuery $el.toggleClass(className); // Native el.classList.toggle(className); 2.2 Width \u0026 Height Width 与 Height 获取方法相同，下面以 Height 为例： Window height // window height $(window).height(); // 不含 scrollbar，与 jQuery 行为一致 window.document.documentElement.clientHeight; // 含 scrollbar window.innerHeight; Document height // jQuery $(document).height(); // Native const body = document.body; const html = document.documentElement; const height = Math.max( body.offsetHeight, body.scrollHeight, html.clientHeight, html.offsetHeight, html.scrollHeight ); Element height // jQuery $el.height(); // Native function getHeight(el) { const styles = this.getComputedStyle(el); const height = el.offsetHeight; const borderTopWidth = parseFloat(styles.borderTopWidth); const borderBottomWidth = parseFloat(styles.borderBottomWidth); const paddingTop = parseFloat(styles.paddingTop); const paddingBottom = parseFloat(styles.paddingBottom); return height - borderBottomWidth - borderTopWidth - paddingTop - paddingBottom; } // 精确到整数（border-box 时为 height - border 值，content-box 时为 height + padding 值） el.clientHeight; // 精确到小数（border-box 时为 height 值，content-box 时为 height + padding + border 值） el.getBoundingClientRect().height; 2.3 Position \u0026 Offset Position 获得匹配元素相对父元素的偏移 // jQuery $el.position(); // Native { left: el.offsetLeft, top: el.offsetTop } Offset 获得匹配元素相对文档的偏移 // jQuery $el.offset(); // Native function getOffset (el) { const box = el.getBoundingClientRect(); return { top: box.top + window.pageYOffset - document.documentElement.clientTop, left: box.left + window.pageXOffset - document.documentElement.clientLeft } } 2.4 Scroll Top 获取元素滚动条垂直位置。 // jQuery $(window).scrollTop(); // Native (document.documentElement \u0026\u0026 document.documentElement.scrollTop) || document.body.scrollTop; ⬆ 回到顶部 ","date":"2022-01-19","objectID":"/%E4%BD%A0%E4%B9%9F%E8%AE%B8%E4%B8%8D%E9%9C%80%E8%A6%81-jquery/:4:0","tags":["JavaScript","编程"],"title":"你也许不需要 jQuery ","uri":"/%E4%BD%A0%E4%B9%9F%E8%AE%B8%E4%B8%8D%E9%9C%80%E8%A6%81-jquery/"},{"categories":["JavaScript"],"content":"DOM 操作 3.1 Remove 从 DOM 中移除元素。 // jQuery $el.remove(); // Native el.parentNode.removeChild(el); // Native - Only latest, NO IE el.remove(); 3.2 Text Get text 返回指定元素及其后代的文本内容。 // jQuery $el.text(); // Native el.textContent; Set text 设置元素的文本内容。 // jQuery $el.text(string); // Native el.textContent = string; 3.3 HTML Get HTML // jQuery $el.html(); // Native el.innerHTML; Set HTML // jQuery $el.html(htmlString); // Native el.innerHTML = htmlString; 3.4 Append Append 插入到子节点的末尾 // jQuery $el.append(\"\u003cdiv id='container'\u003ehello\u003c/div\u003e\"); // Native (HTML string) el.insertAdjacentHTML('beforeend', '\u003cdiv id=\"container\"\u003eHello World\u003c/div\u003e'); // Native (Element) el.appendChild(newEl); 3.5 Prepend // jQuery $el.prepend(\"\u003cdiv id='container'\u003ehello\u003c/div\u003e\"); // Native (HTML string) el.insertAdjacentHTML('afterbegin', '\u003cdiv id=\"container\"\u003eHello World\u003c/div\u003e'); // Native (Element) el.insertBefore(newEl, el.firstChild); 3.6 insertBefore 在选中元素前插入新节点 // jQuery $newEl.insertBefore(queryString); // Native (HTML string) el.insertAdjacentHTML('beforebegin ', '\u003cdiv id=\"container\"\u003eHello World\u003c/div\u003e'); // Native (Element) const el = document.querySelector(selector); if (el.parentNode) { el.parentNode.insertBefore(newEl, el); } 3.7 insertAfter 在选中元素后插入新节点 // jQuery $newEl.insertAfter(queryString); // Native (HTML string) el.insertAdjacentHTML('afterend', '\u003cdiv id=\"container\"\u003eHello World\u003c/div\u003e'); // Native (Element) const el = document.querySelector(selector); if (el.parentNode) { el.parentNode.insertBefore(newEl, el.nextSibling); } 3.8 is 如果匹配给定的选择器，返回true // jQuery $el.is(selector); // Native el.matches(selector); 3.9 clone 深拷贝被选元素。（生成被选元素的副本，包含子节点、文本和属性。） //jQuery $el.clone(); //Native //深拷贝添加参数'true' el.cloneNode(); 3.10 empty 移除所有子节点 //jQuery $el.empty(); //Native el.innerHTML = ''; 3.11 wrap 把每个被选元素放置在指定的HTML结构中。 //jQuery $(\".inner\").wrap('\u003cdiv class=\"wrapper\"\u003e\u003c/div\u003e'); //Native Array.from(document.querySelectorAll('.inner')).forEach((el) =\u003e { const wrapper = document.createElement('div'); wrapper.className = 'wrapper'; el.parentNode.insertBefore(wrapper, el); el.parentNode.removeChild(el); wrapper.appendChild(el); }); 3.12 unwrap 移除被选元素的父元素的DOM结构 // jQuery $('.inner').unwrap(); // Native Array.prototype.forEach.call(document.querySelectorAll('.inner'), (el) =\u003e { let elParentNode = el.parentNode if(elParentNode !== document.body) { elParentNode.parentNode.insertBefore(el, elParentNode) elParentNode.parentNode.removeChild(elParentNode) } }); 3.13 replaceWith 用指定的元素替换被选的元素 //jQuery $('.inner').replaceWith('\u003cdiv class=\"outer\"\u003e\u003c/div\u003e'); //Native Array.prototype.forEach.call(document.querySelectorAll('.inner'),(el) =\u003e { const outer = document.createElement(\"div\"); outer.className = \"outer\"; el.parentNode.insertBefore(outer, el); el.parentNode.removeChild(el); }); 3.14 simple parse 解析 HTML/SVG/XML 字符串 // jQuery $(`\u003col\u003e \u003cli\u003ea\u003c/li\u003e \u003cli\u003eb\u003c/li\u003e \u003c/ol\u003e \u003col\u003e \u003cli\u003ec\u003c/li\u003e \u003cli\u003ed\u003c/li\u003e \u003c/ol\u003e`); // Native range = document.createRange(); parse = range.createContextualFragment.bind(range); parse(`\u003col\u003e \u003cli\u003ea\u003c/li\u003e \u003cli\u003eb\u003c/li\u003e \u003c/ol\u003e \u003col\u003e \u003cli\u003ec\u003c/li\u003e \u003cli\u003ed\u003c/li\u003e \u003c/ol\u003e`); ⬆ 回到顶部 ","date":"2022-01-19","objectID":"/%E4%BD%A0%E4%B9%9F%E8%AE%B8%E4%B8%8D%E9%9C%80%E8%A6%81-jquery/:5:0","tags":["JavaScript","编程"],"title":"你也许不需要 jQuery ","uri":"/%E4%BD%A0%E4%B9%9F%E8%AE%B8%E4%B8%8D%E9%9C%80%E8%A6%81-jquery/"},{"categories":["JavaScript"],"content":"Ajax Fetch API 是用于替换 XMLHttpRequest 处理 ajax 的新标准，Chrome 和 Firefox 均支持，旧浏览器可以使用 polyfills 提供支持。 IE9+ 请使用 github/fetch，IE8+ 请使用 fetch-ie8，JSONP 请使用 fetch-jsonp。 4.1 从服务器读取数据并替换匹配元素的内容。 // jQuery $(selector).load(url, completeCallback) // Native fetch(url).then(data =\u003e data.text()).then(data =\u003e { document.querySelector(selector).innerHTML = data }).then(completeCallback) ⬆ 回到顶部 ","date":"2022-01-19","objectID":"/%E4%BD%A0%E4%B9%9F%E8%AE%B8%E4%B8%8D%E9%9C%80%E8%A6%81-jquery/:6:0","tags":["JavaScript","编程"],"title":"你也许不需要 jQuery ","uri":"/%E4%BD%A0%E4%B9%9F%E8%AE%B8%E4%B8%8D%E9%9C%80%E8%A6%81-jquery/"},{"categories":["JavaScript"],"content":"事件 完整地替代命名空间和事件代理，链接到 https://github.com/oneuijs/oui-dom-events 5.0 Document ready by DOMContentLoaded // jQuery $(document).ready(eventHandler); // Native // 检测 DOMContentLoaded 是否已完成 if (document.readyState !== 'loading') { eventHandler(); } else { document.addEventListener('DOMContentLoaded', eventHandler); } 5.1 使用 on 绑定事件 // jQuery $el.on(eventName, eventHandler); // Native el.addEventListener(eventName, eventHandler); 5.2 使用 off 解绑事件 // jQuery $el.off(eventName, eventHandler); // Native el.removeEventListener(eventName, eventHandler); 5.3 Trigger // jQuery $(el).trigger('custom-event', {key1: 'data'}); // Native if (window.CustomEvent) { const event = new CustomEvent('custom-event', {detail: {key1: 'data'}}); } else { const event = document.createEvent('CustomEvent'); event.initCustomEvent('custom-event', true, true, {key1: 'data'}); } el.dispatchEvent(event); ⬆ 回到顶部 ","date":"2022-01-19","objectID":"/%E4%BD%A0%E4%B9%9F%E8%AE%B8%E4%B8%8D%E9%9C%80%E8%A6%81-jquery/:7:0","tags":["JavaScript","编程"],"title":"你也许不需要 jQuery ","uri":"/%E4%BD%A0%E4%B9%9F%E8%AE%B8%E4%B8%8D%E9%9C%80%E8%A6%81-jquery/"},{"categories":["JavaScript"],"content":"实用工具 大部分实用工具都能在 native API 中找到. 其他高级功能可以选用专注于该领域的稳定性和性能都更好的库来代替，推荐 lodash。 6.1 基本工具 isArray 检测参数是不是数组。 // jQuery $.isArray(range); // Native Array.isArray(range); isWindow 检测参数是不是 window。 // jQuery $.isWindow(obj); // Native function isWindow(obj) { return obj !== null \u0026\u0026 obj !== undefined \u0026\u0026 obj === obj.window; } inArray 在数组中搜索指定值并返回索引 (找不到则返回 -1)。 // jQuery $.inArray(item, array); // Native array.indexOf(item) \u003e -1; // ES6-way array.includes(item); isNumeric 检测传入的参数是不是数字。 Use typeof to decide the type or the type example for better accuracy. // jQuery $.isNumeric(item); // Native function isNumeric(value) { return !isNaN(parseFloat(value)) \u0026\u0026 isFinite(value); } isFunction 检测传入的参数是不是 JavaScript 函数对象。 // jQuery $.isFunction(item); // Native function isFunction(item) { if (typeof item === 'function') { return true; } var type = Object.prototype.toString(item); return type === '[object Function]' || type === '[object GeneratorFunction]'; } isEmptyObject 检测对象是否为空 (包括不可枚举属性). // jQuery $.isEmptyObject(obj); // Native function isEmptyObject(obj) { return Object.keys(obj).length === 0; } isPlainObject 检测是不是扁平对象 (使用 “{}” 或 “new Object” 创建). // jQuery $.isPlainObject(obj); // Native function isPlainObject(obj) { if (typeof (obj) !== 'object' || obj.nodeType || obj !== null \u0026\u0026 obj !== undefined \u0026\u0026 obj === obj.window) { return false; } if (obj.constructor \u0026\u0026 !Object.prototype.hasOwnProperty.call(obj.constructor.prototype, 'isPrototypeOf')) { return false; } return true; } extend 合并多个对象的内容到第一个对象。 object.assign 是 ES6 API，也可以使用 polyfill。 // jQuery $.extend({}, defaultOpts, opts); // Native Object.assign({}, defaultOpts, opts); trim 移除字符串头尾空白。 // jQuery $.trim(string); // Native string.trim(); map 将数组或对象转化为包含新内容的数组。 // jQuery $.map(array, (value, index) =\u003e { }); // Native array.map((value, index) =\u003e { }); each 轮询函数，可用于平滑的轮询对象和数组。 // jQuery $.each(array, (index, value) =\u003e { }); // Native array.forEach((value, index) =\u003e { }); grep 找到数组中符合过滤函数的元素。 // jQuery $.grep(array, (value, index) =\u003e { }); // Native array.filter((value, index) =\u003e { }); type 检测对象的 JavaScript [Class] 内部类型。 // jQuery $.type(obj); // Native function type(item) { const reTypeOf = /(?:^\\[object\\s(.*?)\\]$)/; return Object.prototype.toString.call(item) .replace(reTypeOf, '$1') .toLowerCase(); } merge 合并第二个数组内容到第一个数组。 // jQuery $.merge(array1, array2); // Native // 使用 concat，不能去除重复值 function merge(...args) { return [].concat(...args) } // ES6，同样不能去除重复值 array1 = [...array1, ...array2] // 使用 Set，可以去除重复值 function merge(...args) { return Array.from(new Set([].concat(...args))) } now 返回当前时间的数字呈现。 // jQuery $.now(); // Native Date.now(); proxy 传入函数并返回一个新函数，该函数绑定指定上下文。 // jQuery $.proxy(fn, context); // Native fn.bind(context); makeArray 类数组对象转化为真正的 JavaScript 数组。 // jQuery $.makeArray(arrayLike); // Native Array.prototype.slice.call(arrayLike); // ES6-way Array.from(arrayLike); 6.2 包含 检测 DOM 元素是不是其他 DOM 元素的后代. // jQuery $.contains(el, child); // Native el !== child \u0026\u0026 el.contains(child); 6.3 Globaleval 全局执行 JavaScript 代码。 // jQuery $.globaleval(code); // Native function Globaleval(code) { const script = document.createElement('script'); script.text = code; document.head.appendChild(script).parentNode.removeChild(script); } // Use eval, but context of eval is current, context of $.Globaleval is global. eval(code); 6.4 解析 parseHTML 解析字符串为 DOM 节点数组. // jQuery $.parseHTML(htmlString); // Native function parseHTML(string) { const context = document.implementation.createHTMLDocument(); // Set the base href for the created document so any parsed elements with URLs // are based on the document's URL const base = context.createElement('base'); base.href = document.location.href; context.head.appendChild(base); context.body.innerHTML = string; return context.body.children; } parseJSON 传入格式正确的 JSON 字符串并返回 JavaScript 值. // jQuery $.parseJSON(str); // Native JSON.parse(str); ⬆ 回到顶部 ","date":"2022-01-19","objectID":"/%E4%BD%A0%E4%B9%9F%E8%AE%B8%E4%B8%8D%E9%9C%80%E8%A6%81-jquery/:8:0","tags":["JavaScript","编程"],"title":"你也许不需要 jQuery ","uri":"/%E4%BD%A0%E4%B9%9F%E8%AE%B8%E4%B8%8D%E9%9C%80%E8%A6%81-jquery/"},{"categories":["JavaScript"],"content":"Promises Promise 代表异步操作的最终结果。jQuery 用它自己的方式处理 promises，原生 JavaScript 遵循 Promises/A+ 标准实现了最小 API 来处理 promises。 7.1 done, fail, always done 会在 promise 解决时调用，fail 会在 promise 拒绝时调用，always 总会调用。 // jQuery $promise.done(doneCallback).fail(failCallback).always(alwaysCallback) // Native promise.then(doneCallback, failCallback).then(alwaysCallback, alwaysCallback) 7.2 when when 用于处理多个 promises。当全部 promises 被解决时返回，当任一 promise 被拒绝时拒绝。 // jQuery $.when($promise1, $promise2).done((promise1Result, promise2Result) =\u003e { }); // Native Promise.all([$promise1, $promise2]).then([promise1Result, promise2Result] =\u003e {}); 7.3 Deferred Deferred 是创建 promises 的一种方式。 // jQuery function asyncFunc() { const defer = new $.Deferred(); setTimeout(() =\u003e { if(true) { defer.resolve('some_value_computed_asynchronously'); } else { defer.reject('failed'); } }, 1000); return defer.promise(); } // Native function asyncFunc() { return new Promise((resolve, reject) =\u003e { setTimeout(() =\u003e { if (true) { resolve('some_value_computed_asynchronously'); } else { reject('failed'); } }, 1000); }); } // Deferred way function defer() { const deferred = {}; const promise = new Promise((resolve, reject) =\u003e { deferred.resolve = resolve; deferred.reject = reject; }); deferred.promise = () =\u003e { return promise; }; return deferred; } function asyncFunc() { const defer = defer(); setTimeout(() =\u003e { if(true) { defer.resolve('some_value_computed_asynchronously'); } else { defer.reject('failed'); } }, 1000); return defer.promise(); } ⬆ 回到顶部 ","date":"2022-01-19","objectID":"/%E4%BD%A0%E4%B9%9F%E8%AE%B8%E4%B8%8D%E9%9C%80%E8%A6%81-jquery/:9:0","tags":["JavaScript","编程"],"title":"你也许不需要 jQuery ","uri":"/%E4%BD%A0%E4%B9%9F%E8%AE%B8%E4%B8%8D%E9%9C%80%E8%A6%81-jquery/"},{"categories":["JavaScript"],"content":"动画 8.1 Show \u0026 Hide // jQuery $el.show(); $el.hide(); // Native // 更多 show 方法的细节详见 https://github.com/oneuijs/oui-dom-utils/blob/master/src/index.js#L363 el.style.display = ''|'inline'|'inline-block'|'inline-table'|'block'; el.style.display = 'none'; 8.2 Toggle 显示或隐藏元素。 // jQuery $el.toggle(); // Native if (el.ownerDocument.defaultView.getComputedStyle(el, null).display === 'none') { el.style.display = ''|'inline'|'inline-block'|'inline-table'|'block'; } else { el.style.display = 'none'; } 8.3 FadeIn \u0026 FadeOut // jQuery $el.fadeIn(3000); $el.fadeOut(3000); // Native el.style.transition = 'opacity 3s'; // fadeIn el.style.opacity = '1'; // fadeOut el.style.opacity = '0'; 8.4 FadeTo 调整元素透明度。 // jQuery $el.fadeTo('slow',0.15); // Native el.style.transition = 'opacity 3s'; // 假设 'slow' 等于 3 秒 el.style.opacity = '0.15'; 8.5 FadeToggle 动画调整透明度用来显示或隐藏。 // jQuery $el.fadeToggle(); // Native el.style.transition = 'opacity 3s'; const { opacity } = el.ownerDocument.defaultView.getComputedStyle(el, null); if (opacity === '1') { el.style.opacity = '0'; } else { el.style.opacity = '1'; } 8.6 SlideUp \u0026 SlideDown // jQuery $el.slideUp(); $el.slideDown(); // Native const originHeight = '100px'; el.style.transition = 'height 3s'; // slideUp el.style.height = '0px'; // slideDown el.style.height = originHeight; 8.7 SlideToggle 滑动切换显示或隐藏。 // jQuery $el.slideToggle(); // Native const originHeight = '100px'; el.style.transition = 'height 3s'; const { height } = el.ownerDocument.defaultView.getComputedStyle(el, null); if (parseInt(height, 10) === 0) { el.style.height = originHeight; } else { el.style.height = '0px'; } 8.8 Animate 执行一系列 CSS 属性动画。 // jQuery $el.animate({ params }, speed); // Native el.style.transition = 'all ' + speed; Object.keys(params).forEach((key) =\u003e el.style[key] = params[key]; ) ⬆ 回到顶部 ","date":"2022-01-19","objectID":"/%E4%BD%A0%E4%B9%9F%E8%AE%B8%E4%B8%8D%E9%9C%80%E8%A6%81-jquery/:10:0","tags":["JavaScript","编程"],"title":"你也许不需要 jQuery ","uri":"/%E4%BD%A0%E4%B9%9F%E8%AE%B8%E4%B8%8D%E9%9C%80%E8%A6%81-jquery/"},{"categories":["JavaScript"],"content":"替代品 你可能不需要 jQuery (You Might Not Need jQuery) - 如何使用原生 JavaScript 实现通用事件，元素，ajax 等用法。 npm-dom 以及 webmodules - 在 NPM 上提供独立 DOM 模块的组织 ","date":"2022-01-19","objectID":"/%E4%BD%A0%E4%B9%9F%E8%AE%B8%E4%B8%8D%E9%9C%80%E8%A6%81-jquery/:11:0","tags":["JavaScript","编程"],"title":"你也许不需要 jQuery ","uri":"/%E4%BD%A0%E4%B9%9F%E8%AE%B8%E4%B8%8D%E9%9C%80%E8%A6%81-jquery/"},{"categories":["JavaScript"],"content":"浏览器支持 Latest ✔ Latest ✔ 10+ ✔ Latest ✔ 6.1+ ✔ License MIT ","date":"2022-01-19","objectID":"/%E4%BD%A0%E4%B9%9F%E8%AE%B8%E4%B8%8D%E9%9C%80%E8%A6%81-jquery/:12:0","tags":["JavaScript","编程"],"title":"你也许不需要 jQuery ","uri":"/%E4%BD%A0%E4%B9%9F%E8%AE%B8%E4%B8%8D%E9%9C%80%E8%A6%81-jquery/"},{"categories":["经验"],"content":"You’re about to read a blog post with a lot of advice. Learning from those who came before us is instrumental to success, but we often forget an important caveat. Almost all advice is contextual, yet it is rarely delivered with any context. 你将要读到一篇博客文章，里面有很多建议。向我们的前辈学习有助于成功，但是我们经常忘记一个重要的警告。几乎所有的建议都是上下文相关的，但很少在任何上下文中提供。 “You just need to charge more!” says the company who has been in business for 20 years and spent years charging “too little” to gain customers and become successful. “你只是需要收取更高的费用!”这家公司已经经营了20年，多年来收取的费用“太少”，难以赢得顾客并取得成功。 “You need to build everything as microservices!” says the company who built a quick monolith, gained thousands of customers, and then pivoted into microservices as they started running into scaling issues. “你需要把所有东西都打造成微型服务!”这家公司建立了一个快速整体结构，赢得了数以千计的客户，然后转向微型服务，因为他们开始遇到扩展问题。 Without understanding the context, the advice is meaningless, or even worse, harmful. If those folks had followed their own advice early on, they themselves would likely have suffered from it. It is hard to escape this trap. We may be the culmination of our experiences, but we view them through the lens of the present. 如果不了解背景，这些建议就毫无意义，甚至是有害的。如果这些人在早期就遵循了他们自己的建议，他们自己可能也会遭受这样的痛苦。这个陷阱很难逃脱。我们可能是我们经历的顶点，但我们通过当下的镜头来看待它们。 So to give you a little context on where my advice comes from, I spent the first half of my career as a software engineer working for various small businesses and startups, then I went into consulting and worked in a number of really large businesses. Then I started Simple Thread and we grew from a team of 2 to a team of 25. 10 years ago we worked with mostly small/medium businesses, and now we work with a mix of big and small businesses. 所以，为了给你们一点关于我的建议从何而来的背景知识，我在我职业生涯的前半段是一名软件工程师，为各种小企业和初创企业工作，然后我进入咨询业，并在一些非常大的企业工作。然后我开始了简单线程，我们从一个2人的团队成长为一个25人的团队。10年前我们主要和中小企业合作，现在我们和大小企业合作。 My advice is from someone who… 我的建议来自一个..。 has almost always been on small, lean teams where we have to do a lot with very little. 几乎总是在小规模精干的团队中，我们必须用很少的资源做很多事情。 values working software over specific tools. 重视工作软件胜过特定的工具。 is starting new projects all the time, but also has to maintain a number of systems. 一直在开展新项目，但同时也必须维护一些系统。 values engineer productivity over most other considerations 把工程师的生产力看得比大多数其他因素更重要 My experiences over the last 20 years have shaped how I view software, and have led me to some beliefs which I’ve tried to whittle down to a manageable list that I hope you find valuable. 我过去20年的经历塑造了我对软件的看法，并且让我产生了一些信念，我试图将这些信念精简成一个可管理的清单，希望你们能发现它们的价值。 ","date":"2021-10-11","objectID":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/:0:0","tags":["经验","思考"],"title":"做了20年软件工程师学到的20件事","uri":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/"},{"categories":["经验"],"content":"On with the list ","date":"2021-10-11","objectID":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/:1:0","tags":["经验","思考"],"title":"做了20年软件工程师学到的20件事","uri":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/"},{"categories":["经验"],"content":"继续列表 ","date":"2021-10-11","objectID":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/:2:0","tags":["经验","思考"],"title":"做了20年软件工程师学到的20件事","uri":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/"},{"categories":["经验"],"content":"1. I still don’t know very much ","date":"2021-10-11","objectID":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/:2:1","tags":["经验","思考"],"title":"做了20年软件工程师学到的20件事","uri":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/"},{"categories":["经验"],"content":"1. 我知道的还不多 “How can you not know what BGP is?” “You’ve never heard of Rust?” Most of us have heard these kinds of statements, probably too often. The reason many of us love software is because we are lifelong learners, and in software no matter which direction you look, there are wide vistas of knowledge going off in every direction and expanding by the day. This means that you can spend decades in your career, and still have a huge knowledge gap compared to someone who has also spent decades in a seemingly similar role. The sooner you realize this, the sooner you can start to shed your imposter syndrome and instead delight in learning from and teaching others. “你怎么会不知道什么是边界网关协议呢?”“你从来没有听说过拉斯特?”我们大多数人都听过这种说法，可能太频繁了。我们之所以热爱软件，是因为我们是终身学习者，在软件领域，无论你朝哪个方向看，都能看到知识的广阔前景。这意味着你可以在你的职业生涯中度过几十年，但与那些花了几十年时间从事类似工作的人相比，你仍然存在巨大的知识差距。你越早意识到这一点，你就能越早摆脱你的冒名顶替综合症，而是乐于学习和教导他人。 ","date":"2021-10-11","objectID":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/:2:2","tags":["经验","思考"],"title":"做了20年软件工程师学到的20件事","uri":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/"},{"categories":["经验"],"content":"2. The hardest part of software is building the right thing ","date":"2021-10-11","objectID":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/:2:3","tags":["经验","思考"],"title":"做了20年软件工程师学到的20件事","uri":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/"},{"categories":["经验"],"content":"2. 软件最难的部分是构建正确的东西 I know this is cliche at this point, but the reason most software engineers don’t believe it is because they think it devalues their work. Personally I think that is nonsense. Instead it highlights the complexity and irrationality of the environments in which we have to work, which compounds our challenges. You can design the most technically impressive thing in the world, and then have nobody want to use it. Happens all the time. Designing software is mostly a listening activity, and we often have to be part software engineer, part psychic, and part anthropologist. Investing in this design process, whether through dedicated UX team members or by simply educating yourself, will deliver enormous dividends. Because how do you really calculate the cost of building the wrong software? It amounts to a lot more than just lost engineering time. 我知道这是陈词滥调，但是大多数软件工程师不相信这是因为他们认为它贬低了他们的工作。我个人认为这是无稽之谈。相反，它强调了我们必须工作的环境的复杂性和不合理性，这使我们面临的挑战更加复杂。你可以设计出世界上技术上最令人印象深刻的东西，然后没有人愿意使用它。这种事经常发生。设计软件主要是一种倾听活动，我们经常不得不兼做软件工程师、精神工程师和人类学家。投资这个设计过程，无论是通过专注的 UX 团队成员还是仅仅通过自我教育，都会带来巨大的回报。因为你如何计算构建错误软件的成本呢？这不仅仅意味着浪费了工程时间。 ","date":"2021-10-11","objectID":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/:2:4","tags":["经验","思考"],"title":"做了20年软件工程师学到的20件事","uri":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/"},{"categories":["经验"],"content":"3. The best software engineers think like designers ","date":"2021-10-11","objectID":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/:2:5","tags":["经验","思考"],"title":"做了20年软件工程师学到的20件事","uri":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/"},{"categories":["经验"],"content":"3. 最好的软件工程师像设计师一样思考 Great software engineers think deeply about the user experience of their code. They might not think about it in those terms, but whether it is an external API, programmatic API, user interface, protocol, or any other interface; great engineers consider who will be using it, why it will be used, how it will be used, and what is important to those users. Keeping the user’s needs in mind is really the heart of good user experience. 优秀的软件工程师会深入思考他们的代码的用户体验。他们可能不会用那些术语来考虑它，而是考虑它是否是一个外部的 API，可编程的 API，用户界面，协议，或者其他任何界面; 伟大的工程师会考虑谁将使用它，为什么要使用它，如何使用它，以及对这些用户来说什么是重要的。记住用户的需求是良好用户体验的核心。 ","date":"2021-10-11","objectID":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/:2:6","tags":["经验","思考"],"title":"做了20年软件工程师学到的20件事","uri":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/"},{"categories":["经验"],"content":"4. The best code is no code, or code you don’t have to maintain ","date":"2021-10-11","objectID":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/:2:7","tags":["经验","思考"],"title":"做了20年软件工程师学到的20件事","uri":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/"},{"categories":["经验"],"content":"4. 最好的代码是没有代码，或者你不需要维护的代码 All I have to say is “coders gonna code.” You ask someone in any profession how to solve a problem, and they are going to err on the side of what they are good at. It is just human nature. Most software engineers are always going to err on the side of writing code, especially when a non-technical solution isn’t obvious. The same goes for code you don’t have to maintain. Engineering teams are apt to want to reinvent the wheel, when lots of wheels already exist. This is a balancing act, there are lots of reasons to grow your own, but beware of toxic “Not Invented Here” syndrome. 我要说的就是“程序员会编码。”你问任何职业的人如何解决一个问题，他们都会在自己擅长的方面犯错。这是人类的天性。大多数软件工程师总是会在编写代码方面犯错误，尤其是在非技术性解决方案不明显的情况下。对于不需要维护的代码，情况也是如此。当很多轮子已经存在的时候，工程团队倾向于重新发明轮子。这是一个平衡的行为，有很多理由来种植你自己的，但是要小心有毒的“不是这里发明的”综合症。 ","date":"2021-10-11","objectID":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/:2:8","tags":["经验","思考"],"title":"做了20年软件工程师学到的20件事","uri":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/"},{"categories":["经验"],"content":"5. Software is a means to an end ","date":"2021-10-11","objectID":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/:2:9","tags":["经验","思考"],"title":"做了20年软件工程师学到的20件事","uri":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/"},{"categories":["经验"],"content":"5. 软件是达到目的的手段 The primary job of any software engineer is delivering value. Very few software developers understand this, even fewer internalize it. Truly internalizing this leads to a different way of solving problems, and a different way of viewing your tools. If you really believe that software is subservient to the outcome, you’ll be ready to really find “the right tool for the job” which might not be software at all. 任何软件工程师的主要工作是提供价值。很少有软件开发人员能够理解这一点，甚至很少有软件开发人员能够内化它。真正内化这一点会带来解决问题的不同方式，以及看待工具的不同方式。如果你真的相信软件服从于结果，那么你就准备好真正找到“适合这项工作的工具”，而这个工具可能根本就不是软件。 ","date":"2021-10-11","objectID":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/:2:10","tags":["经验","思考"],"title":"做了20年软件工程师学到的20件事","uri":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/"},{"categories":["经验"],"content":"6. Sometimes you have to stop sharpening the saw, and just start cutting shit ","date":"2021-10-11","objectID":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/:2:11","tags":["经验","思考"],"title":"做了20年软件工程师学到的20件事","uri":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/"},{"categories":["经验"],"content":"6. 有时候你不得不停止磨锯子，而是开始切东西 Some people tend to jump into problems and just start writing code. Other people tend to want to research and research and get caught in analysis paralysis. In those cases, set a deadline for yourself and just start exploring solutions. You’ll quickly learn more as you start solving the problem, and that will lead you to iterate into a better solution. 有些人倾向于直接进入问题并开始编写代码。其他人倾向于研究和调查，结果陷入分析瘫痪。在这种情况下，给自己设定一个最后期限，然后开始寻找解决方案。当你开始解决这个问题的时候，你会很快学到更多的东西，这将引导你迭代出一个更好的解决方案。 ","date":"2021-10-11","objectID":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/:2:12","tags":["经验","思考"],"title":"做了20年软件工程师学到的20件事","uri":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/"},{"categories":["经验"],"content":"7. If you don’t have a good grasp of the universe of what’s possible, you can’t design a good system ","date":"2021-10-11","objectID":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/:2:13","tags":["经验","思考"],"title":"做了20年软件工程师学到的20件事","uri":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/"},{"categories":["经验"],"content":"7. 如果你不能很好地把握宇宙中的可能性，你就无法设计出一个好的系统 This is something I struggle with a lot as my responsibilities take me further and further from the day to day of software engineering. Keeping up with the developer ecosystem is a huge amount of work, but it is critical to understand what is possible. If you don’t understand what is possible and what is available in a given ecosystem then you’ll find it impossible to design a reasonable solution to all but the most simple of problems. To summarize, be wary of people designing systems who haven’t written any code in a long time. 这是我一直在努力解决的问题，因为我的职责使我在软件工程的日常工作中越走越远。保持开发人员生态系统是一项巨大的工作，但是理解什么是可能的是至关重要的。如果你不知道在一个给定的生态系统中什么是可能的，什么是可用的，那么你会发现除了最简单的问题之外，不可能为所有问题设计一个合理的解决方案。总而言之，要小心那些长期没有编写任何代码的系统设计人员。 ","date":"2021-10-11","objectID":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/:2:14","tags":["经验","思考"],"title":"做了20年软件工程师学到的20件事","uri":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/"},{"categories":["经验"],"content":"8. Every system eventually sucks, get over it ","date":"2021-10-11","objectID":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/:2:15","tags":["经验","思考"],"title":"做了20年软件工程师学到的20件事","uri":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/"},{"categories":["经验"],"content":"8. 每个系统最终都会失败，克服它 Bjarne Stroustrup has a quote that goes “There are only two kinds of languages: the ones people complain about and the ones nobody uses”. This can be extended to large systems as well. There is no “right” architecture, you’ll never pay down all of your technical debt, you’ll never design the perfect interface, your tests will always be too slow. This isn’t an excuse to never make things better, but instead a way to give you perspective. Worry less about elegance and perfection; instead strive for continuous improvement and creating a livable system that your team enjoys working in and sustainably delivers value. 比雅尼·斯特劳斯特鲁普有这样一句话: 世界上只有两种语言: 一种是人们抱怨的语言，另一种是没有人使用的语言。这也可以推广到大型系统。没有“正确”的架构，你永远不会偿还所有的技术债务，你永远不会设计出完美的界面，你的测试总是太慢。这不是一个永远不能让事情变得更好的借口，而是一种给你观点的方式。少担心优雅和完美; 相反，努力持续改进，创造一个适宜居住的系统，让你的团队享受工作并可持续地提供价值。 ","date":"2021-10-11","objectID":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/:2:16","tags":["经验","思考"],"title":"做了20年软件工程师学到的20件事","uri":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/"},{"categories":["经验"],"content":"9. Nobody asks “why” enough ","date":"2021-10-11","objectID":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/:2:17","tags":["经验","思考"],"title":"做了20年软件工程师学到的20件事","uri":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/"},{"categories":["经验"],"content":"9. 没有人足够多地问为什么 Take any opportunity to question assumptions and approaches that are “the way things have always been done”. Have a new team member coming on board? Pay attention to where they get confused and what questions they ask. Have a new feature request that doesn’t make sense? Make sure you understand the goal and what is driving the desire for this functionality. If you don’t get a clear answer, keep asking why until you understand. 抓住任何机会质疑那些“一直以来都是这样做的”的假设和方法。有新的团队成员加入吗？注意他们在哪里感到困惑，他们问了什么问题。有一个没有意义的新特性请求？确保你理解这个目标，以及是什么驱动了对这个功能的渴望。如果你没有得到一个明确的答案，不断地问为什么，直到你明白为止。 ","date":"2021-10-11","objectID":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/:2:18","tags":["经验","思考"],"title":"做了20年软件工程师学到的20件事","uri":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/"},{"categories":["经验"],"content":"10. We should be far more focused on avoiding 0.1x programmers than finding 10x programmers ","date":"2021-10-11","objectID":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/:2:19","tags":["经验","思考"],"title":"做了20年软件工程师学到的20件事","uri":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/"},{"categories":["经验"],"content":"10. 我们应该更专注于避免0.1 x 的程序员，而不是寻找10倍的程序员 The 10x programmer is a silly myth. The idea that someone can produce in 1 day what another competent, hard working, similarly experienced programmer can produce in 2 weeks is silly. I’ve seen programmers that sling 10x the amount of code, and then you have to fix it 10x the amount of times. The only way someone can be a 10x programmer is if you compare them to 0.1x programmers. Someone who wastes time, doesn’t ask for feedback, doesn’t test their code, doesn’t consider edge cases, etc… We should be far more concerned with keeping 0.1x programmers off our teams than finding the mythical 10x programmer. 10倍的程序员是一个愚蠢的神话。认为一个人可以在一天内完成另一个有能力、勤奋、同样有经验的程序员在两周内完成的工作，这种想法是愚蠢的。我曾经见过程序员把代码量增加10倍，然后你必须把它修复10倍的次数。一个人能成为10倍程序员的唯一方法就是将他们与0.1倍程序员进行比较。有些人浪费时间，不要求反馈，不测试他们的代码，不考虑边缘情况，等等。.我们更应该关心的是让0.1 x 的程序员远离我们的团队，而不是寻找神话般的10倍程序员。 ","date":"2021-10-11","objectID":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/:2:20","tags":["经验","思考"],"title":"做了20年软件工程师学到的20件事","uri":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/"},{"categories":["经验"],"content":"11. One of the biggest differences between a senior engineer and a junior engineer is that they’ve formed opinions about the way things should be ","date":"2021-10-11","objectID":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/:2:21","tags":["经验","思考"],"title":"做了20年软件工程师学到的20件事","uri":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/"},{"categories":["经验"],"content":"图11。高级工程师和初级工程师最大的区别之一是，他们已经形成了对事情应该是什么样子的看法 Nothing worries me more than a senior engineer that has no opinion of their tools or how to approach building software. I’d rather someone give me opinions that I violently disagree with than for them to have no opinions at all. If you are using your tools, and you don’t love or hate them in a myriad of ways, you need to experience more. You need to explore other languages, libraries, and paradigms. There are few ways of leveling up your skills faster than actively seeking out how others accomplish tasks with different tools and techniques than you do. 没有什么比一个高级工程师对他们的工具或者如何构建软件没有意见更让我担心的了。我宁愿有人给我一些我强烈反对的意见，也不愿他们没有任何意见。如果你正在使用你的工具，并且你不以无数种方式爱或恨它们，你需要体验更多。您需要探索其他语言、库和范例。几乎没有什么方法可以比你更快地升级你的技能，而是积极地寻找其他人是如何用不同的工具和技术完成任务的。 ","date":"2021-10-11","objectID":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/:2:22","tags":["经验","思考"],"title":"做了20年软件工程师学到的20件事","uri":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/"},{"categories":["经验"],"content":"12. People don’t really want innovation ","date":"2021-10-11","objectID":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/:2:23","tags":["经验","思考"],"title":"做了20年软件工程师学到的20件事","uri":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/"},{"categories":["经验"],"content":"12. 人们并不真的需要创新 People talk about innovation a whole lot, but what they are usually looking for is cheap wins and novelty. If you truly innovate, and change the way that people have to do things, expect mostly negative feedback. If you believe in what you’re doing, and know it will really improve things, then brace yourself for a long battle. 人们总是谈论创新，但是他们通常寻找的是廉价的胜利和新奇。如果你真的在创新，改变人们做事的方式，最好期待负面的反馈。如果你相信你正在做的事情，并且知道它真的会改善事情，那么就做好准备迎接一场长期的战斗。 ","date":"2021-10-11","objectID":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/:2:24","tags":["经验","思考"],"title":"做了20年软件工程师学到的20件事","uri":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/"},{"categories":["经验"],"content":"13. Your data is the most important part of your system ","date":"2021-10-11","objectID":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/:2:25","tags":["经验","思考"],"title":"做了20年软件工程师学到的20件事","uri":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/"},{"categories":["经验"],"content":"13. 你的数据是你系统中最重要的部分 I’ve seen a lot of systems where hope was the primary mechanism of data integrity. In systems like this, anything that happens off the golden path creates partial or dirty data. Dealing with this data in the future can become a nightmare. Just remember, your data will likely long outlive your codebase. Spend energy keeping it orderly and clean, it’ll pay off well in the long run. 我见过很多系统，希望是数据完整性的主要机制。在这样的系统中，黄金路径之外发生的任何事情都会创建部分或脏数据。未来处理这些数据可能会成为一场噩梦。请记住，您的数据可能会比代码库更长寿。花费精力保持它的有序和清洁，从长远来看，它会得到很好的回报。 ","date":"2021-10-11","objectID":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/:2:26","tags":["经验","思考"],"title":"做了20年软件工程师学到的20件事","uri":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/"},{"categories":["经验"],"content":"14. Look for technological sharks ","date":"2021-10-11","objectID":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/:2:27","tags":["经验","思考"],"title":"做了20年软件工程师学到的20件事","uri":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/"},{"categories":["经验"],"content":"14. 寻找科技鲨鱼 Old technologies that have stuck around are sharks, not dinosaurs. They solve problems so well that they have survived the rapid changes that occur constantly in the technology world. Don’t bet against these technologies, and replace them only if you have a very good reason. These tools won’t be flashy, and they won’t be exciting, but they will get the job done without a lot of sleepless nights. 一直存在的老技术是鲨鱼，而不是恐龙。他们解决问题的能力如此之强，以至于他们在技术世界不断发生的快速变化中幸存了下来。不要对这些技术打赌，只有在你有很好的理由的情况下才替换它们。这些工具不会华而不实，也不会令人兴奋，但它们可以在没有许多不眠之夜的情况下完成工作。 ","date":"2021-10-11","objectID":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/:2:28","tags":["经验","思考"],"title":"做了20年软件工程师学到的20件事","uri":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/"},{"categories":["经验"],"content":"15. Don’t mistake humility for ignorance ","date":"2021-10-11","objectID":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/:2:29","tags":["经验","思考"],"title":"做了20年软件工程师学到的20件事","uri":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/"},{"categories":["经验"],"content":"15. 不要把谦卑误认为无知 There are a lot of software engineers out there who won’t express opinions unless asked. Never assume that just because someone isn’t throwing their opinions in your face that they don’t have anything to add. Sometimes the noisiest people are the ones we want to listen to the least. Talk to the people around you, seek their feedback and advice. You’ll be glad you did. 有很多软件工程师除非被问到，否则不会表达自己的观点。永远不要因为别人没有把他们的意见扔到你面前，就认为他们没有什么要补充的。有时候最吵的人恰恰是我们最不想听的人。与你周围的人交谈，寻求他们的反馈和建议。你会很高兴你这么做的。 ","date":"2021-10-11","objectID":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/:2:30","tags":["经验","思考"],"title":"做了20年软件工程师学到的20件事","uri":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/"},{"categories":["经验"],"content":"16. Software engineers should write regularly ","date":"2021-10-11","objectID":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/:2:31","tags":["经验","思考"],"title":"做了20年软件工程师学到的20件事","uri":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/"},{"categories":["经验"],"content":"16. 软件工程师应该定期写作 Software engineers should regularly blog, journal, write documentation and in general do anything that requires them to keep their written communication skills sharp. Writing helps you think about your problems, and helps you communicate those more effectively with your team and your future self. Good written communication is one of the most important skills for any software engineer to master. 软件工程师应该定期写博客、日志、写文档，并且一般地做任何需要他们保持书面沟通技巧敏锐的事情。写作可以帮助你思考你的问题，并帮助你更有效地与你的团队和你未来的自己沟通。对于任何软件工程师来说，良好的书面沟通能力是最重要的技能之一。 ","date":"2021-10-11","objectID":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/:2:32","tags":["经验","思考"],"title":"做了20年软件工程师学到的20件事","uri":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/"},{"categories":["经验"],"content":"17. Keep your processes as lean as possible ","date":"2021-10-11","objectID":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/:2:33","tags":["经验","思考"],"title":"做了20年软件工程师学到的20件事","uri":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/"},{"categories":["经验"],"content":"17. 保持你的过程尽可能的精简 Everyone wants to be agile these days, but being “agile” is about building things in small chunks, learning, and then iterating. If someone is trying to shoehorn much more into it than that, then they’re probably selling something. It isn’t to say that people don’t need accountability or help to work this way, but how many times have you heard someone from your favorite tech company or large open source project brag about how great their Scrum process is? Stay lean on process until you know you need more. Trust your team and they will deliver. 现在每个人都想变得敏捷，但是“敏捷”是指在小的范围内构建事物，学习，然后迭代。如果有人试图把更多的东西塞进去，那么他们很可能是在卖东西。这并不是说人们不需要问责或帮助来这样工作，但是你有多少次听到你最喜欢的科技公司或大型开源项目的人吹嘘他们的 Scrum 流程有多棒？在你知道你需要更多之前，保持依赖过程。相信你的团队，他们会做到的。 ","date":"2021-10-11","objectID":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/:2:34","tags":["经验","思考"],"title":"做了20年软件工程师学到的20件事","uri":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/"},{"categories":["经验"],"content":"18. Software engineers, like all humans, need to feel ownership ","date":"2021-10-11","objectID":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/:2:35","tags":["经验","思考"],"title":"做了20年软件工程师学到的20件事","uri":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/"},{"categories":["经验"],"content":"18. 软件工程师，像所有人一样，需要感受到所有权 If you divorce someone from the output of their work, they will care less about their work. I see this almost as a tautology. This is the primary reason why cross-functional teams work so well, and why DevOps has become so popular. It isn’t all about handoffs and inefficiencies, it is about owning the whole process from start to finish, and being directly responsible for delivering value. Give a group of passionate people complete ownership over designing, building, and delivering a piece of software (or anything really) and amazing things will happen. 如果你把某人的工作成果与他们的工作分离开来，他们就不会那么关心自己的工作。我认为这几乎是同义反复。这就是为什么跨职能团队工作得这么好的主要原因，也是为什么 DevOps 变得如此流行的主要原因。这并不全是关于换手和低效率，而是关于从开始到结束拥有整个过程，并直接负责交付价值。让一群充满激情的人完全拥有设计、构建和交付一个软件(或者其他任何东西)的所有权，神奇的事情就会发生。 ","date":"2021-10-11","objectID":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/:2:36","tags":["经验","思考"],"title":"做了20年软件工程师学到的20件事","uri":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/"},{"categories":["经验"],"content":"19. Interviews are almost worthless for telling how good of a team member someone will be ","date":"2021-10-11","objectID":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/:2:37","tags":["经验","思考"],"title":"做了20年软件工程师学到的20件事","uri":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/"},{"categories":["经验"],"content":"19. 面试对于告诉你一个团队成员将会有多优秀几乎毫无价值 Interviews are far better spent trying to understand who someone is, and how interested they are in a given field of expertise. Trying to suss out how good of a team member they will be is a fruitless endeavor. And believe me, how smart or knowledgable someone is is also not a good indicator that they will be a great team member. No one is going to tell you in an interview that they are going to be unreliable, abusive, pompous, or never show up to meetings on time. People might claim they have “signals” for these things… “if they ask about time off in the first interview then they are never going to be there!” But these are all bullshit. If you’re using signals like these you’re just guessing and turning away good candidates. 面试最好是试图了解某人是谁，以及他们对某个特定领域的专业知识有多感兴趣。试图弄清楚一个团队成员有多优秀是徒劳的。相信我，一个人有多聪明多博学也不能说明他会成为一个优秀的团队成员。没有人会在面试中告诉你，他们不可靠，辱骂，浮夸，或者从不准时出席会议。人们可能会声称他们有这些事情的“信号”… “如果他们在第一次面试时问休息时间，那么他们永远不会在那里!”但这些都是胡说八道。如果你使用这样的信号，你只是在猜测和拒绝好的候选人。 ","date":"2021-10-11","objectID":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/:2:38","tags":["经验","思考"],"title":"做了20年软件工程师学到的20件事","uri":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/"},{"categories":["经验"],"content":"20. Always strive to build a smaller system ","date":"2021-10-11","objectID":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/:2:39","tags":["经验","思考"],"title":"做了20年软件工程师学到的20件事","uri":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/"},{"categories":["经验"],"content":"20. 总是努力建立一个更小的系统 There are a lot of forces that will push you to build the bigger system up-front. Budget allocation, the inability to decide which features should be cut, the desire to deliver the “best version” of a system. All of these things push us very forcefully towards building too much. You should fight this. You learn so much as you’re building a system that you will end up iterating into a much better system than you ever could have designed in the first place. This is surprisingly a hard sell to most people. 有很多的力量将推动你建立一个更大的系统。预算分配，无法决定应该削减哪些功能，渴望提供系统的“最佳版本”。所有这些东西都强有力地推动我们去建造太多的东西。你应该反抗。在构建一个系统的过程中，你学到了很多东西，最终你会迭代到一个比你最初设计的系统要好得多的系统。对于大多数人来说，这是一个令人惊讶的难以推销的东西。 ","date":"2021-10-11","objectID":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/:2:40","tags":["经验","思考"],"title":"做了20年软件工程师学到的20件事","uri":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/"},{"categories":["经验"],"content":"What is your story? ","date":"2021-10-11","objectID":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/:3:0","tags":["经验","思考"],"title":"做了20年软件工程师学到的20件事","uri":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/"},{"categories":["经验"],"content":"你的故事是什么？ So there you have it, 20 years of software distilled down into 20 pithy pieces of wisdom. I’d love to hear it if something resonated with you. I’d also love to hear if you have a piece of wisdom that you’ve picked up over your career that you’d like to share. Feel free to leave it down in the comments. 现在你知道了吧，20年的软件经过精炼，总结出了20条精辟的智慧。如果你有什么共鸣的话，我很想听听。我也很想听听你是否有一些你在职业生涯中学到的智慧想要与我们分享。欢迎在评论中留下你的观点。 Loved the article? Hated it? Didn’t even read it? 喜欢这篇文章? 讨厌它? 甚至没有读过它？ We’d love to hear from you. 我们很想听听你的意见。 Source ","date":"2021-10-11","objectID":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/:4:0","tags":["经验","思考"],"title":"做了20年软件工程师学到的20件事","uri":"/20%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%AD%A6%E5%88%B0%E7%9A%8420%E4%BB%B6%E4%BA%8B/"},{"categories":["JavaScript"],"content":"nodejs通过ffi-napi调用系统dll文件 const ffi = require('ffi-napi'); function showText(str) { return Buffer.from(str+'\\0','ucs2'); }; // 通过ffi加载user32.dll const myUser32 = new ffi.Library('user32', { 'MessageBoxW': // 声明这个dll中的一个函数 [ 'int32', ['int32', 'string', 'string', 'int32'], // 用json的格式罗列其返回类型和参数类型 ], }); // 调用user32.dll中的MessageBoxW()函数, 弹出一个对话框 myUser32.MessageBoxW( 0, showText('I am Node.JS!'), showText('你好，世界!'), 1 ); ","date":"2021-10-06","objectID":"/node%E8%B0%83%E7%94%A8dll/:1:0","tags":["JavaScript","nodejs"],"title":"nodejs调用dll","uri":"/node%E8%B0%83%E7%94%A8dll/"},{"categories":["python"],"content":"libxl官网 ","date":"2021-09-28","objectID":"/python%E8%B0%83%E7%94%A8libxl%E6%8F%92%E4%BB%B6/:0:0","tags":["python","dll"],"title":"python调用libxl插件","uri":"/python%E8%B0%83%E7%94%A8libxl%E6%8F%92%E4%BB%B6/"},{"categories":["python"],"content":"封装libxl.py示例 #coding=utf-8 from ctypes import * class Excel: def __init__(self): self.xl = CDLL(\"./libxl.dll\") def getxl(self): return self.xl def createXML(self): bhandle = self.xl.xlCreateXMLBookCA() return bhandle class Book: def __init__(self,excel,bhandle): self.xl = excel self.bookhandle = bhandle def pr(self): print(self.bookhandle) def setKey(self): self.xl.xlBookSetKeyA (self.bookhandle, b\"HeiYe\", b\"windows-2220200f01c5e9016fb86160afo5raf1\") def createXML(self): self.bookhandle = self.xl.xlCreateXMLBookCA() def addSheet(self,sheetname): shandle=self.xl.xlBookAddSheetA (self.bookhandle, sheetname,0) return shandle def save(self,name): self.xl.xlBookSaveA (self.bookhandle, name) def release(self): self.xl.xlBookReleaseA (self.bookhandle) class Sheet: def __init__(self,excel,shandle): self.xl = excel self.sheethandle = shandle def writestr(self,x,y,string): self.xl.xlSheetWriteStrA (self.sheethandle, x, y, string, 0) ","date":"2021-09-28","objectID":"/python%E8%B0%83%E7%94%A8libxl%E6%8F%92%E4%BB%B6/:1:0","tags":["python","dll"],"title":"python调用libxl插件","uri":"/python%E8%B0%83%E7%94%A8libxl%E6%8F%92%E4%BB%B6/"},{"categories":["python"],"content":"调用libxl.py示例，将libxl.py和stdcall形式的libxl.dll放到同一个目录下 from libxl import * excel = Excel() bh = excel.createXML() xl = excel.getxl() book = Book(xl,bh) book.setKey() sh = book.addSheet(b\"sheet1\") sheet = Sheet(xl, sh) sheet.writestr(0, 0, \"Hello World! 你好\".encode(\"gbk\")) book.save(b\"test.xlsx\") book.release() ","date":"2021-09-28","objectID":"/python%E8%B0%83%E7%94%A8libxl%E6%8F%92%E4%BB%B6/:2:0","tags":["python","dll"],"title":"python调用libxl插件","uri":"/python%E8%B0%83%E7%94%A8libxl%E6%8F%92%E4%BB%B6/"},{"categories":["计算机书籍"],"content":"非编程语言类 ","date":"2021-05-20","objectID":"/free-programming-books-zh_cn/:1:0","tags":["书籍"],"title":"免费的计算机编程类中文书籍","uri":"/free-programming-books-zh_cn/"},{"categories":["计算机书籍"],"content":"置顶 [笔记]前端工程师的入门与进阶 💯 [全文]如何正确的学习 Node.js 💯 ","date":"2021-05-20","objectID":"/free-programming-books-zh_cn/:1:1","tags":["书籍"],"title":"免费的计算机编程类中文书籍","uri":"/free-programming-books-zh_cn/"},{"categories":["计算机书籍"],"content":"操作系统 开源世界旅行手册 鸟哥的Linux私房菜 The Linux Command Line (中英文版) Linux 设备驱动 (第三版) 深入分析Linux内核源码 😟 UNIX TOOLBOX Docker中文指南 Docker —— 从入门到实践 Docker入门实战 Docker Cheat Sheet FreeRADIUS新手入门 😟 Mac 开发配置手册 FreeBSD 使用手册 Linux 命令行(中文版) Linux 构建指南 Linux工具快速教程 Linux Documentation (中文版) 嵌入式 Linux 知识库 (eLinux.org 中文版) 理解Linux进程 命令行的艺术 SystemTap新手指南 操作系统思考 ","date":"2021-05-20","objectID":"/free-programming-books-zh_cn/:1:2","tags":["书籍"],"title":"免费的计算机编程类中文书籍","uri":"/free-programming-books-zh_cn/"},{"categories":["计算机书籍"],"content":"智能系统 一步步搭建物联网系统 ","date":"2021-05-20","objectID":"/free-programming-books-zh_cn/:1:3","tags":["书籍"],"title":"免费的计算机编程类中文书籍","uri":"/free-programming-books-zh_cn/"},{"categories":["计算机书籍"],"content":"分布式系统 走向分布式 ","date":"2021-05-20","objectID":"/free-programming-books-zh_cn/:1:4","tags":["书籍"],"title":"免费的计算机编程类中文书籍","uri":"/free-programming-books-zh_cn/"},{"categories":["计算机书籍"],"content":"编译原理 《计算机程序的结构和解释》公开课 翻译项目 ","date":"2021-05-20","objectID":"/free-programming-books-zh_cn/:1:5","tags":["书籍"],"title":"免费的计算机编程类中文书籍","uri":"/free-programming-books-zh_cn/"},{"categories":["计算机书籍"],"content":"函数式概念 傻瓜函数编程 ","date":"2021-05-20","objectID":"/free-programming-books-zh_cn/:1:6","tags":["书籍"],"title":"免费的计算机编程类中文书籍","uri":"/free-programming-books-zh_cn/"},{"categories":["计算机书籍"],"content":"计算机图形学 OpenGL 教程 WebGL自学网 😟 《Real-Time Rendering 3rd》提炼总结 ","date":"2021-05-20","objectID":"/free-programming-books-zh_cn/:1:7","tags":["书籍"],"title":"免费的计算机编程类中文书籍","uri":"/free-programming-books-zh_cn/"},{"categories":["计算机书籍"],"content":"WEB服务器 Nginx开发从入门到精通 (淘宝团队出品) Nginx教程从入门到精通(PDF版本，运维生存时间出品) OpenResty最佳实践 Apache 中文手册 ","date":"2021-05-20","objectID":"/free-programming-books-zh_cn/:1:8","tags":["书籍"],"title":"免费的计算机编程类中文书籍","uri":"/free-programming-books-zh_cn/"},{"categories":["计算机书籍"],"content":"版本控制 Git教程 （本文由 廖雪峰 创作，如果觉得本教程对您有帮助，可以去 iTunes 购买） git - 简易指南 猴子都能懂的GIT入门 Git 参考手册 Pro Git Pro Git 中文版 (整理在gitbook上) Git Magic GotGitHub Git权威指南 Git Community Book 中文版 Mercurial 使用教程 HgInit (中文版) 沉浸式学 Git Git-Cheat-Sheet （感谢 @flyhigher139 翻译了中文版） GitHub秘籍 GitHub帮助文档 git-flow 备忘清单 svn 手册 GitHub漫游指南 ","date":"2021-05-20","objectID":"/free-programming-books-zh_cn/:1:9","tags":["书籍"],"title":"免费的计算机编程类中文书籍","uri":"/free-programming-books-zh_cn/"},{"categories":["计算机书籍"],"content":"编辑器 exvim–vim 改良成IDE项目 笨方法学Vimscript 中译本 😟 Vim中文文档 所需即所获：像 IDE 一样使用 vim vim 实操教程 Atom飞行手册中文版 Markdown·简单的世界 一年成为 Emacs 高手 Emacs 生存指南 Atom官方手册 ","date":"2021-05-20","objectID":"/free-programming-books-zh_cn/:1:10","tags":["书籍"],"title":"免费的计算机编程类中文书籍","uri":"/free-programming-books-zh_cn/"},{"categories":["计算机书籍"],"content":"NoSQL NoSQL数据库笔谈 Redis 设计与实现 Redis 命令参考 带有详细注释的 Redis 3.0 代码 带有详细注释的 Redis 2.6 代码 The Little MongoDB Book The Little Redis Book Neo4j 简体中文手册 v1.8 Neo4j .rb 中文資源 Disque 使用教程 Apache Spark 设计与实现 ","date":"2021-05-20","objectID":"/free-programming-books-zh_cn/:1:11","tags":["书籍"],"title":"免费的计算机编程类中文书籍","uri":"/free-programming-books-zh_cn/"},{"categories":["计算机书籍"],"content":"PostgreSQL PostgreSQL 8.2.3 中文文档 PostgreSQL 9.3.1 中文文档 PostgreSQL 9.5.3 中文文档 ","date":"2021-05-20","objectID":"/free-programming-books-zh_cn/:1:12","tags":["书籍"],"title":"免费的计算机编程类中文书籍","uri":"/free-programming-books-zh_cn/"},{"categories":["计算机书籍"],"content":"MySQL MySQL索引背后的数据结构及算法原理 21分钟MySQL入门教程 ","date":"2021-05-20","objectID":"/free-programming-books-zh_cn/:1:13","tags":["书籍"],"title":"免费的计算机编程类中文书籍","uri":"/free-programming-books-zh_cn/"},{"categories":["计算机书籍"],"content":"管理和监控 ELKstack 中文指南 Mastering Elasticsearch(中文版) ElasticSearch 权威指南 Elasticsearch 权威指南（中文版） Logstash 最佳实践 Puppet 2.7 Cookbook 中文版 ","date":"2021-05-20","objectID":"/free-programming-books-zh_cn/:1:14","tags":["书籍"],"title":"免费的计算机编程类中文书籍","uri":"/free-programming-books-zh_cn/"},{"categories":["计算机书籍"],"content":"项目相关 持续集成（第二版） (译言网) 让开发自动化系列专栏 追求代码质量 selenium 中文文档 Selenium Webdriver 简易教程 Joel谈软件 約耳談軟體(Joel on Software) Gradle 2 用户指南 Gradle 中文使用文档 编码规范 开源软件架构 GNU make 指南 GNU make 中文手册 The Twelve-Factor App ","date":"2021-05-20","objectID":"/free-programming-books-zh_cn/:1:15","tags":["书籍"],"title":"免费的计算机编程类中文书籍","uri":"/free-programming-books-zh_cn/"},{"categories":["计算机书籍"],"content":"设计模式 图说设计模式 史上最全设计模式导学目录 design pattern 包教不包会 设计模式 Java 版 ","date":"2021-05-20","objectID":"/free-programming-books-zh_cn/:1:16","tags":["书籍"],"title":"免费的计算机编程类中文书籍","uri":"/free-programming-books-zh_cn/"},{"categories":["计算机书籍"],"content":"Web 关于浏览器和网络的 20 项须知 浏览器开发工具的秘密 Chrome 开发者工具中文手册 Chrome扩展开发文档 Grunt中文文档 gulp中文文档 Gulp 入门指南 移动Web前端知识库 正则表达式30分钟入门教程 前端开发体系建设日记 移动前端开发收藏夹 JSON风格指南 HTTP 接口设计指北 前端资源分享（一） 前端资源分享（二） 前端代码规范 及 最佳实践 前端开发者手册 前端工程师手册 w3school教程整理 Wireshark用户手册 一站式学习Wireshark HTTP 下午茶 HTTP/2.0 中文翻译 RFC 7540 - HTTP/2 中文翻译版 http2讲解 3 Web Designs in 3 Weeks 站点可靠性工程 Web安全学习笔记 Serverless 架构应用开发指南 ","date":"2021-05-20","objectID":"/free-programming-books-zh_cn/:1:17","tags":["书籍"],"title":"免费的计算机编程类中文书籍","uri":"/free-programming-books-zh_cn/"},{"categories":["计算机书籍"],"content":"大数据 大数据/数据挖掘/推荐系统/机器学习相关资源 面向程序员的数据挖掘指南 大型集群上的快速和通用数据处理架构 数据挖掘中经典的算法实现和详细的注释 Spark 编程指南简体中文版 ","date":"2021-05-20","objectID":"/free-programming-books-zh_cn/:1:18","tags":["书籍"],"title":"免费的计算机编程类中文书籍","uri":"/free-programming-books-zh_cn/"},{"categories":["计算机书籍"],"content":"编程艺术 程序员编程艺术 每个程序员都应该了解的内存知识(译)【第一部分】 取悦的工序：如何理解游戏 (豆瓣阅读，免费书籍) ","date":"2021-05-20","objectID":"/free-programming-books-zh_cn/:1:19","tags":["书籍"],"title":"免费的计算机编程类中文书籍","uri":"/free-programming-books-zh_cn/"},{"categories":["计算机书籍"],"content":"其它 OpenWrt智能、自动、透明翻墙路由器教程 SAN 管理入门系列 Sketch 中文手册 深入理解并行编程 程序员的自我修养 Growth: 全栈增长工程师指南 系统重构与迁移指南 ","date":"2021-05-20","objectID":"/free-programming-books-zh_cn/:1:20","tags":["书籍"],"title":"免费的计算机编程类中文书籍","uri":"/free-programming-books-zh_cn/"},{"categories":["计算机书籍"],"content":"编程语言类 ","date":"2021-05-20","objectID":"/free-programming-books-zh_cn/:2:0","tags":["书籍"],"title":"免费的计算机编程类中文书籍","uri":"/free-programming-books-zh_cn/"},{"categories":["计算机书籍"],"content":"Android Android Design(中文版) Google Material Design 正體中文版 (译本一 译本二) Material Design 中文版 Google Android官方培训课程中文版 Android学习之路 Android开发技术前线(android-tech-frontier) Point-of-Android Android 一些重要知识点解析整理 Android6.0新特性详解 ","date":"2021-05-20","objectID":"/free-programming-books-zh_cn/:2:1","tags":["书籍"],"title":"免费的计算机编程类中文书籍","uri":"/free-programming-books-zh_cn/"},{"categories":["计算机书籍"],"content":"APP Apache Cordova 开发指南 ","date":"2021-05-20","objectID":"/free-programming-books-zh_cn/:2:2","tags":["书籍"],"title":"免费的计算机编程类中文书籍","uri":"/free-programming-books-zh_cn/"},{"categories":["计算机书籍"],"content":"AWK awk程序设计语言 awk中文指南 awk实战指南 ","date":"2021-05-20","objectID":"/free-programming-books-zh_cn/:2:3","tags":["书籍"],"title":"免费的计算机编程类中文书籍","uri":"/free-programming-books-zh_cn/"},{"categories":["计算机书籍"],"content":"C/C++ C/C++ 中文参考手册 (欢迎大家参与在线翻译和校对) C 语言编程透视 C++ 并发编程指南 Linux C编程一站式学习 (宋劲杉, 北京亚嵌教育研究中心) CGDB中文手册 100个gdb小技巧 100个gcc小技巧 ZMQ 指南 How to Think Like a Computer Scientist (中英文版) 跟我一起写 Makefile GNU make中文手册 (需科学上网) (PDF) GNU make 指南 Google C++ 风格指南 C/C++ Primer (by @andycai) 简单易懂的C魔法 C++ FAQ LITE(中文版) C++ Primer 5th Answers C++ 并发编程(基于C++11) QT 教程 DevBean的《Qt学习之路2》(Qt5) 中文版《QmlBook》 C++ Template 进阶指南 libuv中文教程 Boost 库中文教程 笨办法学C 高速上手 C++11/14/17 ","date":"2021-05-20","objectID":"/free-programming-books-zh_cn/:2:4","tags":["书籍"],"title":"免费的计算机编程类中文书籍","uri":"/free-programming-books-zh_cn/"},{"categories":["计算机书籍"],"content":"C# Microsoft Docs C# 官方文档 ASP.NET MVC 5 入门指南 超全面的 .NET GDI+ 图形图像编程教程 .NET控件开发基础 .NET开发要点精讲（初稿） ","date":"2021-05-20","objectID":"/free-programming-books-zh_cn/:2:5","tags":["书籍"],"title":"免费的计算机编程类中文书籍","uri":"/free-programming-books-zh_cn/"},{"categories":["计算机书籍"],"content":"Clojure Clojure入门教程 ","date":"2021-05-20","objectID":"/free-programming-books-zh_cn/:2:6","tags":["书籍"],"title":"免费的计算机编程类中文书籍","uri":"/free-programming-books-zh_cn/"},{"categories":["计算机书籍"],"content":"CSS/HTML 学习CSS布局 通用 CSS 笔记、建议与指导 CSS参考手册 Emmet 文档 前端代码规范 (腾讯 AlloyTeam 团队) HTML和CSS编码规范 Sass Guidelines 中文 CSS3 Tutorial 《CSS3 教程》 MDN HTML 中文文档 MDN CSS 中文文档 ","date":"2021-05-20","objectID":"/free-programming-books-zh_cn/:2:7","tags":["书籍"],"title":"免费的计算机编程类中文书籍","uri":"/free-programming-books-zh_cn/"},{"categories":["计算机书籍"],"content":"Dart Dart 语言导览 ","date":"2021-05-20","objectID":"/free-programming-books-zh_cn/:2:8","tags":["书籍"],"title":"免费的计算机编程类中文书籍","uri":"/free-programming-books-zh_cn/"},{"categories":["计算机书籍"],"content":"Elixir Elixir编程入门 ","date":"2021-05-20","objectID":"/free-programming-books-zh_cn/:2:9","tags":["书籍"],"title":"免费的计算机编程类中文书籍","uri":"/free-programming-books-zh_cn/"},{"categories":["计算机书籍"],"content":"Erlang 21天学通Erlang ","date":"2021-05-20","objectID":"/free-programming-books-zh_cn/:2:10","tags":["书籍"],"title":"免费的计算机编程类中文书籍","uri":"/free-programming-books-zh_cn/"},{"categories":["计算机书籍"],"content":"Fortran Fortran77和90/95编程入门 ","date":"2021-05-20","objectID":"/free-programming-books-zh_cn/:2:11","tags":["书籍"],"title":"免费的计算机编程类中文书籍","uri":"/free-programming-books-zh_cn/"},{"categories":["计算机书籍"],"content":"Go Go编程基础 Go入门指南 学习Go语言 Go Web 编程 (此书已经出版，希望开发者们去购买，支持作者的创作) Go实战开发 (当我收录此项目时，作者已经写完第三章，如果读完前面章节觉得有帮助，可以给作者捐赠，以鼓励作者的继续创作) Network programming with Go 中文翻译版本 Effective Go Go 语言标准库 Golang标准库文档 Revel 框架手册 Java程序员的Golang入门指南 Go命令教程 Go语言博客实践 Go 官方文档翻译 深入解析Go Go语言圣经(中文版) (GitBook) golang runtime源码分析 Go语言实战: 编写可维护Go语言代码建议 Golang 系列教程(译) Go RPC 开发指南GitBook Go语言高级编程 Go2编程指南 Go语言设计模式 Go语言四十二章经 ","date":"2021-05-20","objectID":"/free-programming-books-zh_cn/:2:12","tags":["书籍"],"title":"免费的计算机编程类中文书籍","uri":"/free-programming-books-zh_cn/"},{"categories":["计算机书籍"],"content":"Groovy 实战 Groovy 系列 ","date":"2021-05-20","objectID":"/free-programming-books-zh_cn/:2:13","tags":["书籍"],"title":"免费的计算机编程类中文书籍","uri":"/free-programming-books-zh_cn/"},{"categories":["计算机书籍"],"content":"Haskell Real World Haskell 中文版 Haskell趣学指南 ","date":"2021-05-20","objectID":"/free-programming-books-zh_cn/:2:14","tags":["书籍"],"title":"免费的计算机编程类中文书籍","uri":"/free-programming-books-zh_cn/"},{"categories":["计算机书籍"],"content":"iOS iOS开发60分钟入门 iOS7人机界面指南 Google Objective-C Style Guide 中文版 iPhone 6 屏幕揭秘 Apple Watch开发初探 马上着手开发 iOS 应用程序 网易斯坦福大学公开课：iOS 7应用开发字幕文件 ","date":"2021-05-20","objectID":"/free-programming-books-zh_cn/:2:15","tags":["书籍"],"title":"免费的计算机编程类中文书籍","uri":"/free-programming-books-zh_cn/"},{"categories":["计算机书籍"],"content":"Java Apache Shiro 用户指南 Jersey 2.x 用户指南 Spring Framework 4.x参考文档 Spring Boot参考指南 (翻译中) MyBatis中文文档 MyBatis Generator 中文文档 用jersey构建REST服务 Activiti 5.x 用户指南 Google Java编程风格指南 Netty 4.x 用户指南 Netty 实战(精髓) REST 实战 Java 编码规范 Apache MINA 2 用户指南 H2 Database 教程 Java Servlet 3.1 规范 JSSE 参考指南 Java开源实现及最佳实践 Java 编程要点 Think Java Java 8 简明教程 On Java 8 中文版 (翻译中) Effective Java 第3版中文版 ","date":"2021-05-20","objectID":"/free-programming-books-zh_cn/:2:16","tags":["书籍"],"title":"免费的计算机编程类中文书籍","uri":"/free-programming-books-zh_cn/"},{"categories":["计算机书籍"],"content":"JavaScript 现代 Javascript 教程 Google JavaScript 代码风格指南 Google JSON 风格指南 Airbnb JavaScript 规范 JavaScript 标准参考教程（alpha） Javascript编程指南 (源码) javascript 的 12 个怪癖 JavaScript 秘密花园 JavaScript核心概念及实践 (PDF) (此书已由人民邮电出版社出版发行，但作者依然免费提供PDF版本，希望开发者们去购买，支持作者) 《JavaScript 模式》 “JavaScript patterns”中译本 JavaScript语言精粹 命名函数表达式探秘 (注:原文由为之漫笔翻译，原始地址无法打开，所以此处地址为我博客上的备份) 学用 JavaScript 设计模式 (开源中国) 深入理解JavaScript系列 ECMAScript 5.1 中文版 ECMAScript 6 入门 (作者：阮一峰) JavaScript Promise迷你书 You-Dont-Know-JS (深入JavaScript语言核心机制的系列图书) JavaScript 教程 廖雪峰 MDN JavaScript 中文文档 jQuery jQuery 解构 简单易懂的JQuery魔法 How to write jQuery plugin You Don’t Need jQuery 如何实现一个类jQuery？ Node.js Node入门 七天学会NodeJS Nodejs Wiki Book (繁体中文) express.js 中文文档 koa 中文文档 一起学koa 使用 Express + MongoDB 搭建多人博客 Express框架 Node.js 包教不包会 Learn You The Node.js For Much Win! (中文版) Node debug 三法三例 nodejs中文文档 orm2 中文文档 一起学 Node.js underscore.js Underscore.js中文文档 backbone.js backbone.js中文文档 backbone.js入门教程 (PDF) Backbone.js入门教程第二版 Developing Backbone.js Applications(中文版) AngularJS AngularJS最佳实践和风格指南 AngularJS中译本 AngularJS入门教程 构建自己的AngularJS 在Windows环境下用Yeoman构建AngularJS项目 Zepto.js Zepto.js 中文文档 Sea.js Hello Sea.js React.js React 学习之道 React.js 小书 React.js 中文文档 React webpack-cookbook React 入门教程 React 入门教程 (作者：hulufei, 与上行不同作者) React Native 中文文档(含最新Android内容) Learn React \u0026 Webpack by building the Hacker News front page impress.js impress.js的中文教程 CoffeeScript CoffeeScript Cookbook The Little Book on CoffeeScript中文版 CoffeeScript 编码风格指南 TypeScipt TypeScript Handbook ExtJS Ext4.1.0 中文文档 Meteor Discover Meteor Meteor 中文文档 Angular-Meteor 中文教程 VueJS 逐行剖析 Vue.js 源码 Chrome扩展及应用开发 ","date":"2021-05-20","objectID":"/free-programming-books-zh_cn/:2:17","tags":["书籍"],"title":"免费的计算机编程类中文书籍","uri":"/free-programming-books-zh_cn/"},{"categories":["计算机书籍"],"content":"Kotlin Kotlin 官方参考文档 中文版 Kotlin 中文文档 GitHub Kotlin 参考文档 《Kotlin for android developers》中文版 ","date":"2021-05-20","objectID":"/free-programming-books-zh_cn/:2:18","tags":["书籍"],"title":"免费的计算机编程类中文书籍","uri":"/free-programming-books-zh_cn/"},{"categories":["计算机书籍"],"content":"LaTeX 一份其实很短的 LaTeX 入门文档 一份不太简短的 LATEX 2ε 介绍 （PDF版） ","date":"2021-05-20","objectID":"/free-programming-books-zh_cn/:2:19","tags":["书籍"],"title":"免费的计算机编程类中文书籍","uri":"/free-programming-books-zh_cn/"},{"categories":["计算机书籍"],"content":"LISP Common Lisp ANSI Common Lisp 中文翻譯版 On Lisp 中文翻译版本 Scheme Yet Another Scheme Tutorial Scheme入门教程 Scheme语言简明教程 Racket Racket book ","date":"2021-05-20","objectID":"/free-programming-books-zh_cn/:2:20","tags":["书籍"],"title":"免费的计算机编程类中文书籍","uri":"/free-programming-books-zh_cn/"},{"categories":["计算机书籍"],"content":"Lua Lua编程入门 Lua 5.1 参考手册 中文翻译 Lua 5.3 参考手册 中文翻译 Lua源码欣赏 ","date":"2021-05-20","objectID":"/free-programming-books-zh_cn/:2:21","tags":["书籍"],"title":"免费的计算机编程类中文书籍","uri":"/free-programming-books-zh_cn/"},{"categories":["计算机书籍"],"content":"OCaml Real World OCaml ","date":"2021-05-20","objectID":"/free-programming-books-zh_cn/:2:22","tags":["书籍"],"title":"免费的计算机编程类中文书籍","uri":"/free-programming-books-zh_cn/"},{"categories":["计算机书籍"],"content":"Perl Modern Perl 中文版 Perl 程序员应该知道的事 ","date":"2021-05-20","objectID":"/free-programming-books-zh_cn/:2:23","tags":["书籍"],"title":"免费的计算机编程类中文书籍","uri":"/free-programming-books-zh_cn/"},{"categories":["计算机书籍"],"content":"PHP PHP 官方手册 PHP调试技术手册(PDF) PHP之道：php-the-right-way (@wulijun版 PHPHub版) PHP 最佳实践 PHP 开发者实践 深入理解PHP内核 PHP扩展开发及内核应用 Laravel5.1 中文文档 Laravel 5.1 LTS 速查表 Symfony2 Cookbook 中文版(版本 2.7.0 LTS) Symfony2中文文档 (未译完) YiiBook几本Yii框架的在线教程 深入理解 Yii 2.0 Yii 框架中文官网 简单易懂的PHP魔法 swoole文档及入门教程 Composer 中文网 Slim 中文文档 Lumen 中文文档 PHPUnit 中文文档 PHP-LeetCode ","date":"2021-05-20","objectID":"/free-programming-books-zh_cn/:2:24","tags":["书籍"],"title":"免费的计算机编程类中文书籍","uri":"/free-programming-books-zh_cn/"},{"categories":["计算机书籍"],"content":"Prolog 笨办法学Prolog ","date":"2021-05-20","objectID":"/free-programming-books-zh_cn/:2:25","tags":["书籍"],"title":"免费的计算机编程类中文书籍","uri":"/free-programming-books-zh_cn/"},{"categories":["计算机书籍"],"content":"Python 廖雪峰 Python 2.7 中文教程 廖雪峰 Python 3 中文教程 简明Python教程 简明 Python 教程(Python 3) 零基础学 Python 第一版 零基础学 Python 第二版 可爱的 Python Python 2.7 官方教程中文版 Python 3.3 官方教程中文版 Python Cookbook 中文版 Python3 Cookbook 中文版 深入 Python 深入 Python 3 PEP8 Python代码风格规范 Google Python 风格指南 中文版 Python入门教程 (PDF) 笨办法学 Python (PDF EPUB) Python自然语言处理中文版 （感谢陈涛同学的翻译，也谢谢 @shwley 联系了作者） Python 绘图库 matplotlib 官方指南中文翻译 Scrapy 0.25 文档 ThinkPython ThinkPython 2ed Python快速教程 Python 正则表达式操作指南 python初级教程：入门详解 Twisted 与异步编程入门 TextGrocery 中文 API ( 基于svm算法的一个短文本分类 Python 库 ) Requests: HTTP for Humans Pillow 中文文档 PyMOTW 中文版 Python 官方文档中文版 Fabric 中文文档 Beautiful Soup 4.2.0 中文文档 Python 中的 Socket 编程 用Python做科学计算 Sphinx 中文文档 精通 Python 设计模式 python 安全编程教程 程序设计思想与方法 知乎周刊·编程小白学Python Scipy 讲义 Python 学习笔记 基础篇 Python 学习笔记 模块篇 Python 标准库 中文版 Python进阶 Python 核心编程 第二版 CPyUG译 Python最佳实践指南 Python 精要教程 Python 量化交易教程 Django Django 1.5 文档中文版 正在翻译中 Django 2.0 文档中文版 Django 最佳实践 Django 2.1 搭建个人博客教程 ( 编写中 ) Django搭建简易博客教程 The Django Book 中文版 Django 设计模式与最佳实践 Django 网站开发 Cookbook Django Girls 學習指南 Flask Flask 文档中文版 Jinja2 文档中文版 Werkzeug 文档中文版 Flask之旅 Flask 扩展文档汇总 Flask 大型教程 SQLAlchemy 中文文档 Flask 入门教程 web.py web.py 0.3 新手指南 Web.py Cookbook 简体中文版 Tornado Introduction to Tornado 中文翻译 Tornado源码解析 Tornado 4.3 文档中文版 ","date":"2021-05-20","objectID":"/free-programming-books-zh_cn/:2:26","tags":["书籍"],"title":"免费的计算机编程类中文书籍","uri":"/free-programming-books-zh_cn/"},{"categories":["计算机书籍"],"content":"R R语言忍者秘笈 ","date":"2021-05-20","objectID":"/free-programming-books-zh_cn/:2:27","tags":["书籍"],"title":"免费的计算机编程类中文书籍","uri":"/free-programming-books-zh_cn/"},{"categories":["计算机书籍"],"content":"Ruby Ruby 风格指南 Rails 风格指南 笨方法學 Ruby Ruby on Rails 指南 Ruby on Rails 實戰聖經 Ruby on Rails Tutorial 原书第 3 版 (本书网页版免费提供，电子版以 PDF、EPub 和 Mobi 格式提供购买，仅售 9.9 美元) Rails 实践 Rails 5 开发进阶(Beta) Rails 102 编写Ruby的C拓展 Ruby 源码解读 Ruby中的元编程 ","date":"2021-05-20","objectID":"/free-programming-books-zh_cn/:2:28","tags":["书籍"],"title":"免费的计算机编程类中文书籍","uri":"/free-programming-books-zh_cn/"},{"categories":["计算机书籍"],"content":"Rust Rust编程语言 中文翻译 Rust Primer ","date":"2021-05-20","objectID":"/free-programming-books-zh_cn/:2:29","tags":["书籍"],"title":"免费的计算机编程类中文书籍","uri":"/free-programming-books-zh_cn/"},{"categories":["计算机书籍"],"content":"Scala Scala课堂 (Twitter的Scala中文教程) Effective Scala(Twitter的Scala最佳实践的中文翻译) Scala指南 ","date":"2021-05-20","objectID":"/free-programming-books-zh_cn/:2:30","tags":["书籍"],"title":"免费的计算机编程类中文书籍","uri":"/free-programming-books-zh_cn/"},{"categories":["计算机书籍"],"content":"Shell Shell脚本编程30分钟入门 Bash脚本15分钟进阶教程 Linux工具快速教程 shell十三问 Shell编程范例 Linux命令搜索引擎 ","date":"2021-05-20","objectID":"/free-programming-books-zh_cn/:2:31","tags":["书籍"],"title":"免费的计算机编程类中文书籍","uri":"/free-programming-books-zh_cn/"},{"categories":["计算机书籍"],"content":"Swift The Swift Programming Language 中文版 Swift 语言指南 Stanford 公开课，Developing iOS 8 Apps with Swift 字幕翻译文件 C4iOS - COSMOS ","date":"2021-05-20","objectID":"/free-programming-books-zh_cn/:2:32","tags":["书籍"],"title":"免费的计算机编程类中文书籍","uri":"/free-programming-books-zh_cn/"},{"categories":["计算机书籍"],"content":"读书笔记及其它 编译原理（紫龙书）中文第2版习题答案 把《编程珠玑》读薄 Effective C++读书笔记 Golang 学习笔记、Python 学习笔记、C 学习笔记 (PDF) Jsoup 学习笔记 学习笔记: Vim、Python、memcached 图灵开放书翻译计划–C++、Python、Java等 蒂姆·奥莱利随笔 （由译言网翻译，电子版免费） SICP 解题集 精彩博客集合 中文文案排版指北 Standard C 语言标准函数库速查 (Cheat Sheet) Git Cheatsheet Chs GitBook简明教程 制造开源软件 提问的智慧 Markdown 入门参考 AsciiDoc简明指南 背包问题九讲 老齐的技术资料 前端技能汇总 借助开源项目，学习软件开发 前端工作面试问题 leetcode/lintcode题解/算法学习笔记 前端开发笔记本 LeetCode题解 《不可替代的团队领袖培养计划》 ","date":"2021-05-20","objectID":"/free-programming-books-zh_cn/:3:0","tags":["书籍"],"title":"免费的计算机编程类中文书籍","uri":"/free-programming-books-zh_cn/"},{"categories":["计算机网络"],"content":"★本文的目标读者 　今天这篇的标题是“扫盲”，也就是说：即使那些完全不懂 IT 领域，也不懂通讯领域的读者，依然能看懂（至少能看懂一部分）。为了做到这点，俺会尽量使用通俗的比喻，并适当加一些示意图。 另外，就算你已经比较了解网络通讯领域，本文中提到的某些部分，也可能是你所不知道的。也就是说：懂行的同学，看看此文，也会有帮助。 本文的标题特地强调了【系统性】——俺希望这篇教程能帮助读者对“计算机网络”这个领域进行系统性学习（何为“系统性学习”？请看这篇教程） 为了做到【系统性】这个目的，这篇教程很长。俺开博12年，这篇的长度估计能排到前5名。建议大伙儿慢慢看，不要着急。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:1:0","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"★基本概念 　为了足够通俗，俺先要介绍一些基本概念。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:2:0","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇信道（channel） 　这是通讯领域非常基本的概念，肯定要先聊聊它。 通俗地说，信道就是“传送信息的通道”。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:2:1","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇信道的类型 　首先，信道可以从广义上分为“物理信道 ＆ 逻辑信道”。 顾名思义，“物理信道”就是直接使用某种【物理介质】来传送信息；至于“逻辑信道”——是基于“物理信道”之上抽象出来的玩意儿（待会儿讲到“协议栈”的时候再聊）。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:2:2","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇信道的带宽 　“带宽”指的是：某个信道在单位时间内最大能传输多少比特的信息。 请注意： 电气领域 ＆ 计算机领域都有“带宽”这个概念，但两者的定义不太一样。电气领域所说的“带宽”指的是“模拟带宽”，单位是“赫兹/Hz”；计算机领域所说的“带宽”指“数字带宽”，单位是“比特率”或“字节率”。 后续章节提到“带宽”，都是指计算机领域的术语。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:2:3","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇带宽的单位——容易把外行绕晕 　“比特率”或“字节率”很容易搞混淆。用英文表示的话——大写字母 B 表示【字节】；小写字母 b 表示【比特】。 　由于带宽的数字通常很大，要引入“K、M、G”之类的字母表示数量级，于是又引出一个很扯蛋的差异——“10进制”与“2进制”的差异。 【10进制】的 K 表示 1000；M 表示 1000x1000（1百万） 【2进制】的 K 表示 1024（2的10次方）；M 表示 1024x1024（2的20次方） 为了避免扯皮，后来国际上约定了一个规矩：对【2进制】的数量级要加一个小写字母 i。比如说：Ki 表示 1024；Mi 表示 1024x1024 …… 以此类推。 举例： 1Kbps 表示“1000比特每秒” 1KiBps 表示“1024字节每秒” ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:2:4","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇信道的工作模式：单工 VS 半双工 VS 全双工 　再来说说信道的工作模式。大致可以分为如下三种。为了让大伙儿比较好理解，俺对每一种都举相应的例子。 　单工（simplex） 比如“电台广播”就是典型的【单工】。“电台”可以发信号给“收音机”，但“收音机”【不能】发信号给“电台”。 　半双工（half-duplex） 比如“单条铁路轨道”，就是典型的【半双工】。火车在单条铁轨上，可以有两种运行方向；但对于同一个瞬间，只能选其中一个方向（否则就撞车了）。 　全双工（full-duplex） 比如“光纤”就是典型的【全双工】。在同一根光导纤维中，可以有多个光束【同时相向】传播，互相不会干扰对方。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:2:5","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇端点 　为了叙述方便，俺把参与通讯的对象（主体）称作“通讯端点”，简称“端点”。 这里的“端点”是广义的，可以是硬件（比如某个网卡），也可以是软件（比如某个应用程序）。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:2:6","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇单播、组播/多播、广播、选播 　对于“网络通讯”，至少得有 N 个端点参与，并且【N ≥ 2】才有意义。 当 N 个端点构成一个网络，这时候就会涉及到“单播、组播、广播”这几个概念。 通俗地说： 单播（unicast）——发送给网络中的指定的【单个】端点 组播/多播（multicast）——发送给网络中的指定的【多个】端点 广播（broadcast）——发送给网络中的【所有】端点 选播（anycast）——发送给网络中随机选择的【单个】端点 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:2:7","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇通讯协议（protocol） 　所谓的“通讯协议”就是：参与通讯的各方所采用的某种【约定】。只有大家都遵守这个约定，才有可能相互传递信息。 打个比方：如果两个人要用自然语言交流，前提是：双方使用相同（或相互兼容）的自然语言。 “通讯协议”就类似某种自然语言，参与通讯的多个端点，都必须能理解这个语言。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:2:8","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"★从“分层”到“参考模型” ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:3:0","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇分层 　在聊“分层”之前，先说说“分工”。比如在一个公司中，通常设有不同的工种/岗位，这就【分工】。 对于网络通讯也是如此，不太可能用一种通讯协议完成所有的信息传递任务（注：对于特别简单的网络，或许有可能只用单一协议；但如今的网络通讯已经很复杂，用【单个】通讯协议包办所有事情，已经不太可能） 一旦采用了多种通讯协议，这几种协议之间，该如何配合捏？ 在网络通讯领域，采用的是【分层】的设计思路。多个层次的协议在一起协同工作，技术上称作“协议栈”（洋文叫做“protocol stack”）。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:3:1","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇协议栈的原理 　对于多层次的协议栈。每个层次都有各自的“端点”（进行通讯的主体）。处于【同一层次】的两个端点会使用该层次的协议进行通讯（注：同一个层次的协议，可能只有一个，也可能有多个）。 除了最顶层，每个层次的端点会向其【直接】上层提供“服务”；除了最底层，每个层次的端点会调用【直接】下层提供的“服务”（这里所说的“服务”指某种“编程接口”，技术行话叫 API）。 （“协议栈”的示意图） （“服务”与“协议”之间的关系） ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:3:2","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇逻辑信道 　（前一个小节说了）每个层次会向上一个层次提供服务（API 调用）。对上层而言，调用下层提供的 API 发送信息，其效果相当于在使用某种【信道】进行通讯，这也就是俺在 ★基本概念 那个章节所说的“逻辑信道”。 （“逻辑信道”示意图） ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:3:3","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇数据格式的原理 　大部分协议会把要传送的数据切割为 N 份，每一份就是一个数据包。 通常来说，数据包的格式有如下三部分： 头部 身体（也称作“有效载荷”） 尾部（注：很多协议没有尾部） 　如果你收过快递，可以把“网络数据包”与“快递包裹”作一个对照—— 数据包的“头/尾”，就类似于快递包裹的【包装袋】。数据包的“身体”，就类似于快递包裹里面的东西。 　对于【相邻】两层的协议，【下】层包含【上】层。也就是说：下层协议的【载荷】就是上层协议的【整体】。 还是以快递举例： 假设你从网上买了一台笔记本电脑。电脑出厂时，电脑厂商肯定会提供一个包装盒。快递公司在寄送这台笔记本的时候，又会在笔记本的盒子外面再加一个包装袋。对应到网络协议——“快递公司的包装袋”相当于【下层】协议；“电脑厂商的包装盒”，相当于【上层】协议。 （上下层协议的格式及包含关系） ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:3:4","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇网络分层的参考模型 　上述所说的“分层 ＆ 协议栈”只是一个抽象的（笼统的）思路。具体要分几层？每一层要干啥事儿？这些都是很有讲究滴！网络技术发展了几十年，已经有很多牛人提出了各种不同的划分方案，称之为“网络分层的参考模型”（为了打字省力，以下简称“模型”）。 在各种模型中，名气最大的当然是“OSI 模型”（洋文称作“OSI model”）。在后续的章节中，俺会以这个模型为主体，进行介绍。 除了“OSI 模型”还有一个很出名的模型是“TCP/IP 模型”（因为互联网很成功，它才跟着出名）。 对“TCP/IP 模型”的分层，不同的文章或书籍，说法不太一样（“3层、4层、5层”皆有），这就引发了一些争议。包括几位热心读者也在博客留言，表达不同意见。为了避免一家之言，贴出维基百科的“这个链接”，其中给出了几种比较有名的说法。 另外，俺想提醒一下： 由于本文是基于【OSI 模型】进行展开。对于 TCP/IP 模型到底算几层，这方面的争论【不】影响本文后续的内容。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:3:5","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"★OSI 概述 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:4:0","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇OSI 的历史 　“OSI”的全称是“Open System Interconnection”。先说说它的历史。 上世纪70年代，“国际电信联盟”（ITU）想对各国的电信系统（电话/电报）建立标准化的规格；与此同时，“国际标准化组织”（ISO）想要建立某种统一的标准，使得不同公司制造的大型主机可以相互联网。 后来，这两个国际组织意识到：“电信系统互联”与“电脑主机互联”的性质差不多。于是 ISO 与 ITU 就决定合作，两家一起干。这2个组织的2套班子，从上世纪70年代开始搞，搞来搞去，搞了很多年，一直到1984年才终于正式发布 OSI 标准。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:4:1","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇OSI 标准的两个组成部分 　严格来讲，OSI 包括两大部分—— 其一，抽象的概念模型，也就是前面提到的【OSI model】； 其二，针对这个概念模型的具体实现（具体的通讯协议），洋文叫做【OSI protocols】。 　（前面说了）OSI 是由 ISO ＆ ITU 联手搞出来滴。这两个国际组织里面的人，要么是来自各国的电信部门，要么是来自各国的高校学者。总而言之，既有严重的官僚风气，又有明显的学究风气。（正是因为这两种风气叠加，所以搞了很多年，才搞出 OSI） OSI 的协议实现（OSI protocols），不客气地说，就是一堆垃圾——据说把 OSI protocols 所有的协议文档，全部打印成 A4 纸，摞起来得有一米多高！是不是很吓人？协议搞得如此复杂，严重违背了 IT 设计领域的 KISS 原则。 由于 OSI protocols 实在太复杂，后来基本没人用。但 OSI model 反而广为流传，并且成为“网络分层模型”中名气最大，影响力最广的一个。 因此，本文后续章节中，凡是提到 OSI，指的是【OSI model】。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:4:2","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇OSI 模型的7层 　OSI 模型总共分7层，示意图参见如下表格： 层次中文名洋文名 第7层应用层Application Layer 第6层表示层Presentation Layer 第5层会话层Session Layer 第4层传输层Transport Layer 第3层网络层Network Layer 第2层数据链路层Data Link Layer 第1层物理层Physical Layer （注：为了打字省力，在后续章节把“数据链路层”直接称为“链路层”） 考虑到本文是针对一般性读者的【扫盲教程】，俺重点聊第1~4层。搞明白这几个层次之后，有助于你更好地理解网络的很多概念，也有助于你更好地理解很多信息安全的概念。 网上已经有很多关于 OSI 的文章，可惜大部分写得粗糙——很多文章只是在照抄定义。 俺曾经写过一篇《学习技术的三部曲：WHAT、HOW、WHY》，其中提到【理解技术】的不同层次。要想更好地理解 OSI 模型，你得搞明白：为啥需要引入某某层？（请注意：这是一个 WHY 型的问题） 接下来在讨论 OSI 的每个层次时，俺都会专门写一个小节，谈该层次的【必要性】。搞明白【必要性】，你就知道为啥要引入这个层次。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:4:3","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"★物理层：概述 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:5:0","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇物理层的必要性 　通俗地说：直接与物理介质打交道的层次，就是物理层。这一层的必要性比较明显。 因为所有的通讯，归根结底都要依赖于【物理介质】。与物理介质打交道，需要牵涉到很多与【物理学】相关的东东。比如：“无线电通讯”需要关心“频率/波长”；电缆通讯需要跟“电压”打交道；“光纤通讯”需要关心“玻璃的折射率＆光线的入射角” …… “物理层”的主要职责是：屏蔽这些细节，使得“物理层”之上的层次不用再去操心物理学。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:5:1","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇物理信道的类型 　何为“物理信道”，在本文开篇的“基本概念”已经提到了。 对于“物理信道”，还可以进一步细分为如下三大类： 1. 有线信道（比如：双绞线、同轴电缆、光纤、等等） 2. 无线信道（比如：微波通讯、电台广播、卫星通讯、等等） 3. 存储信道 　“存储信道”比较少见，很多人没听说过，稍微解释一下。 假设你要把一大坨信息传送给另一个人，除了用“有线 or 无线”这两种通讯方式，还可以把信息先保存到某种【存储介质】（比如硬盘），然后再把存储介质用某种方式（比如快递）转交给对方。这就是所谓的“存储信道”。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:5:2","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇信噪比（Signal-to-noise ratio） 　俺在很多篇关于“学习＆心理学”的博文中提到过【信噪比】这个概念。其实这个概念是从通讯领域借用的术语。 对于“物理信道”，总是会存在某些环境干扰，称之为“噪声”（Noise）。“信道传输的有用信息”与“无用的干扰噪声”，这两者的比值就是“信噪比”。 “信噪比”单位是【分贝】。“分贝”洋文叫做“decibel”（简写为 dB）。“deci”表示“十进制”；“bel”是为了纪念大名鼎鼎的贝尔（电话它爹）。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:5:3","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇带宽的限制因素 　“物理信道”要依赖于物理传输介质。不管使用何种物理介质，都要受限于某些基本的物理学定律（比如“光速上限”）。另外，不管何种物理介质，总是会有或多或少的环境干扰（噪声）。这两个因素导致了：任何“物理信道”的最大传输率总是有限滴。 由于物理层是最底下的一层，物理层之上的其它层次总是要直接或间接地依赖【物理信道】。因此，其它层次建立的“逻辑信道”，其带宽只会比“物理信道”的最大带宽更小。换句话说：“物理信道”的带宽上限也就是整个协议栈的带宽上限。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:5:4","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇多路复用（Multiplexing） 　一般来说，凡是能实现【长距离】通讯的“物理信道”，都有相当的经济成本。比如铺设“光纤、同轴电缆”都要花钱。无线电通讯虽然免去了铺设线路的成本，但需要竞标购买频段。因此，物理信道非常强调“多路复用”。 所谓的“多路复用”，通俗地说就是：尽可能地共享物理信道，不要浪费了。 “多路复用”有很多种类型；不同的类型，原理也不同。为了展示各种不同的原理，俺拿【无线通信】来说事儿。 无线通信领域的“多路复用”，【至少】有如下几种： 　频分多路复用/FDM（Frequency-Division Multiplexing） 这个最简单，就是根据频率拆分。不同的线路占用不同的频段，互不干扰。（电台广播用的就是这个思路） 但这个思路的缺点很明显—— 其一，要依赖足够宽的频段（频段是稀缺资源）； 其二，不同线路的流量可能会动态变化。如果某个线路空闲，其占用的频段就浪费了。 （注：光纤通讯中有个“波分多路复用/WDM”，本质上就是 FDM） 　时分多路复用/TDM（Time-Division Multiplexing） 这种思路只用一个很窄的频段。为了在同一个频道发送多个信道，采用【分时机制】，把时间切割成很小的时间片，每个线路占用一个时间片。周而往复。 这个思路有点像十字路口的红绿灯——每隔一段时间，其中一条路可以通行。 这个思路的优点是：可以只使用一个很窄的频段。缺点是：线路越多，每条线路等待越久；即使某个线路空闲，依然会占用时间片（浪费了资源）。 　码分多路复用/CDM（Code-Division Multiplexing） 这种思路采用某种【编码】的技巧，使得多个端点可以在同一个时间点使用同一频段发送数据；由于他们采用不同的编码方式，不会相互干扰。 一般来说，CDM 要依赖于“扩频技术”（spread spectrum），需占用一个比较宽的频道范围。这算是缺点。但其优点很明显—— 其一，可以支持 N 个线路（N 动态变化）； 其二，即使任何一个线路的流量动态变化，也不会浪费物理信道的资源。 显然，这种思路明显优于 FDM ＆ TDM。如今在移动通讯领域大名鼎鼎的 CDMA（码分多址），采用的就是这个思路。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:5:5","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"★物理层：具体实例 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:6:0","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇物理层的【协议】 　物理层的协议主要有如下： USB 协议 蓝牙协议的一部分 IEEE 802.11 的一部分（Wi-Fi） IEEE 802.16（WiMAX） IEEE 1394（火线接口） RS-232 协议（串行接口/串口） …… （考虑到篇幅）俺不可能具体细聊这些协议，只是贴出每个的维基百科链接，感兴趣的同学自己点进去看。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:6:1","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇物理层的【协议实现】 　对于电脑主机（含移动设备），“网卡硬件”包含了物理层的协议实现（参见如下示意图） 另外，还有一些专门的【1层】网络设备，也提供物理层的功能（参见下一个小节）。 （OSI 模型中，不同层次的协议实现） ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:6:2","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇物理层相关的【网络设备】 调制解调器（modem） 通俗地说，“调制解调器”就是用来翻译“数字信号 ＆ 模拟信号”。 在发送信息时，modem 把电脑要发送的“字节流”（数字信号）翻译成“模拟信号”，然后通过物理介质发送出去；当它从物理介质收到“模拟信号”，再翻译成“数字信号”，传回给电脑。 早期的拨号上网，modem 面对的物理介质是“固话线路”；如今家庭宽带普及，光纤入户，modem 面对的物理介质是“光纤线路”。 （老式 modem，用于固定电话线路） 中继器（repeater） 信号在物理介质中传输，会出现【衰减】（不论是“有线 or 无线”都有可能衰减）。“中继器”的作用是【信号增益】，使得信号能传得更远。 另外，比如“微波通讯”是直线传播，而地球表面有弧度，还有地形的起伏。所以每隔一定距离要建“微波塔”。这玩意儿也相当于“中继器”。 （微波塔示意图） 集线器（hub） 可以把“集线器”视作更牛逼的“中继器”——“中继器”只有两个口（只能连接两个通讯端点），而“集线器”有多个口（同时连接多个通讯端点）。 通常所说的“集线器”是指“以太网集线器”。这种设备如今已经逐步淘汰，很少见到了。 （老式的10兆以太网集线器） 另外，很多同学应该都用过“USB hub”，就是针对 USB 线的“集线器”（“USB 线”也可以视作某种通讯介质）。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:6:3","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"★链路层：概述 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:7:0","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇链路层的必要性 对信息的打包 物理层传输的信息，通俗地说就是【比特流】（也就是一长串比特）。但是对于计算机来说，“比特流”太低级啦，处理起来极不方便。“链路层”要干的第一个事情，就是把“比特流”打包成更大的一坨，以方便更上层的协议进行处理。在 OSI 模型中，链路层的一坨，称之为“帧”（frame）。 　差错控制 物理介质的传输，可能受到环境的影响。这种影响不仅仅体现为“噪声”，有时候会出现严重的干扰，导致物理层传输的“比特流”出错（某个比特“从0变1”或“从1变0”）。因此，链路层还需要负责检查物理层的传输是否出错。在 IT 行话中，检测是否出错，称之为“差错控制机制”（后面有一个小节会简单说一下这个话题）。 　流量控制 假设两个端点通过同一个物理信道进行通讯，这两个端点处理信息的速度可能不同。如果发送方输出信息的速度超过接收方处理信息的速度，通讯就会出问题。于是就需要有某种机制来协调，确保发送方的发送速度不会超出接收方的处理速度。在技术行话中，这称之为“流量控制”，简称“流控”。 　信道复用 在上一个章节已经讲到：用于远距离通讯的“物理介质”，总是有成本。因此需要对物理信道进行“多路复用”，就会导致多个端点共用同一个物理信道。如果同时存在多个发送者和多个接收者。接收者如何知道某个信息是发给自己而不是别人？ 另外，某些物理介质可能不支持并发（无法同时发送信息）。某些物理介质可能是【半双工】，所有这些物理层的限制，都使得“多路复用”变得复杂。为了解决这些问题，链路层需要提供了某种相应的机制（协议），术语叫做“介质访问控制”（洋文是“Media Access Control”，简称 MAC）。后续小节会聊它。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:7:1","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇差错控制 　为了发现传输的信息是否出错，设计了很多相应的数学算法。这些算法大体分为两类：“检错算法 ＆ 纠错算法”。 简而言之，“检错算法”只能检测出错误，而“纠错算法”不但能检测出错误，还能纠正错误。很显然，“纠错算法”更牛逼，但是它也更复杂。 常见的“检错算法”对传输的数据计算出一个【校验值】，接收方收到数据会重新计算校验和，如果算出来不对，就把收到的数据丢弃，让对方重发。“校验算法”的原理类似于《扫盲文件完整性校验——关于散列值和数字签名》一文中提到的“散列算法/哈希算法”。 “纠错算法”更高级，由于涉及到更多数学，俺就不展开啦。 对于【无线】物理信道，由于出错的概率更高，并且重新传输数据的成本也更高。所以【无线】通讯的链路层协议，更倾向于用【纠错】机制；作为对比，【有线】通讯的链路层协议，更倾向于用【检错】机制。 　“MAC 协议”用来确保对下层物理介质的使用，不会出现冲突。为了形象，俺拿“铁路系统”来比喻，说明“MAC 协议”的用途。 假设有一条【单轨】铁路连接 A/B 两地。有很多火车想从 A 开到 B，同时还有很多火车想从 B 开到 A。 首先，要确保不发生撞车（如果已经有车在 A 开往 B 的途中，那么 B 就不能再发车）；其次，即使是同一个方向的车，出发时间也要错开一个时间间隔。 所有这些协调工作，都是靠“MAC 协议”来搞定。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:7:2","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇MAC 地址 　为了完成上述任务，光有“MAC 协议”还不够，还需要为每一个端点引入【惟一的】标识。这个标识就称作“MAC 地址”。 通俗地说，每个网卡都内置了一个“MAC 地址”。这个地址是网卡在出厂的时候就已经设置好的，并且用某种机制确保该地址【全球唯一】。 　如何保证 MAC 地址全球唯一捏？简单说一下： MAC 地址包含6个字节（48个比特），分为两半。第一部分称作【OUI】，OUI 的24个比特中，其中2个比特有特殊含义，其它22个比特，用来作为网卡厂商的唯一编号。这个编号由国际组织 IEEE 统一分配。 MAC 地址第二部分的24比特，由网卡厂商自己决定如何分配。每个厂商只要确保自己生产的网卡，后面这24比特是唯一的，就行啦。 （MAC 地址的构成） 由于俺在很多安全教程中鼓吹大伙儿使用“操作系统虚拟机”，再顺便说说【虚拟网卡】的 MAC 地址。 “虚拟网卡”是由【虚拟化软件】创建滴。IEEE 也给每个虚拟化软件的厂商（含开源社区）分配了唯一的 OUI。因此，虚拟化软件在创建“虚拟网卡”时，会使用自己的 OUI 生成前面24个比特；后面的24比特，会采用某种算法使之尽可能【随机化】。由于“2的24次方”很大（224 = 16777216），碰巧一样的概率很低。 （注：如果手工修改 MAC 地址，故意把两块网卡的 MAC 地址搞成一样，那确实就做不到唯一性了。并且会导致链路层的通讯出问题） ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:7:3","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"★链路层：具体实例 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:8:0","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇链路层的【协议】 　链路层的协议主要有如下： MAC 协议（介质访问控制） LLC 协议（逻辑链路控制） ARP 协议（解析 MAC 地址） IEEE 802.3（以太网） IEEE 802.11 的一部分（Wi-Fi） L2TP 协议（2层VPN） PPP 协议（拨号上网） SLIP 协议（拨号上网） …… （考虑到篇幅）俺不可能具体细聊这些协议，只是贴出每个的维基百科链接，感兴趣的同学自己点进去看。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:8:1","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇链路层的【协议实现】 　对于电脑主机（含移动设备），“网卡硬件 ＆ 网卡驱动”会包含链路层协议的实现（参见如下示意图）。 另外，还有一些专门的【2层】网络设备，也提供链路层的功能（参见下一个小节）。 （OSI 模型中，不同层次的协议实现） ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:8:2","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇链路层相关的【网络设备】 网络交换机（network switch） （注：一般提到“网络交换机”，如果不加定语，指的就是“2层交换机”；此外还有更高层的交换机，在后续章节介绍） 为啥要有交换机捏？俺拿“以太网的发展史”来说事儿。 以太网刚诞生的时候，称之为“经典以太网”，电脑是通过【集线器】相连。“集线器”前面提到过，工作在【1层】（物理层），并不理解链路层的协议。因此，集线器的原理是【广播】模式——它从某个网线接口收到的数据，会复制 N 份，发送到其它【每个】网线接口。假设有4台电脑（A、B、C、D）都连在集线器上，A 发数据给 B，其实 C ＆ D 也都收到 A 发出的数据。显然，这种工作模式很傻逼（低效）。由于“经典以太网”的工作模式才“10兆”，所以集线器虽然低效，还能忍受。 后来要发展“百兆以太网”，再用这种傻逼的广播模式，就不能忍啦。于是“经典以太网”就发展为“交换式以太网”。用【交换机】代替“集线器”。 交换机是工作在2层（链路层）的设备，能够理解链路层协议。当交换机从某个网线接口收到一份数据（链路层的“帧”），它可以识别出“链路帧”里面包含的目标地址（接收方的 MAC 地址），然后只把这份数据转发给“目标 MAC 地址相关的网线接口”。 由于交换机能识别2层协议，它不光比集线器的性能高，而且功能也强得多。比如（稍微高级点的）交换机可以实现“MAC 地址过滤、VLAN、QoS”等多种额外功能。 　网桥/桥接器（network bridge） “交换机”通常用来连接【同一种】网络的设备。有时候，需要让两台不同网络类型的电脑相连，就会用到【网桥】。 下面以“操作系统虚拟机”来举例（完全没用过虚拟机的同学，请跳过这个举例）。 在这篇博文，俺介绍了虚拟机的几种“网卡模式”，其中有一种模式叫做【bridge 模式】。一旦设置了这种模式，Guest OS 的虚拟网卡，对于 Host OS 所在的外部网络，是【双向】可见滴。也就是说，物理主机所在的外部网络，也可以看见这块虚拟网卡。 现在，假设你的物理电脑（Host OS）只安装了【无线网卡】（WiFi），而虚拟化软件给 Guest OS 配置的通常是【以太网卡】。显然，这是两种【不同】的网络。为啥 Guest OS 的以太网卡设置为“bridge 模式”之后，外部 WiFi 网络可以看到它捏？ 奥妙在于——虚拟化软件在内部悄悄地帮你实现了一个“网桥”。这个网桥把“Host OS 的 WiFi 网卡”与“Guest OS 的以太网卡”关联起来。WiFi 网卡收到了链路层数据之后，如果接收方的 MAC 地址对应的是 Guest OS，网桥会把这份数据丢给 Guest OS 的网卡。 这种网卡模式之所以称作“bridge 模式”，原因就在于此。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:8:3","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇链路层相关的【软件工具】 嗅探抓包工具（Sniffer） 要了解链路层的数据包结构，需要用到“嗅探工具”。这类工具能捕获流经你网卡的所有【链路层】数据包。前面聊“协议栈”的时候说过：下层数据包的载荷就是上层数据包的整体。因此，拿到【链路层】数据包也就意味着：你已经拿到2层之上的所有数据包的信息了。 有些抓包工具自带图形界面，可以直接显示数据包的内容给你看。还有些只提供命令行（只是把获取的数据包保存为文件），然后要搭配其它图形化的工具来展示数据包的内容。 抓包的工具有很多，名气最大的是 Wireshark（原先叫做 Ethereal）。 　ARP 命令 首先，ARP 是“MAC 地址解析协议”的洋文名称。该协议根据“IP 地址”解析“MAC 地址”。 Windows 自带一个同名的 arp 命令，可以用来诊断与“MAC 地址”相关的信息。比如：列出当前子网中其它主机的 IP 地址以及对应的 MAC 地址。这个命令在 Linux ＆ Mac OS 上也有。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:8:4","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"★网络层：概述 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:9:0","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇网络层的必要性 路由机制（routing） 在 OSI 模型中，链路层本身【不】提供路由功能。你可以通俗地理解为：链路层只处理【直接相连】的两个端点（注：这么说不完全严密，只是帮助外行理解） 对于某个复杂网络，可能有很多端点，有很复杂的拓扑结构。当拓扑足够复杂，总有一些端点之间【没有直连】。那么，如何在这些【没有直连】的端点之间建立通讯捏？此时就需要提供某种机制，让其它端点帮忙转发数据。这就需要引入“路由机制”。 为了避免把“链路层”搞得太复杂，路由机制放到“链路层”之上来实现，也就是“网络层”。 　基于【路由】的地址编码方式 链路层已经提供了某种全球唯一的地址编码方式（MAC 地址）。但“MAC 地址”有如下几个问题： 其一，它是固定的（虽然可以用技术手段去修改 MAC 地址，但很少这么干） 其二，MAC 地址的编码是基于【厂商】，无法体现网络拓扑结构。或者说，“MAC 地址”对于“路由机制”是不够友好滴。 因此，需要引入一种更抽象（更高层）的地址，也就是“网络层地址”。咱们常说的“IP 地址”，是“网络层地址”的实现方式之一。 　为了帮你理解，举个例子： 每个人都有身份证号（这就类似于“MAC 地址”）。当某人加入了某个公司，公司会为此人再分配一个“员工号”（这就类似于“网络地址”）。既然有身份证号，为啥公司还要另搞一套“员工编号”捏？因为“员工编号”有额外的好处。比如说：可以把员工号划分为不同的区间，对应不同的部门。这样一来，只要看到员工号，就知道此人来自哪个部门。 类似道理，每个网卡都有自己固定的 MAC 地址，当这个网卡接入到不同的网络，每次都可以再分配不同的“网络地址”。通过“网络地址”可以看出这个网卡属于哪个网络（对路由比较方便）。 　网际互联（internetwork） 引入“网络层”的另一个目的是：屏蔽不同类型的网络之间的差异，从而有利于【网际互联】（也就是建立“网络的网络”）。 一般来说，要想联通【异种】网络，就要求每个网络中都有一台主机充当【网关】（gateway）。【网关】起到“中介/翻译”的作用——帮不同的网络翻译协议，使得不同的网络可以互相联通。 假设【没有】统一的网络层，网关的工作就很难做。就好比说：如果全球没有某种通用的自然语言，就需要培养非常多不同类型的翻译人才（假设有30种主要语言，任意两种互译，就需要几百种不同的翻译人才）。 反之，如果有了某种统一的网络层标准，问题就好办多了（还是假设有30种主要语言，只要选定某种作为通用语，然后培养29种翻译人才，就可以实现任意两种语言互译）。 如今的互联网时代，【IP 协议】就是那个充当统一标准的网络层协议。 （互联网整合了各种类型的网络） ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:9:1","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇网络拓扑（network topology） 　网络的拓扑结构有很多种，有简单的，有复杂的。一般来说，再复杂的拓扑，也可以逐步分解为若干简单拓扑的组合。 对拓扑的研究，有专门一个数学分支（拓扑学）。考虑到本文只是扫盲，俺不可能再去聊“拓扑学”。因此，只挑几种简单的拓扑结构，让大伙儿有个直观的印象。 （常见的网状拓扑结构：星形拓扑、环形拓扑、总线拓扑、网状拓扑、等等） 如今的互联网，整体的拓扑结构超级复杂。但还是可以逐步分解为上述几种基本的拓扑结构。 （互联网的复杂拓扑，右下角是图中某个小点的放大。 为节省大伙儿的翻墙流量，俺贴的是缩小图。点“这里”看原始图） ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:9:2","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇互联网的拓扑——从“历史”的角度看其健壮性 　从上面那张图可以看出：互联网拓扑的【局部】有很多是“星形拓扑”（当然也有其它的）。但从【宏观】上看，更像是“网状拓扑”。 在现实生活中，对于复杂结构，通常都会采用“树状层次结构”，以便于管理。比如：域名系统、公司组织结构、官僚系统 …… 那为啥互联网的【宏观】拓扑结构是“网状”捏？这就要说到互联网的历史。 　在上世纪50年代（冷战高峰期），美国军方的指挥系统高度依赖于电信公司提供的电话网络。当时的电话网络大致如下—— 在基层，每个地区有电话交换局，每一部电话都连入当地的交换局。 在全国，设有若干个长途局，每个交换局都接入某个特定的长途局（不同地区的交换局通过长途局中转）。 简而言之，当时美国的电话网络是典型的【多级星形拓扑】。这种拓扑的优点是：简单、高效、便于管理；但缺点是：健壮性很差。从这个案例中，大伙儿可以再次体会到“效率”与“健壮性”之间的矛盾。俺写过一篇很重要的博文（这里）深入讨论了这个话题。 话说1957年的时候，苏联成功试射第一颗洲际弹道导弹（ICBM），美国军方开始担心：一旦苏联先用洲际导弹攻击美国，只要把少数几个长途局轰掉，军方的指挥系统就会瘫痪。也就是说，“长途局”已经成为美国军方的【单点故障】（何为“单点故障”？参见这篇博文）。 1960年，美国国防部找来大名鼎鼎的兰德公司进行咨询，要求提供一个应对核打击的方案。该公司的研究员 Paul Baran 设计了一个方案，把“星形拓扑”改为【网状拓扑】。采用【网状拓扑】的好处在于：即使发生全面核大战，大量骨干节点被摧毁，整个网络也不会被分隔成几个孤岛，军方的指挥系统依然能正常运作。 （左边：互联网诞生前——美国的电话网络　右边：兰德公司的“Baran 方案”） 有了兰德公司的方案，美国军方找到当时最大的电信公司 AT＆T，想要实现这个系统，结果被否决了。AT＆T 高层认为：搞这样一种系统根本不切实际。于是 Baran 的方案中途夭折。 为啥 AT＆T 反对这个方案捏？一方面，成功的大公司总是有很强的思维定势（关于这点，参见这篇文章）；另一方面，Baran 的设计方案确实很超前——其前瞻性不仅包括“拓扑结构”，而且把当时电信行业的几大核心观念完全颠覆掉了（具体如何颠覆，后续章节还会再聊）。 时间一晃又过了好多年，到了60年代末，由于一系列机缘巧合，英国佬发现了“Baran 方案”的价值，并据此搞了一个小型的 NPL 网络（NPL 是“国家物理实验室”的缩写）。然后在某次 ACM 会议上，美国佬看到英国佬的论文，才意识到：Baran 方案完全可行。经历了“出口转内销”的命运之后，该方案重新被美国国防部重视。之后，（国防部下属的）“高级计划研究局”（ARPA）开始筹建“阿帕网”（ARPANET），才有了如今的互联网。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:9:3","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇路由的大致原理 　聊完“拓扑”，再来聊“路由”。 当主机 A 向主机 B 发送网络层的数据时，大致会经历如下步骤： A 主机的协议栈先判断“A B 两个地址”是否在同一个子网（“子网掩码”就是用来干这事儿滴）。 如果是同一个子网，直接发给对方；如果不是同一个子网，发给本子网的【默认网关】。 （此处所说的“网关”指“3层网关/网络层网关”） 对于“默认网关”，有可能自己就是路由器；也可能自己不是路由器，但与其它路由器相连。 也就是说，“默认网关”要么自己对数据包进行路由，要么丢给能进行路由的另一台设备。 （万一找不到能路由的设备，这个数据就被丢弃，于是网络通讯出错） 当数据到达某个路由器之后，有如下几种可能—— 3.1 该路由器正好是 B 所在子网的网关（与 B 直连），那就把数据包丢给 B，路由过程就结束啦； 3.2 亦或者，路由器会把数据包丢给另一个路由器（另一个路由器再丢给另一个路由器） …… 如此循环往复，最终到达目的地 B。 3.3 还存在一种可能性：始终找不到“主机 B”（有可能该主机“断线 or 关机 or 根本不存在”）。为了避免数据包长时间在网络上闲逛，还需要引入某种【数据包存活机制】（洋文叫做“Time To Live”，简称 TTL）。 通常会采用某个整数（TTL 计数）表示数据包能活多久。当主机 A 发出这个数据包的时候，这个“TTL 计数”就已经设置好了。每当这个数据包被路由器转发一次，“TTL 记数”就减一。当 TTL 变为零，这个数据包就死了（被丢弃）。 　对于某些大型的复杂网络（比如互联网），每个路由器可能与其它 N 个路由器相连（N 可能很大）。对于上述的 3.2 情形，它如何判断：该转发给谁捏？ 这时候，“路由算法”就体现出价值啦—— 一般来说，路由器内部会维护一张【路由表】。每当收到一个网络层的数据包，先取出数据包中的【目标地址】，然后去查这张路由表，看谁距离目标最近，就把数据包转发给谁。 上面这段话看起来好像很简单，其实路由算法挺复杂滴。考虑到本文是“扫盲性质”，而且篇幅已经很长，不可能再去聊“路由算法”的细节。对此感兴趣的同学，可以去看《计算机网络》的第5章。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:9:4","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇路由算法的演变史（以互联网为例） 　（技术菜鸟可以跳过这个小节） 由于互联网的 IP 协议已经成为“网络层协议”的事实标准，俺简单聊一下互联网的路由机制是如何进化滴。 　第1阶段：静态全局路由表 （前面说了）互联网的前身是“阿帕网/ARPANET”。在阿帕网诞生初期（上世纪70年代），全球的主机很少。因此，早期的路由表很简单，既是“全局”滴，又是“静态”滴。简而言之，每个路由器内部都维护一张“全局路由表”，这个“路由表”包含了全球所有其它路由器的关联信息。每当来了一个数据包，查一下这张全局路由表，自然就清楚要转发给谁，才能最快到达目的地。 早期的阿帕网，主机的变化比较少，也很少增加路由器。每当出现一个新的路由器，其它路由器的管理员就手工编辑各自的“全局路由表”。 为了加深大伙儿印象，特意找来两张70年代初的阿帕网拓扑图（注：图中的 IMP 是“Interface Message Processor”的缩写，也就是如今所说的“路由器”）。 （1973年的阿帕网） （1977年的阿帕网） 第2阶段：动态全局路由表 后来，“阿帕网/互联网”的规模猛增，路由器数量也跟着猛增，隔三差五都有新的路由器冒出来。再用“静态路由表”这种机制，（编辑路由表的）管理员会被活活累死。于是改用“动态路由表”，并引入某种“路由发现机制”。但“路由表”依然是【全局】滴。 　第3阶段：动态分级路由表 再到后来，全球的路由器越来越多，成千上万，再搞“全局路由表”已经不太现实了—— 一方面，“全局路由表”越来越大（查询的速度就越来越慢） 另一方面，由于互联网的流量越来越大，每来一个数据包都要查表，查询越来越频繁。 于是，路由器开始吃不消了。为了解决困境，想出一个新招数：引入“分级路由”（hierarchical routing）。所谓的“分级路由”就是：把整个互联网分为多个大区域，每个大区域内部再分小区域，小区域内部再分小小区域 …… 看到这里，熟悉“数据结构与算法”的同学就会意识到——这相当于构造了一个【树状】层次结构。 有了这个层次结构，每个路由器重点关注：自己所在的那个最小化区域里面的网络拓扑。如此一来，每个路由器的“路由表”都会大幅度减小。 （全局路由表 VS 分级路由表） ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:9:5","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇互联网的路由——从“CAS”的角度看其健壮性 　去年（2020）俺写了一篇博文《“政治体制”与“系统健壮性”——基于“复杂性科学”的思考》，其中介绍了“CAS”（复杂自适应系统）的概念。互联网的路由机制，就是一个典型的 CAS。 如果把互联网视作一个系统，每个公网上的路由器都是一个自适应的主体。假如某个地区的网络流量突然暴涨，骨干网路由器会自动分流；假如因为地震或战争，导致某个地区的骨干网路由器全部下线，周边地区的路由器也会自动避开这个区域 ….. 所有这些工作，【不需要】依靠任何最高指挥中枢，去进行协调。 相反，如果互联网的路由系统中，设立了某种“中央委员会”进行实时调度，那互联网早就完蛋了，根本无法成长为今天这种规模。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:9:6","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇网络层的两种交换技术——电路交换（circuit switching） VS 分组交换（packet switching） 　（技术菜鸟可以跳过这个小节） 前面聊“互联网诞生”，说到兰德公司的“Baran 方案”。该方案对当时的电信系统提出几大革命性的变化，其中之一就是“分组交换”技术（也称“数据包交换”or“封包交换”）。 一般来说，网络层的设计有两种截然不同的风格：【电路交换 VS 分组交换】。有时候也分别称之为“有连接的网络层 VS 无连接的网络层”。此处所说的“连接”指的是某种“虚电路”（洋文叫做“virtual circuit”，简称 VC）。 　要理解“虚电路”，首先要从老式的电话系统说起。 最早期的电话，既没有拨号盘也没有按键，全靠一张嘴。当你拿起电话，先告诉接线员你要打给谁，接线员会用一根跳接线，插入电话交换设备的某个插孔，从而把你的电话机与对方的电话机相连。于是建立了一条两人之间的电话通路，也就是“电路”。你可以把“接线员”想象成某种“人肉路由器” :) （1900年法国巴黎的电话交换局，可以看到接线员在操作电话交换设备） 后来发明了“自动电话交换机”，导致“接线员”全体下岗。虽然自动化了，但原理还是一样——当你在电话上拨了某人的号码，电话局的交换机会自动选择一条线路。只有当这条线路建立起来，对方的电话才会响。一旦双方开始通话，双方之间的语音都是通过这条线路传输。并且这条线路是独占的——只要通话不挂断，这条线路就不会再分配给其他人使用。 　前面提到“互联网诞生的历史”，当时军方推动的“Baran 方案”被 AT＆T 断然拒绝。因为这个方案完全颠覆了传统的电话系统—— 颠覆之1：把“模拟信号”颠覆为“数字信号”（这点比较好理解，俺就不解释了） 颠覆之2：把“星形拓扑”颠覆为“网状拓扑”（关于这点，前面的小节已经讨论了） 颠覆之3：把“电路交换”颠覆为“分组交换”（这就是本小节的重点） 　为了帮大伙儿理解上述第3点，举个例子： 假设主机 A 要向主机 B 发送一大坨数据。因为数据太多，肯定要分成好几坨小一点的（分成多个数据包）。如何把这些数据包发送给对方捏？ 　“电路交换”的实现方式 在发送数据之前，要先建立连接通道（通过路由算法，找出 A ＆ B 之间的某条通路）。这条通路就是所谓的“虚电路/VC”。一旦 VC 建立，每一个数据包都是从这条拓扑路径进行路由。 　“分组交换”的实现方式 在发送数据之前，【不需要】建立通道，让每个数据包独立进行路由。这种情况下，这几个数据包可能会走【不同的】拓扑路径。因此，数据包到达的顺序与发送的顺序【不一定】相同。接收方收到所有数据包之后，还要自己进行排序。 维基百科上有一个 GIF 动画（这个链接），比较直观地演示“分组交换/封包交换”的效果。由于这个动画稍微有点大（超过 1MB），俺就不贴到博文中了。 　当时的电话系统主要承载语音传输，“电路交换”显然性能更高。那为啥 Baran 的设计要采用“分组交换”捏？俺又要再次提到【效率 VS 健壮性】之间的矛盾与均衡。 对于“电路交换”，一旦建立连接，同一个连接的所有数据都走相同的路径（会经过完全相同的路由器）。也就是说，传输的过程中，如果某个路由器挂掉了（网络掉线 or 硬件当机 or 软件崩溃）。那么，该路由器正在处理的 N 个连接全都要报废。而“分组交换”则更加灵活——即使某个路由器挂掉了，后续的数据包会自动转向另外的路由器，损失很小。 “Baran 方案”之所以采用“分组交换”的设计，因为人家这个方案是提交给军方用来应对【全面核战争】滴，当然要考虑健壮性啦。 　话说这两种交换机制，各有很多支持者，并分裂为两大阵营，分别是：“电信阵营 VS 互联网阵营”。两大阵营的口水战持续了 N 年，都无法说服对方。到了后来设计 OSI 模型的时候，为了保持中立性与通用性，OSI 模型本身并没有强制要求网络层采用哪一种风格。 经过几十年之后，咱们已经可以看出来：“互联网阵营”占据主导地位。如今，连电信系统都是架构在互联网之上。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:9:7","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"★网络层：具体实例 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:10:0","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇网络层的【协议】 　网络层的协议有很多。由于“互联网”已经成为全球的事实标准，因此俺只列出属于“互联网协议族”的那些“网络层协议”： IP 协议（含 IPv4 ＆ IPv6） ICMP IGMP IPSec …… （考虑到篇幅）俺不可能具体细聊这些协议，只是贴出每个的维基百科链接，感兴趣的同学自己点进去看。 对上述这些协议，最重要的当然是 IP 协议。如果你想要深入了解 IP 协议，可以参考如下这本书。关于 IP 协议的书，此书的影响力最大。这本书共3卷，通常只需看第1卷。 《TCP-IP 详解》 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:10:1","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇网络层的【协议实现】 　对于电脑主机（含移动设备），网络层的协议实现通常包含在操作系统自带的网络模块中（也就是“操作系统协议栈”）。具体参见如下示意图。 另外，还有一些专门的【3层】网络设备，也提供网络层的功能（参见本章节的后续小节）。 （OSI 模型中，不同层次的协议实现） ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:10:2","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇IP 地址的格式及含义 　当年设计阿帕网的时候，采用了【4字节】（32比特）来表示“网络层地址”（也就是 IP 地址）。 “IP 地址”的含义很重要，俺有必要解释一下： 咱们平时所说的 IP 地址，采用【点分十进制】来表示。就是把地址的4个字节，先翻译为十进制，然后每个字节用一个小数点分隔开（参见如下示意图）： （4字节 IP 地址：“二进制”与“点分十进制”的对照示意图） “IP 地址”的32比特，分为两部分：第1部分用来标识【子网】，第2部分用来标识该子网中的【主机】。 这两部分各占用多少比特，是不确定的。在这种情况下，“操作系统协议栈”如何知道哪些比特标识“子网”，哪些比特标识“主机”捏？奥妙在于【子网掩码】。所以，大伙儿在给系统配置 IP 地址的时候，通常都需要再设置一个【子网掩码】，就这个用途。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:10:3","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇IP 地址枯竭，及其解决方法 　前一个小节提到：IP地址包含【4字节】（32比特）。因此，最多只能表示【2的32次方】（42亿左右）的不同地址。考虑到还有很多地址保留给特殊用途，实际可用地址远远不到42亿。 到了如今，全球网民都已经几十亿了，IP 地址开始枯竭。咋办捏？为了解决这个问题，发展出若干技术手段。简单说一下最常见的几种手段： 　IPv6 名气最大（最多人知道）的技术手段，大概是 IPv6 了。这招想要一劳永逸地解决地址枯竭的问题，采用了16字节（128比特）来表示 IP 地址。 设计 IPv6 的人自豪地宣称：即使给地球上的每一粒沙子分配一个 IPv6 地址，依然绰绰有余（确实没有吹牛，“2的128次方”是天文数字）。 但 IPv6 的缺点在于，【无法】向下兼容原有的 IP 协议（原有的协议叫“IPv4”）。IPv6 的普及一直比较慢，这是主要原因。 　代理服务器（proxy） 一看到代理，很多人就想到翻墙。其实它也可以用来解决“地址枯竭”的问题。 比如说，某个公司有100人，100台电脑。如果每台电脑都分配公网 IP 地址，就要消耗100个公网地址（太浪费啦）。 可以只申请一个公网 IP，然后在内网搞一个代理服务器，公网 IP 分配给它（代理服务器有两个网卡，一个接内网，一个接公网）。然后在其它电脑上设置代理，指向这台代理服务器，就都可以上外网啦。 （注：在本文的末尾有一个 ★杂项 的章节，会专门聊一下“代理”这个话题） 　网络地址转换（NAT） 前面 proxy 那招有个缺点：内网的每台电脑里面的每个上网软件，都要单独设置代理。实在太麻烦啦！ 后来就发明了某种更牛逼的招数——网络地址转换（洋文是“Network Address Translation”，简称 NAT）。 用了这招，还是只要申请一个公网 IP，分配给内网的网关（网关有两个网卡，一个接内网，一个接公网）。然后在内网的网关配置 NAT 功能，自动就可以让内网的每台电脑访问外网。 在这篇博文，俺介绍了虚拟机的几种“网卡模式”，其中有一种模式叫做【NAT 模式】，就是指这个玩意儿。 采用了 NAT 技术之后，可能会对某些应用软件（尤其是 P2P 类型的）造成兼容性问题，于是又发明了一些“NAT 穿透技术”（NAT traversal）。这类技术有好几种，如果有空的话，俺会单独写教程介绍。 　其它解决方法 关于“IPv4 地址空间耗尽”，解决方法肯定不止上面这几招。限于篇幅，就此打住。更多的讨论参见维基百科的“这个链接”。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:10:4","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇网络层相关的【网络设备】 路由器（router） （前面章节聊“路由原理”的时候，已经介绍过它；这里就不再浪费口水啦） 　3层交换机（Layer 3 switching） “3层交换机”是在“2层交换机”的基础上，增加了对网络层的处理。因此，它可以做到类似路由器的效果——在几个子网之间转发数据。 与路由器的差别在于——“3层交换机”链接的几个子网是【同种】网络；而路由器可以连接【异种】网络。 从上面这句话看，“3层交换机”的能力显然不如“路由器”。既然已经有“路由器”，为啥还要发明“3层交换机”捏？这就要说到【单臂路由器】的弊端。 对于企业内网的“2层交换机”，通常都支持 VLAN 功能。通俗地说：可以在交换机中划分多个【虚拟子网】。其实这些子网的中所有的电脑，都还是接入这台交换机，只不过这些子网配置了不同的网络地址。对于同一个 VLAN 内部的通讯，“2层交换机”自己就可以搞定（只需要用到2层协议）；但对于【跨】VLAN 主机之间的通讯，“2层交换机”就没戏啦（它没有路由功能）。因此，就必须在它旁边外加一个路由器，形成如下拓扑结构。在这个拓扑中，路由器只与单个设备（2层交换机）相连，所以称之为“单臂”。 请注意：如下示意图只画了两台电脑，位于两个 VLAN。实际上可能有很多个 VLAN，每个里面有几十台电脑。于是，交换机与路由器之间的传输通道就会成为瓶颈——【跨】VLAN 的任意两台电脑通讯，数据包都要到路由器那里兜一圈。为了消除这种瓶颈，才发明了“3层交换机”——把路由功能直接集成到交换机内部。 （“单臂路由器”的拓扑结构） 无线热点（Wireless Access Point） “无线热点”通常用来提供无线接入，使得某个【无线】设备能接入到某个【有线】网络中。一般来说，热点都内置了路由功能，那么它就是“无线路由器”，对应到“3层”（网络层）。反之，如果没有路由功能，它就是“网桥”，属于“2层”（链路层）。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:10:5","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇网络层相关的【软件工具】 ping 这个命令，很多人应该都知道。早在 Win9x 就有这个命令了。它使用（网络层的）ICMP 协议来测试某个远程主机是否可达。 提醒一下： 如果 ping 命令显示某个 IP 地址不可达，有很多种情况。比如说： 这个 IP 地址对应的主机已经关机 这个 IP 地址对应的主机已经断线 这个 IP 地址对应的主机拒绝响应 ICMP 协议 从你本机到这个 IP 地址之间，有某个防火墙拦截了 ICMP 协议 …… traceroute 这是一个通用的工具，用来测试路由。很早以前的 Windows 就已经内置了它，命令是 tracert。在 POSIX（Linux＆UNIX）上通常叫 traceroute 你可以用这个命令，测试你本机与互联网另一台主机之间的路由（也就是：从你本机到对方主机，要经过哪些路由器） ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:10:6","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"★传输层：概述 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:11:0","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇传输层的必要性 屏蔽“有连接 or 无连接”的差异 （上一个章节提到）网络层本身已经屏蔽了【异种网络】的差异（比如“以太网、ATM、帧中继”之间的差异），而且网络层也屏蔽了路由的细节。但网络层本身还有一个差异，也就是网络层的两种交换技术：电路交换（有连接） VS 分组交换（无连接）。 前面章节也提到了：上述两种交换技术各有很多支持者，并分裂为两大阵营。当年设计 OSI 模型的时候，为了保持中立性与通用性，并没有强制规定“网络层”必须采用何种交换机制。 对于开发网络软件的程序员来说，当然不想操心“网络层用的是哪一种交换机制”。因此，需要对网络层的上述差异再加一个抽象层（也就是“传输层”）。 　从“主机”到“进程” 前面介绍的“网络层”，其设计是面向主机（电脑）。“网络层地址”也就是某个主机的地址。 而“传输层”是面向【进程】滴！因为传输层要提供给【网络软件】使用，而网络软件打交道的对象是【另一个网络软件】。因此，传输层必须在“网络层地址”的基础上，再引入某种新的标识，用来区分同一台主机上的不同【进程】。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:11:1","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇传输层的特殊性 　在 OSI 7层模型中，传输层正好居中。这是一个很特殊的位置。 OSI 模型最下面3层，与【网络设备】比较密切。这里面所说的“网络设备”，既包括那些独立的主机（比如“路由器、交换机、等”），也包括电脑上的硬件（比如“网卡”）。 OSI 模型最上面3层，与【网络软件】比较密切（或者说，与“用户的业务逻辑”比较密切）。 而中间的传输层，正好是承上启下。对于开发应用软件的程序猿/程序媛，“传输层”是他们能感知的最低一层。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:11:2","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇传输层的【端口】 　刚才谈“传输层的必要性”，提到说——“网络层地址”只能标识【主机】，而传输层必须要能标识【进程】。为了达到这个目的，于是就引入了“传输层端口”这个概念（为了打字省力，后续讨论简称为“端口”）。 在 OSI 模型中，“端口”的官方称呼是“传输服务访问点”（洋文缩写 TSAP）。但是作为程序员，俺已经习惯于“端口”这个称呼。后续介绍依然用“端口”一词。 当程序员使用传输层提供的 API 开发网络软件时，通常把“端口”与“网络地址”一起使用（构成“二元组”），就可以定位到某个主机上的某个进程。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:11:3","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"★传输层：具体实例 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:12:0","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇传输层的【协议】 　为了让程序员可以更爽地使用传输层来开发网络软件，传输层既要提供“有连接”的风格，也要提供“无连接”的风格。关于这两种风格的对比，前面已经聊过，这里不再浪费口水。 具体到“互联网协议族”，有两个主要的传输层实现，分别是 TCP ＆ UDP（前者是“有连接”，后者是“无连接”）。 除了 TCP ＆ UDP，“互联网协议族”还提供了其它一些传输层协议。因为比较冷门，俺就不介绍啦。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:12:1","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇传输层的【协议实现】 　对于电脑主机（含移动设备），传输层的协议实现通常包含在操作系统自带的网络模块中（也就是“操作系统协议栈”）。具体参见如下示意图。 另外，还有一些专门的【4层】网络设备，也提供传输层的功能（参见后续的小节）。 （OSI 模型中，不同层次的协议实现） ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:12:2","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇套接字（socket API） 　前面说了：传输层是面向程序员（让他们可以更方便地开发网络软件）。因此，就需要提供一些封装传输层的【库】（API）。程序员只需要调用这些【库】，就可以使用传输层的协议进行通讯啦。 影响力最大的传输层封装库，当然是 socket API。它来自加州大学伯克利分校。 在互联网诞生初期，伯克利分校开发了一个 UNIX 操作系统的的变种，叫做“伯克利 UNIX 发行版”（BSD Unix），也就是如今 BSD 操作系统的前身。伯克利发行版内置了一套用来进行网络编程的 API，当时叫做“伯克利套接字”（Berkeley sockets）。由于这套 API 用起来很方便，很多其它的 UNIX 变种也移植了这套 API，于是就逐渐成了业界的事实标准。到了上世纪90年代，Windows ＆ Linux 也都提供了这套 API。 由于大部分读者不是程序员，“套接字”这个话题就到此为止。如果你是个程序员，并且对网络编程感兴趣，可以参考俺的电子书清单，其中有一个分类目录是【IT 类 / 软件开发 / 网络相关】。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:12:3","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇传输层相关的【网络设备】 4层交换机（Layer 4 switching） 前面已经介绍了“3层交换机”，“4层交换机”是其进一步的改良，可以识别传输层的协议，获取 TCP or UDP 的端口号。 有了这个能力，网管就可以在这种交换机上配置一些管理策略。比如说：（根据传输层端口号）过滤掉某种流量，或者对某种流量设置转发的优先级。 　状态防火墙（stateful firewall） 网络防火墙分好几种，大部分属于这种。它能完全处理 TCP 协议的状态，显然它属于“4层”（传输层）。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:12:4","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇传输层相关的【软件工具】 netcat 家族——传输层的“瑞士军刀” 关于 netcat，俺已经写过一篇比较详细的教程：《扫盲 netcat（网猫）的 N 种用法——从“网络诊断”到“系统入侵”》。看完这篇教程，你肯定能体会它功能的强大——很多与 TCP/UDP 相关的事情，都可以用 netcat 搞定。 另外，netcat 还有很多衍生品（衍生的开源项目），构成一个丰富的 netcat 家族。在上述教程也有介绍。 　netstat ＆ ss Windows 和 POSIX（Linux＆UNIX）都有一个 netstat 命令，可以查看当前系统的 TCP/UDP 状态（包括当前系统开启了哪些监听端口）。 另外，Linux 上还有一个 ss 命令，功能更强（但这个命令在 Windows 上默认没有） 　nmap 这是最著名的开源的扫描器，可以扫描远程主机监听了哪些传输层端口（注：前面提到的“netcat 家族”也可以干这事儿） nmap 的功能很强，“端口扫描”只是其功能之一。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:12:5","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"★业务层（OSI 上三层）：概述 　一不小心，这篇教程已经写了这么长。为了照顾那些有“阅读障碍”的读者，俺要稍微控制一下篇幅，就把 OSI 的【上三层】合在一起讨论。 前面的章节说过：【上三层】更接近于“网络软件”，对应的是应用软件的业务逻辑，因此俺统称为“业务层”。 注：有些书（比如《计算机网络》）会把 OSI 的上三层统称为“应用层”。由于 OSI 模型中本来就有一个“应用层”，俺认为这样容易搞混（尤其不利于技术菜鸟），所以另外起了一个“业务层”的名称。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:13:0","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇业务层的必要性 　业务层显然是必要滴。因为传输层位于操作系统，它不可能去了解网络软件的业务逻辑。为了让网络软件能够相互通讯，肯定要在传输层之上再定义更高层的协议。 问题在于：网络软件千奇百怪，其业务逻辑各不相同，因此，“业务层如何设计”，【无】一定之规。有些软件只用一个协议来搞定所有的业务逻辑（只有一层）；有些软件会参考 OSI，把业务逻辑的协议分为三层；还有些软件可能会分出更多的层次。 再强调一下：业务层的协议如何分层，完全看具体的业务逻辑，不要生搬硬套任何现有的参考模型。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:13:1","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇会话层 ＆ 表示层 ＆ 应用层 　对于大部分读者来说，【没必要】花时间去了解 OSI 最上面三层之间的区别。你只需把最上面三层视作【一坨】——他们都是与网络软件的业务逻辑密切相关滴。 那么，哪些人需要详细了解“这三层的差异”捏？ 如果你是个程序员，并且你正好是开发【网络】软件，俺建议你了解一下 OSI 模型的最上面三层，有助于你更深刻地思考某些网络协议的设计。所谓的“更深刻”指的是：你不能光停留在 WHAT 层面，要提升到 HOW 甚至 WHY 层面（参见《学习技术的三部曲：WHAT、HOW、WHY》） ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:13:2","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"★业务层（OSI 上三层）：具体实例 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:14:0","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇业务层的【协议】 　业务层的协议非常多。即使光把各种协议的名称列出来，也很费劲。所以俺就偷懒一下，只点评几个特别重要的协议。 　HTTP 协议 如果让俺评选最重要的业务层协议，俺首推 HTTP 协议。互联网的普及推动了 Web 的普及，而 Web 的普及使得 HTTP 成为信息时代的重要支柱。当你上网的时候，你看到的网页（HTML 页面）就是通过 HTTP 协议传输到你的浏览器上。 如今 HTTP 已经不仅仅用来展示网页，还有很多业务层的协议是建立在 HTTP 协议之上。比如说：如果你用 RSS 订阅俺的博客，RSS 阅读器需要调用 blogspot 博客平台提供的 RSS 接口，这些 RSS 接口就是基于 HTTP 协议传输滴。 考虑到本文的篇幅，俺不可能在这里细聊 HTTP 协议的规格，有兴趣的同学可以去看《HTTP 权威指南》这本书。 　SSL/TLS 协议 最早的 HTTP 协议是【明文】滴；为了强化安全性，后来又设计了 SSL 协议，用来【加密】HTTP 流量；再后来，SSL 升级为 TLS（这俩是同义词）。如今经常看到的 HTTPS 相当于“HTTP over TLS”。 SSL/TLS 设计得比较优雅（很灵活），使得其它业务层的协议可以很方便地架构在 SSL/TLS 之上。这样的好处是：其它协议就不用自己再设计一套加密机制＆认证机制。 SSL/TLS 对于安全性很重要，因此俺专门写了一个系列教程（如下），详细介绍该协议的技术细节。 《扫盲 HTTPS 和 SSL／TLS 协议》（系列） 　域名相关的协议（DNS 及其它） 域名相关的协议，也很重要。因为域名系统是整个互联网的基础设施。最早的域名查询协议是“DNS 协议”，由于这个协议【没有】加密，导致了一些安全隐患。比如 GFW 就利用 DNS 的这个弱点，搞“域名污染/域名投毒”。因此，后来又设计了一系列新的域名协议，引入了加密的机制。 关于这些协议的扫盲教程，可以参考如下几篇博文： 《扫盲 DNS 原理，兼谈“域名劫持”和“域名欺骗／域名污染”》 《对比4种强化域名安全的协议——DNSSEC，DNSCrypt，DNS over TLS，DNS over HTTPS》 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:14:1","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇业务层相关的【网络设备】 应用层防火墙（application firewall） 前面提到了：大多数网络防火墙处于4层（状态防火墙），另外还有少数处于7层，也就是“应用层防火墙”（有时候也称之为“7层防火墙”）。 一般来说，这类防火墙具备了【深度包检测】（deep packet inspection，简称 DPI）的能力，可以分析应用层协议的【内容】。 简单说一下“深度包检测”： 如果某个网络设备，仅仅分析“应用层协议”本身，它还【不够格】称之为 DPI。为了做到 DPI，还要能理解应用层协议所承载的【内容】。 比如说：某人通过【明文】的 HTTP 协议从网上下载了一个 zip 压缩包。对于这个下载行为，那些做得好的 DPI 设备不光能识别出“HTTP 协议的内容是 ZIP 压缩包”，而且还能从 ZIP 压缩包中提取出里面的文件。 　一般来说，“入侵检测”如果不加定语，通常指“【网络】入侵检测”（洋文叫 NIDS）；另外还有一种“【主机】入侵检测”（洋文叫 HIDS）。HIDS 与本文无关。 “入侵检测”是一种网络安全设备，它通过嗅探（sniffer）的方式抓取网上的数据包，然后进行分析，尝试发现网络中是否存在黑客/骇客的入侵的行为。故名“入侵检测”。 由于 IDS 需要理解【应用层】（7层）的内容，因此它与“应用层防火墙”有个共同点，需要具备某种程度的 DPI（深度包检测）能力。它俩的一大差异是【部署方式】。 考虑到很多读者是 IT 外行，简单说一下“旁路部署”—— 如果你学过中学物理，应该知道电路有“串联 ＆ 并联”。所谓的“旁路部署”类似于电路中的【并联】。通俗地说：IDS 是【并联】部署，防火墙是【串联】部署。 　GFW（Great Firewall） 本博客已经写了很多翻墙教程，大伙儿肯定都知道 GFW 了。 由于“Great Firewall”中有“Firewall”字样，很多天朝网民【误以为】GFW 是防火墙，其实不然！GFW 本质上就是 IDS——其部署方式类似于 IDS（旁路部署），其工作方式有很大一部分也类似于 IDS（当然啦，GFW 的功能比 IDS 更多）。 大约七八年前，就有热心读者建议俺写一篇技术博文，介绍 GFW 的工作原理。由于俺比较懒，拖到今年（2021）都没动手，很惭愧 :( ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:14:2","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"★杂项 　有些概念，并不属于某个特定的层次，单独放到这个章节。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:15:0","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇VPN（virtual private network） 　咱们天朝的网民使用 VPN，一多半是为了翻墙。其实 VPN 的本意（如其名称所示）是为了提供某种虚拟化的私有的网络，让身处异地的多个人，可以用 VPN 构建出一个虚拟的内网，从而能在这个内网中协同工作。 VPN 的类型很多，使用的技术也各不相同，因此 VPN 对应的 OSI 层次很宽（“1层”到“6层”）。俺到维基百科剽窃了如下这张图，让你见识一下 VPN 的多样性。 （名目繁多的 VPN，分类示意图） ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:15:1","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇代理（proxy） 　那些经常翻墙的同学，对“代理”应该都很熟悉了。“代理”与 VPN 类似，一开始并不是用来翻墙滴，“翻墙”只是这俩的副业。 　代理服务器（proxy server） “代理服务器”部署在“客户端 ＆ 服务端”之间，起到某种“中介”的作用。“代理服务器”的类型有很多，干的事情各不相同。 （“代理服务器”的简单示意图） 代理客户端（proxy client） 早期的代理服务器，【不】需要“代理客户端”。因为早期的“代理服务器”支持的是【标准协议】。比如“HTTP proxy server”支持的是标准 HTTP协议，而用户的电脑上，已经有浏览器（原生支持 HTTP 协议）。这种情况下，自然不需要再有“代理客户端”。 后来，为了满足某些特殊需求（比如翻墙），“代理服务器”必须使用某种特殊的（非标准的）协议。因此，就必须在用户的环境中安装“代理客户端”。对于翻墙来说，你装的翻墙软件，相当于“代理客户端”。 　代理的层次 “代理”也分不同的层次。比较常见的有如下几种： TCP 代理（TCP 端口转发）——4层（传输层） SOCKS 代理——5层（会话层） HTTP 代理——7层（应用层） …… ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:15:2","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇网关（gateway） 　前面的某些章节，已经稍微提及了“网关”这个概念，但还没有具体介绍它。 严格来讲，“网关”是一个逻辑概念，【不要】把它当成具体的网络设备。充当“网关”的东东，可能是：路由器 or XX层交换机 or XX层防火墙 or 代理服务器 …… “网关”也分不同的层次。如果不加定语，通常指的是“3层网关”（网络层网关）。列几种比较常见的，供参考： 路由器充当网关——3层（网络层） 3层交换机充当网关——3层（网络层） 4层交换机充当网关——4层（传输层） 应用层防火墙充当网关——7层（应用层） 代理服务器充当网关——（取决于代理的层次，参见前一个小节） …… ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:15:3","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇隧道协议（tunneling protocol） 　所谓的“隧道协议”，通俗地说就是：用某种协议包裹另一种协议，以满足某些特殊的需求。 看到这里，估计某些同学会感到纳闷——因为俺在本文开头介绍“协议栈”的时候提到说：相邻的两层协议，下层会包裹上层。“隧道协议的包裹”与“上下层协议的包裹”，差别在哪捏？ 俺来解释一下： “隧道协议”可以做到更灵活的包裹——既可以对层次相隔很远的协议进行包裹，也可以对同一层的协议进行包裹，甚至可以“倒挂”——所谓的“倒挂”就是让【上】层反过来包裹【下】层。 举例： 俺曾经写过一篇《如何让【不支持】代理的网络软件，通过代理进行联网（不同平台的 N 种方法）》，其中介绍了“HTTP 代理”的两种模式：“转发模式 ＆ 隧道模式”。对于“HTTP 代理”的隧道模式，可以实现【TCP over HTTP】（把 TCP 协议打包到 HTTP 协议内部），这就是刚才所说的“倒挂”。 另外，VPN 小节的那张图中，有些类型的 VPN 就是用“隧道协议”的机制实现。 “计算机网络” ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:15:4","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"★本文的目标读者 　今天这篇的标题是“扫盲”，也就是说：即使那些完全不懂 IT 领域，也不懂通讯领域的读者，依然能看懂（至少能看懂一部分）。为了做到这点，俺会尽量使用通俗的比喻，并适当加一些示意图。 另外，就算你已经比较了解网络通讯领域，本文中提到的某些部分，也可能是你所不知道的。也就是说：懂行的同学，看看此文，也会有帮助。 本文的标题特地强调了【系统性】——俺希望这篇教程能帮助读者对“计算机网络”这个领域进行系统性学习（何为“系统性学习”？请看这篇教程） 为了做到【系统性】这个目的，这篇教程很长。俺开博12年，这篇的长度估计能排到前5名。建议大伙儿慢慢看，不要着急。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:16:0","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"★基本概念 　为了足够通俗，俺先要介绍一些基本概念。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:17:0","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇信道（channel） 　这是通讯领域非常基本的概念，肯定要先聊聊它。 通俗地说，信道就是“传送信息的通道”。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:17:1","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇信道的类型 　首先，信道可以从广义上分为“物理信道 ＆ 逻辑信道”。 顾名思义，“物理信道”就是直接使用某种【物理介质】来传送信息；至于“逻辑信道”——是基于“物理信道”之上抽象出来的玩意儿（待会儿讲到“协议栈”的时候再聊）。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:17:2","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇信道的带宽 　“带宽”指的是：某个信道在单位时间内最大能传输多少比特的信息。 请注意： 电气领域 ＆ 计算机领域都有“带宽”这个概念，但两者的定义不太一样。电气领域所说的“带宽”指的是“模拟带宽”，单位是“赫兹/Hz”；计算机领域所说的“带宽”指“数字带宽”，单位是“比特率”或“字节率”。 后续章节提到“带宽”，都是指计算机领域的术语。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:17:3","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇带宽的单位——容易把外行绕晕 　“比特率”或“字节率”很容易搞混淆。用英文表示的话——大写字母 B 表示【字节】；小写字母 b 表示【比特】。 　由于带宽的数字通常很大，要引入“K、M、G”之类的字母表示数量级，于是又引出一个很扯蛋的差异——“10进制”与“2进制”的差异。 【10进制】的 K 表示 1000；M 表示 1000x1000（1百万） 【2进制】的 K 表示 1024（2的10次方）；M 表示 1024x1024（2的20次方） 为了避免扯皮，后来国际上约定了一个规矩：对【2进制】的数量级要加一个小写字母 i。比如说：Ki 表示 1024；Mi 表示 1024x1024 …… 以此类推。 举例： 1Kbps 表示“1000比特每秒” 1KiBps 表示“1024字节每秒” ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:17:4","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇信道的工作模式：单工 VS 半双工 VS 全双工 　再来说说信道的工作模式。大致可以分为如下三种。为了让大伙儿比较好理解，俺对每一种都举相应的例子。 　单工（simplex） 比如“电台广播”就是典型的【单工】。“电台”可以发信号给“收音机”，但“收音机”【不能】发信号给“电台”。 　半双工（half-duplex） 比如“单条铁路轨道”，就是典型的【半双工】。火车在单条铁轨上，可以有两种运行方向；但对于同一个瞬间，只能选其中一个方向（否则就撞车了）。 　全双工（full-duplex） 比如“光纤”就是典型的【全双工】。在同一根光导纤维中，可以有多个光束【同时相向】传播，互相不会干扰对方。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:17:5","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇端点 　为了叙述方便，俺把参与通讯的对象（主体）称作“通讯端点”，简称“端点”。 这里的“端点”是广义的，可以是硬件（比如某个网卡），也可以是软件（比如某个应用程序）。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:17:6","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇单播、组播/多播、广播、选播 　对于“网络通讯”，至少得有 N 个端点参与，并且【N ≥ 2】才有意义。 当 N 个端点构成一个网络，这时候就会涉及到“单播、组播、广播”这几个概念。 通俗地说： 单播（unicast）——发送给网络中的指定的【单个】端点 组播/多播（multicast）——发送给网络中的指定的【多个】端点 广播（broadcast）——发送给网络中的【所有】端点 选播（anycast）——发送给网络中随机选择的【单个】端点 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:17:7","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇通讯协议（protocol） 　所谓的“通讯协议”就是：参与通讯的各方所采用的某种【约定】。只有大家都遵守这个约定，才有可能相互传递信息。 打个比方：如果两个人要用自然语言交流，前提是：双方使用相同（或相互兼容）的自然语言。 “通讯协议”就类似某种自然语言，参与通讯的多个端点，都必须能理解这个语言。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:17:8","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"★从“分层”到“参考模型” ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:18:0","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇分层 　在聊“分层”之前，先说说“分工”。比如在一个公司中，通常设有不同的工种/岗位，这就【分工】。 对于网络通讯也是如此，不太可能用一种通讯协议完成所有的信息传递任务（注：对于特别简单的网络，或许有可能只用单一协议；但如今的网络通讯已经很复杂，用【单个】通讯协议包办所有事情，已经不太可能） 一旦采用了多种通讯协议，这几种协议之间，该如何配合捏？ 在网络通讯领域，采用的是【分层】的设计思路。多个层次的协议在一起协同工作，技术上称作“协议栈”（洋文叫做“protocol stack”）。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:18:1","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇协议栈的原理 　对于多层次的协议栈。每个层次都有各自的“端点”（进行通讯的主体）。处于【同一层次】的两个端点会使用该层次的协议进行通讯（注：同一个层次的协议，可能只有一个，也可能有多个）。 除了最顶层，每个层次的端点会向其【直接】上层提供“服务”；除了最底层，每个层次的端点会调用【直接】下层提供的“服务”（这里所说的“服务”指某种“编程接口”，技术行话叫 API）。 （“协议栈”的示意图） （“服务”与“协议”之间的关系） ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:18:2","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇逻辑信道 　（前一个小节说了）每个层次会向上一个层次提供服务（API 调用）。对上层而言，调用下层提供的 API 发送信息，其效果相当于在使用某种【信道】进行通讯，这也就是俺在 ★基本概念 那个章节所说的“逻辑信道”。 （“逻辑信道”示意图） ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:18:3","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇数据格式的原理 　大部分协议会把要传送的数据切割为 N 份，每一份就是一个数据包。 通常来说，数据包的格式有如下三部分： 头部 身体（也称作“有效载荷”） 尾部（注：很多协议没有尾部） 　如果你收过快递，可以把“网络数据包”与“快递包裹”作一个对照—— 数据包的“头/尾”，就类似于快递包裹的【包装袋】。数据包的“身体”，就类似于快递包裹里面的东西。 　对于【相邻】两层的协议，【下】层包含【上】层。也就是说：下层协议的【载荷】就是上层协议的【整体】。 还是以快递举例： 假设你从网上买了一台笔记本电脑。电脑出厂时，电脑厂商肯定会提供一个包装盒。快递公司在寄送这台笔记本的时候，又会在笔记本的盒子外面再加一个包装袋。对应到网络协议——“快递公司的包装袋”相当于【下层】协议；“电脑厂商的包装盒”，相当于【上层】协议。 （上下层协议的格式及包含关系） ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:18:4","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇网络分层的参考模型 　上述所说的“分层 ＆ 协议栈”只是一个抽象的（笼统的）思路。具体要分几层？每一层要干啥事儿？这些都是很有讲究滴！网络技术发展了几十年，已经有很多牛人提出了各种不同的划分方案，称之为“网络分层的参考模型”（为了打字省力，以下简称“模型”）。 在各种模型中，名气最大的当然是“OSI 模型”（洋文称作“OSI model”）。在后续的章节中，俺会以这个模型为主体，进行介绍。 除了“OSI 模型”还有一个很出名的模型是“TCP/IP 模型”（因为互联网很成功，它才跟着出名）。 对“TCP/IP 模型”的分层，不同的文章或书籍，说法不太一样（“3层、4层、5层”皆有），这就引发了一些争议。包括几位热心读者也在博客留言，表达不同意见。为了避免一家之言，贴出维基百科的“这个链接”，其中给出了几种比较有名的说法。 另外，俺想提醒一下： 由于本文是基于【OSI 模型】进行展开。对于 TCP/IP 模型到底算几层，这方面的争论【不】影响本文后续的内容。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:18:5","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"★OSI 概述 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:19:0","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇OSI 的历史 　“OSI”的全称是“Open System Interconnection”。先说说它的历史。 上世纪70年代，“国际电信联盟”（ITU）想对各国的电信系统（电话/电报）建立标准化的规格；与此同时，“国际标准化组织”（ISO）想要建立某种统一的标准，使得不同公司制造的大型主机可以相互联网。 后来，这两个国际组织意识到：“电信系统互联”与“电脑主机互联”的性质差不多。于是 ISO 与 ITU 就决定合作，两家一起干。这2个组织的2套班子，从上世纪70年代开始搞，搞来搞去，搞了很多年，一直到1984年才终于正式发布 OSI 标准。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:19:1","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇OSI 标准的两个组成部分 　严格来讲，OSI 包括两大部分—— 其一，抽象的概念模型，也就是前面提到的【OSI model】； 其二，针对这个概念模型的具体实现（具体的通讯协议），洋文叫做【OSI protocols】。 　（前面说了）OSI 是由 ISO ＆ ITU 联手搞出来滴。这两个国际组织里面的人，要么是来自各国的电信部门，要么是来自各国的高校学者。总而言之，既有严重的官僚风气，又有明显的学究风气。（正是因为这两种风气叠加，所以搞了很多年，才搞出 OSI） OSI 的协议实现（OSI protocols），不客气地说，就是一堆垃圾——据说把 OSI protocols 所有的协议文档，全部打印成 A4 纸，摞起来得有一米多高！是不是很吓人？协议搞得如此复杂，严重违背了 IT 设计领域的 KISS 原则。 由于 OSI protocols 实在太复杂，后来基本没人用。但 OSI model 反而广为流传，并且成为“网络分层模型”中名气最大，影响力最广的一个。 因此，本文后续章节中，凡是提到 OSI，指的是【OSI model】。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:19:2","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇OSI 模型的7层 　OSI 模型总共分7层，示意图参见如下表格： 层次中文名洋文名 第7层应用层Application Layer 第6层表示层Presentation Layer 第5层会话层Session Layer 第4层传输层Transport Layer 第3层网络层Network Layer 第2层数据链路层Data Link Layer 第1层物理层Physical Layer （注：为了打字省力，在后续章节把“数据链路层”直接称为“链路层”） 考虑到本文是针对一般性读者的【扫盲教程】，俺重点聊第1~4层。搞明白这几个层次之后，有助于你更好地理解网络的很多概念，也有助于你更好地理解很多信息安全的概念。 网上已经有很多关于 OSI 的文章，可惜大部分写得粗糙——很多文章只是在照抄定义。 俺曾经写过一篇《学习技术的三部曲：WHAT、HOW、WHY》，其中提到【理解技术】的不同层次。要想更好地理解 OSI 模型，你得搞明白：为啥需要引入某某层？（请注意：这是一个 WHY 型的问题） 接下来在讨论 OSI 的每个层次时，俺都会专门写一个小节，谈该层次的【必要性】。搞明白【必要性】，你就知道为啥要引入这个层次。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:19:3","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"★物理层：概述 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:20:0","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇物理层的必要性 　通俗地说：直接与物理介质打交道的层次，就是物理层。这一层的必要性比较明显。 因为所有的通讯，归根结底都要依赖于【物理介质】。与物理介质打交道，需要牵涉到很多与【物理学】相关的东东。比如：“无线电通讯”需要关心“频率/波长”；电缆通讯需要跟“电压”打交道；“光纤通讯”需要关心“玻璃的折射率＆光线的入射角” …… “物理层”的主要职责是：屏蔽这些细节，使得“物理层”之上的层次不用再去操心物理学。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:20:1","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇物理信道的类型 　何为“物理信道”，在本文开篇的“基本概念”已经提到了。 对于“物理信道”，还可以进一步细分为如下三大类： 1. 有线信道（比如：双绞线、同轴电缆、光纤、等等） 2. 无线信道（比如：微波通讯、电台广播、卫星通讯、等等） 3. 存储信道 　“存储信道”比较少见，很多人没听说过，稍微解释一下。 假设你要把一大坨信息传送给另一个人，除了用“有线 or 无线”这两种通讯方式，还可以把信息先保存到某种【存储介质】（比如硬盘），然后再把存储介质用某种方式（比如快递）转交给对方。这就是所谓的“存储信道”。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:20:2","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇信噪比（Signal-to-noise ratio） 　俺在很多篇关于“学习＆心理学”的博文中提到过【信噪比】这个概念。其实这个概念是从通讯领域借用的术语。 对于“物理信道”，总是会存在某些环境干扰，称之为“噪声”（Noise）。“信道传输的有用信息”与“无用的干扰噪声”，这两者的比值就是“信噪比”。 “信噪比”单位是【分贝】。“分贝”洋文叫做“decibel”（简写为 dB）。“deci”表示“十进制”；“bel”是为了纪念大名鼎鼎的贝尔（电话它爹）。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:20:3","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇带宽的限制因素 　“物理信道”要依赖于物理传输介质。不管使用何种物理介质，都要受限于某些基本的物理学定律（比如“光速上限”）。另外，不管何种物理介质，总是会有或多或少的环境干扰（噪声）。这两个因素导致了：任何“物理信道”的最大传输率总是有限滴。 由于物理层是最底下的一层，物理层之上的其它层次总是要直接或间接地依赖【物理信道】。因此，其它层次建立的“逻辑信道”，其带宽只会比“物理信道”的最大带宽更小。换句话说：“物理信道”的带宽上限也就是整个协议栈的带宽上限。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:20:4","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇多路复用（Multiplexing） 　一般来说，凡是能实现【长距离】通讯的“物理信道”，都有相当的经济成本。比如铺设“光纤、同轴电缆”都要花钱。无线电通讯虽然免去了铺设线路的成本，但需要竞标购买频段。因此，物理信道非常强调“多路复用”。 所谓的“多路复用”，通俗地说就是：尽可能地共享物理信道，不要浪费了。 “多路复用”有很多种类型；不同的类型，原理也不同。为了展示各种不同的原理，俺拿【无线通信】来说事儿。 无线通信领域的“多路复用”，【至少】有如下几种： 　频分多路复用/FDM（Frequency-Division Multiplexing） 这个最简单，就是根据频率拆分。不同的线路占用不同的频段，互不干扰。（电台广播用的就是这个思路） 但这个思路的缺点很明显—— 其一，要依赖足够宽的频段（频段是稀缺资源）； 其二，不同线路的流量可能会动态变化。如果某个线路空闲，其占用的频段就浪费了。 （注：光纤通讯中有个“波分多路复用/WDM”，本质上就是 FDM） 　时分多路复用/TDM（Time-Division Multiplexing） 这种思路只用一个很窄的频段。为了在同一个频道发送多个信道，采用【分时机制】，把时间切割成很小的时间片，每个线路占用一个时间片。周而往复。 这个思路有点像十字路口的红绿灯——每隔一段时间，其中一条路可以通行。 这个思路的优点是：可以只使用一个很窄的频段。缺点是：线路越多，每条线路等待越久；即使某个线路空闲，依然会占用时间片（浪费了资源）。 　码分多路复用/CDM（Code-Division Multiplexing） 这种思路采用某种【编码】的技巧，使得多个端点可以在同一个时间点使用同一频段发送数据；由于他们采用不同的编码方式，不会相互干扰。 一般来说，CDM 要依赖于“扩频技术”（spread spectrum），需占用一个比较宽的频道范围。这算是缺点。但其优点很明显—— 其一，可以支持 N 个线路（N 动态变化）； 其二，即使任何一个线路的流量动态变化，也不会浪费物理信道的资源。 显然，这种思路明显优于 FDM ＆ TDM。如今在移动通讯领域大名鼎鼎的 CDMA（码分多址），采用的就是这个思路。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:20:5","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"★物理层：具体实例 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:21:0","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇物理层的【协议】 　物理层的协议主要有如下： USB 协议 蓝牙协议的一部分 IEEE 802.11 的一部分（Wi-Fi） IEEE 802.16（WiMAX） IEEE 1394（火线接口） RS-232 协议（串行接口/串口） …… （考虑到篇幅）俺不可能具体细聊这些协议，只是贴出每个的维基百科链接，感兴趣的同学自己点进去看。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:21:1","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇物理层的【协议实现】 　对于电脑主机（含移动设备），“网卡硬件”包含了物理层的协议实现（参见如下示意图） 另外，还有一些专门的【1层】网络设备，也提供物理层的功能（参见下一个小节）。 （OSI 模型中，不同层次的协议实现） ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:21:2","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇物理层相关的【网络设备】 调制解调器（modem） 通俗地说，“调制解调器”就是用来翻译“数字信号 ＆ 模拟信号”。 在发送信息时，modem 把电脑要发送的“字节流”（数字信号）翻译成“模拟信号”，然后通过物理介质发送出去；当它从物理介质收到“模拟信号”，再翻译成“数字信号”，传回给电脑。 早期的拨号上网，modem 面对的物理介质是“固话线路”；如今家庭宽带普及，光纤入户，modem 面对的物理介质是“光纤线路”。 （老式 modem，用于固定电话线路） 中继器（repeater） 信号在物理介质中传输，会出现【衰减】（不论是“有线 or 无线”都有可能衰减）。“中继器”的作用是【信号增益】，使得信号能传得更远。 另外，比如“微波通讯”是直线传播，而地球表面有弧度，还有地形的起伏。所以每隔一定距离要建“微波塔”。这玩意儿也相当于“中继器”。 （微波塔示意图） 集线器（hub） 可以把“集线器”视作更牛逼的“中继器”——“中继器”只有两个口（只能连接两个通讯端点），而“集线器”有多个口（同时连接多个通讯端点）。 通常所说的“集线器”是指“以太网集线器”。这种设备如今已经逐步淘汰，很少见到了。 （老式的10兆以太网集线器） 另外，很多同学应该都用过“USB hub”，就是针对 USB 线的“集线器”（“USB 线”也可以视作某种通讯介质）。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:21:3","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"★链路层：概述 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:22:0","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇链路层的必要性 对信息的打包 物理层传输的信息，通俗地说就是【比特流】（也就是一长串比特）。但是对于计算机来说，“比特流”太低级啦，处理起来极不方便。“链路层”要干的第一个事情，就是把“比特流”打包成更大的一坨，以方便更上层的协议进行处理。在 OSI 模型中，链路层的一坨，称之为“帧”（frame）。 　差错控制 物理介质的传输，可能受到环境的影响。这种影响不仅仅体现为“噪声”，有时候会出现严重的干扰，导致物理层传输的“比特流”出错（某个比特“从0变1”或“从1变0”）。因此，链路层还需要负责检查物理层的传输是否出错。在 IT 行话中，检测是否出错，称之为“差错控制机制”（后面有一个小节会简单说一下这个话题）。 　流量控制 假设两个端点通过同一个物理信道进行通讯，这两个端点处理信息的速度可能不同。如果发送方输出信息的速度超过接收方处理信息的速度，通讯就会出问题。于是就需要有某种机制来协调，确保发送方的发送速度不会超出接收方的处理速度。在技术行话中，这称之为“流量控制”，简称“流控”。 　信道复用 在上一个章节已经讲到：用于远距离通讯的“物理介质”，总是有成本。因此需要对物理信道进行“多路复用”，就会导致多个端点共用同一个物理信道。如果同时存在多个发送者和多个接收者。接收者如何知道某个信息是发给自己而不是别人？ 另外，某些物理介质可能不支持并发（无法同时发送信息）。某些物理介质可能是【半双工】，所有这些物理层的限制，都使得“多路复用”变得复杂。为了解决这些问题，链路层需要提供了某种相应的机制（协议），术语叫做“介质访问控制”（洋文是“Media Access Control”，简称 MAC）。后续小节会聊它。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:22:1","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇差错控制 　为了发现传输的信息是否出错，设计了很多相应的数学算法。这些算法大体分为两类：“检错算法 ＆ 纠错算法”。 简而言之，“检错算法”只能检测出错误，而“纠错算法”不但能检测出错误，还能纠正错误。很显然，“纠错算法”更牛逼，但是它也更复杂。 常见的“检错算法”对传输的数据计算出一个【校验值】，接收方收到数据会重新计算校验和，如果算出来不对，就把收到的数据丢弃，让对方重发。“校验算法”的原理类似于《扫盲文件完整性校验——关于散列值和数字签名》一文中提到的“散列算法/哈希算法”。 “纠错算法”更高级，由于涉及到更多数学，俺就不展开啦。 对于【无线】物理信道，由于出错的概率更高，并且重新传输数据的成本也更高。所以【无线】通讯的链路层协议，更倾向于用【纠错】机制；作为对比，【有线】通讯的链路层协议，更倾向于用【检错】机制。 　“MAC 协议”用来确保对下层物理介质的使用，不会出现冲突。为了形象，俺拿“铁路系统”来比喻，说明“MAC 协议”的用途。 假设有一条【单轨】铁路连接 A/B 两地。有很多火车想从 A 开到 B，同时还有很多火车想从 B 开到 A。 首先，要确保不发生撞车（如果已经有车在 A 开往 B 的途中，那么 B 就不能再发车）；其次，即使是同一个方向的车，出发时间也要错开一个时间间隔。 所有这些协调工作，都是靠“MAC 协议”来搞定。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:22:2","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇MAC 地址 　为了完成上述任务，光有“MAC 协议”还不够，还需要为每一个端点引入【惟一的】标识。这个标识就称作“MAC 地址”。 通俗地说，每个网卡都内置了一个“MAC 地址”。这个地址是网卡在出厂的时候就已经设置好的，并且用某种机制确保该地址【全球唯一】。 　如何保证 MAC 地址全球唯一捏？简单说一下： MAC 地址包含6个字节（48个比特），分为两半。第一部分称作【OUI】，OUI 的24个比特中，其中2个比特有特殊含义，其它22个比特，用来作为网卡厂商的唯一编号。这个编号由国际组织 IEEE 统一分配。 MAC 地址第二部分的24比特，由网卡厂商自己决定如何分配。每个厂商只要确保自己生产的网卡，后面这24比特是唯一的，就行啦。 （MAC 地址的构成） 由于俺在很多安全教程中鼓吹大伙儿使用“操作系统虚拟机”，再顺便说说【虚拟网卡】的 MAC 地址。 “虚拟网卡”是由【虚拟化软件】创建滴。IEEE 也给每个虚拟化软件的厂商（含开源社区）分配了唯一的 OUI。因此，虚拟化软件在创建“虚拟网卡”时，会使用自己的 OUI 生成前面24个比特；后面的24比特，会采用某种算法使之尽可能【随机化】。由于“2的24次方”很大（224 = 16777216），碰巧一样的概率很低。 （注：如果手工修改 MAC 地址，故意把两块网卡的 MAC 地址搞成一样，那确实就做不到唯一性了。并且会导致链路层的通讯出问题） ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:22:3","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"★链路层：具体实例 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:23:0","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇链路层的【协议】 　链路层的协议主要有如下： MAC 协议（介质访问控制） LLC 协议（逻辑链路控制） ARP 协议（解析 MAC 地址） IEEE 802.3（以太网） IEEE 802.11 的一部分（Wi-Fi） L2TP 协议（2层VPN） PPP 协议（拨号上网） SLIP 协议（拨号上网） …… （考虑到篇幅）俺不可能具体细聊这些协议，只是贴出每个的维基百科链接，感兴趣的同学自己点进去看。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:23:1","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇链路层的【协议实现】 　对于电脑主机（含移动设备），“网卡硬件 ＆ 网卡驱动”会包含链路层协议的实现（参见如下示意图）。 另外，还有一些专门的【2层】网络设备，也提供链路层的功能（参见下一个小节）。 （OSI 模型中，不同层次的协议实现） ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:23:2","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇链路层相关的【网络设备】 网络交换机（network switch） （注：一般提到“网络交换机”，如果不加定语，指的就是“2层交换机”；此外还有更高层的交换机，在后续章节介绍） 为啥要有交换机捏？俺拿“以太网的发展史”来说事儿。 以太网刚诞生的时候，称之为“经典以太网”，电脑是通过【集线器】相连。“集线器”前面提到过，工作在【1层】（物理层），并不理解链路层的协议。因此，集线器的原理是【广播】模式——它从某个网线接口收到的数据，会复制 N 份，发送到其它【每个】网线接口。假设有4台电脑（A、B、C、D）都连在集线器上，A 发数据给 B，其实 C ＆ D 也都收到 A 发出的数据。显然，这种工作模式很傻逼（低效）。由于“经典以太网”的工作模式才“10兆”，所以集线器虽然低效，还能忍受。 后来要发展“百兆以太网”，再用这种傻逼的广播模式，就不能忍啦。于是“经典以太网”就发展为“交换式以太网”。用【交换机】代替“集线器”。 交换机是工作在2层（链路层）的设备，能够理解链路层协议。当交换机从某个网线接口收到一份数据（链路层的“帧”），它可以识别出“链路帧”里面包含的目标地址（接收方的 MAC 地址），然后只把这份数据转发给“目标 MAC 地址相关的网线接口”。 由于交换机能识别2层协议，它不光比集线器的性能高，而且功能也强得多。比如（稍微高级点的）交换机可以实现“MAC 地址过滤、VLAN、QoS”等多种额外功能。 　网桥/桥接器（network bridge） “交换机”通常用来连接【同一种】网络的设备。有时候，需要让两台不同网络类型的电脑相连，就会用到【网桥】。 下面以“操作系统虚拟机”来举例（完全没用过虚拟机的同学，请跳过这个举例）。 在这篇博文，俺介绍了虚拟机的几种“网卡模式”，其中有一种模式叫做【bridge 模式】。一旦设置了这种模式，Guest OS 的虚拟网卡，对于 Host OS 所在的外部网络，是【双向】可见滴。也就是说，物理主机所在的外部网络，也可以看见这块虚拟网卡。 现在，假设你的物理电脑（Host OS）只安装了【无线网卡】（WiFi），而虚拟化软件给 Guest OS 配置的通常是【以太网卡】。显然，这是两种【不同】的网络。为啥 Guest OS 的以太网卡设置为“bridge 模式”之后，外部 WiFi 网络可以看到它捏？ 奥妙在于——虚拟化软件在内部悄悄地帮你实现了一个“网桥”。这个网桥把“Host OS 的 WiFi 网卡”与“Guest OS 的以太网卡”关联起来。WiFi 网卡收到了链路层数据之后，如果接收方的 MAC 地址对应的是 Guest OS，网桥会把这份数据丢给 Guest OS 的网卡。 这种网卡模式之所以称作“bridge 模式”，原因就在于此。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:23:3","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇链路层相关的【软件工具】 嗅探抓包工具（Sniffer） 要了解链路层的数据包结构，需要用到“嗅探工具”。这类工具能捕获流经你网卡的所有【链路层】数据包。前面聊“协议栈”的时候说过：下层数据包的载荷就是上层数据包的整体。因此，拿到【链路层】数据包也就意味着：你已经拿到2层之上的所有数据包的信息了。 有些抓包工具自带图形界面，可以直接显示数据包的内容给你看。还有些只提供命令行（只是把获取的数据包保存为文件），然后要搭配其它图形化的工具来展示数据包的内容。 抓包的工具有很多，名气最大的是 Wireshark（原先叫做 Ethereal）。 　ARP 命令 首先，ARP 是“MAC 地址解析协议”的洋文名称。该协议根据“IP 地址”解析“MAC 地址”。 Windows 自带一个同名的 arp 命令，可以用来诊断与“MAC 地址”相关的信息。比如：列出当前子网中其它主机的 IP 地址以及对应的 MAC 地址。这个命令在 Linux ＆ Mac OS 上也有。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:23:4","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"★网络层：概述 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:24:0","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇网络层的必要性 路由机制（routing） 在 OSI 模型中，链路层本身【不】提供路由功能。你可以通俗地理解为：链路层只处理【直接相连】的两个端点（注：这么说不完全严密，只是帮助外行理解） 对于某个复杂网络，可能有很多端点，有很复杂的拓扑结构。当拓扑足够复杂，总有一些端点之间【没有直连】。那么，如何在这些【没有直连】的端点之间建立通讯捏？此时就需要提供某种机制，让其它端点帮忙转发数据。这就需要引入“路由机制”。 为了避免把“链路层”搞得太复杂，路由机制放到“链路层”之上来实现，也就是“网络层”。 　基于【路由】的地址编码方式 链路层已经提供了某种全球唯一的地址编码方式（MAC 地址）。但“MAC 地址”有如下几个问题： 其一，它是固定的（虽然可以用技术手段去修改 MAC 地址，但很少这么干） 其二，MAC 地址的编码是基于【厂商】，无法体现网络拓扑结构。或者说，“MAC 地址”对于“路由机制”是不够友好滴。 因此，需要引入一种更抽象（更高层）的地址，也就是“网络层地址”。咱们常说的“IP 地址”，是“网络层地址”的实现方式之一。 　为了帮你理解，举个例子： 每个人都有身份证号（这就类似于“MAC 地址”）。当某人加入了某个公司，公司会为此人再分配一个“员工号”（这就类似于“网络地址”）。既然有身份证号，为啥公司还要另搞一套“员工编号”捏？因为“员工编号”有额外的好处。比如说：可以把员工号划分为不同的区间，对应不同的部门。这样一来，只要看到员工号，就知道此人来自哪个部门。 类似道理，每个网卡都有自己固定的 MAC 地址，当这个网卡接入到不同的网络，每次都可以再分配不同的“网络地址”。通过“网络地址”可以看出这个网卡属于哪个网络（对路由比较方便）。 　网际互联（internetwork） 引入“网络层”的另一个目的是：屏蔽不同类型的网络之间的差异，从而有利于【网际互联】（也就是建立“网络的网络”）。 一般来说，要想联通【异种】网络，就要求每个网络中都有一台主机充当【网关】（gateway）。【网关】起到“中介/翻译”的作用——帮不同的网络翻译协议，使得不同的网络可以互相联通。 假设【没有】统一的网络层，网关的工作就很难做。就好比说：如果全球没有某种通用的自然语言，就需要培养非常多不同类型的翻译人才（假设有30种主要语言，任意两种互译，就需要几百种不同的翻译人才）。 反之，如果有了某种统一的网络层标准，问题就好办多了（还是假设有30种主要语言，只要选定某种作为通用语，然后培养29种翻译人才，就可以实现任意两种语言互译）。 如今的互联网时代，【IP 协议】就是那个充当统一标准的网络层协议。 （互联网整合了各种类型的网络） ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:24:1","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇网络拓扑（network topology） 　网络的拓扑结构有很多种，有简单的，有复杂的。一般来说，再复杂的拓扑，也可以逐步分解为若干简单拓扑的组合。 对拓扑的研究，有专门一个数学分支（拓扑学）。考虑到本文只是扫盲，俺不可能再去聊“拓扑学”。因此，只挑几种简单的拓扑结构，让大伙儿有个直观的印象。 （常见的网状拓扑结构：星形拓扑、环形拓扑、总线拓扑、网状拓扑、等等） 如今的互联网，整体的拓扑结构超级复杂。但还是可以逐步分解为上述几种基本的拓扑结构。 （互联网的复杂拓扑，右下角是图中某个小点的放大。 为节省大伙儿的翻墙流量，俺贴的是缩小图。点“这里”看原始图） ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:24:2","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇互联网的拓扑——从“历史”的角度看其健壮性 　从上面那张图可以看出：互联网拓扑的【局部】有很多是“星形拓扑”（当然也有其它的）。但从【宏观】上看，更像是“网状拓扑”。 在现实生活中，对于复杂结构，通常都会采用“树状层次结构”，以便于管理。比如：域名系统、公司组织结构、官僚系统 …… 那为啥互联网的【宏观】拓扑结构是“网状”捏？这就要说到互联网的历史。 　在上世纪50年代（冷战高峰期），美国军方的指挥系统高度依赖于电信公司提供的电话网络。当时的电话网络大致如下—— 在基层，每个地区有电话交换局，每一部电话都连入当地的交换局。 在全国，设有若干个长途局，每个交换局都接入某个特定的长途局（不同地区的交换局通过长途局中转）。 简而言之，当时美国的电话网络是典型的【多级星形拓扑】。这种拓扑的优点是：简单、高效、便于管理；但缺点是：健壮性很差。从这个案例中，大伙儿可以再次体会到“效率”与“健壮性”之间的矛盾。俺写过一篇很重要的博文（这里）深入讨论了这个话题。 话说1957年的时候，苏联成功试射第一颗洲际弹道导弹（ICBM），美国军方开始担心：一旦苏联先用洲际导弹攻击美国，只要把少数几个长途局轰掉，军方的指挥系统就会瘫痪。也就是说，“长途局”已经成为美国军方的【单点故障】（何为“单点故障”？参见这篇博文）。 1960年，美国国防部找来大名鼎鼎的兰德公司进行咨询，要求提供一个应对核打击的方案。该公司的研究员 Paul Baran 设计了一个方案，把“星形拓扑”改为【网状拓扑】。采用【网状拓扑】的好处在于：即使发生全面核大战，大量骨干节点被摧毁，整个网络也不会被分隔成几个孤岛，军方的指挥系统依然能正常运作。 （左边：互联网诞生前——美国的电话网络　右边：兰德公司的“Baran 方案”） 有了兰德公司的方案，美国军方找到当时最大的电信公司 AT＆T，想要实现这个系统，结果被否决了。AT＆T 高层认为：搞这样一种系统根本不切实际。于是 Baran 的方案中途夭折。 为啥 AT＆T 反对这个方案捏？一方面，成功的大公司总是有很强的思维定势（关于这点，参见这篇文章）；另一方面，Baran 的设计方案确实很超前——其前瞻性不仅包括“拓扑结构”，而且把当时电信行业的几大核心观念完全颠覆掉了（具体如何颠覆，后续章节还会再聊）。 时间一晃又过了好多年，到了60年代末，由于一系列机缘巧合，英国佬发现了“Baran 方案”的价值，并据此搞了一个小型的 NPL 网络（NPL 是“国家物理实验室”的缩写）。然后在某次 ACM 会议上，美国佬看到英国佬的论文，才意识到：Baran 方案完全可行。经历了“出口转内销”的命运之后，该方案重新被美国国防部重视。之后，（国防部下属的）“高级计划研究局”（ARPA）开始筹建“阿帕网”（ARPANET），才有了如今的互联网。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:24:3","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇路由的大致原理 　聊完“拓扑”，再来聊“路由”。 当主机 A 向主机 B 发送网络层的数据时，大致会经历如下步骤： A 主机的协议栈先判断“A B 两个地址”是否在同一个子网（“子网掩码”就是用来干这事儿滴）。 如果是同一个子网，直接发给对方；如果不是同一个子网，发给本子网的【默认网关】。 （此处所说的“网关”指“3层网关/网络层网关”） 对于“默认网关”，有可能自己就是路由器；也可能自己不是路由器，但与其它路由器相连。 也就是说，“默认网关”要么自己对数据包进行路由，要么丢给能进行路由的另一台设备。 （万一找不到能路由的设备，这个数据就被丢弃，于是网络通讯出错） 当数据到达某个路由器之后，有如下几种可能—— 3.1 该路由器正好是 B 所在子网的网关（与 B 直连），那就把数据包丢给 B，路由过程就结束啦； 3.2 亦或者，路由器会把数据包丢给另一个路由器（另一个路由器再丢给另一个路由器） …… 如此循环往复，最终到达目的地 B。 3.3 还存在一种可能性：始终找不到“主机 B”（有可能该主机“断线 or 关机 or 根本不存在”）。为了避免数据包长时间在网络上闲逛，还需要引入某种【数据包存活机制】（洋文叫做“Time To Live”，简称 TTL）。 通常会采用某个整数（TTL 计数）表示数据包能活多久。当主机 A 发出这个数据包的时候，这个“TTL 计数”就已经设置好了。每当这个数据包被路由器转发一次，“TTL 记数”就减一。当 TTL 变为零，这个数据包就死了（被丢弃）。 　对于某些大型的复杂网络（比如互联网），每个路由器可能与其它 N 个路由器相连（N 可能很大）。对于上述的 3.2 情形，它如何判断：该转发给谁捏？ 这时候，“路由算法”就体现出价值啦—— 一般来说，路由器内部会维护一张【路由表】。每当收到一个网络层的数据包，先取出数据包中的【目标地址】，然后去查这张路由表，看谁距离目标最近，就把数据包转发给谁。 上面这段话看起来好像很简单，其实路由算法挺复杂滴。考虑到本文是“扫盲性质”，而且篇幅已经很长，不可能再去聊“路由算法”的细节。对此感兴趣的同学，可以去看《计算机网络》的第5章。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:24:4","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇路由算法的演变史（以互联网为例） 　（技术菜鸟可以跳过这个小节） 由于互联网的 IP 协议已经成为“网络层协议”的事实标准，俺简单聊一下互联网的路由机制是如何进化滴。 　第1阶段：静态全局路由表 （前面说了）互联网的前身是“阿帕网/ARPANET”。在阿帕网诞生初期（上世纪70年代），全球的主机很少。因此，早期的路由表很简单，既是“全局”滴，又是“静态”滴。简而言之，每个路由器内部都维护一张“全局路由表”，这个“路由表”包含了全球所有其它路由器的关联信息。每当来了一个数据包，查一下这张全局路由表，自然就清楚要转发给谁，才能最快到达目的地。 早期的阿帕网，主机的变化比较少，也很少增加路由器。每当出现一个新的路由器，其它路由器的管理员就手工编辑各自的“全局路由表”。 为了加深大伙儿印象，特意找来两张70年代初的阿帕网拓扑图（注：图中的 IMP 是“Interface Message Processor”的缩写，也就是如今所说的“路由器”）。 （1973年的阿帕网） （1977年的阿帕网） 第2阶段：动态全局路由表 后来，“阿帕网/互联网”的规模猛增，路由器数量也跟着猛增，隔三差五都有新的路由器冒出来。再用“静态路由表”这种机制，（编辑路由表的）管理员会被活活累死。于是改用“动态路由表”，并引入某种“路由发现机制”。但“路由表”依然是【全局】滴。 　第3阶段：动态分级路由表 再到后来，全球的路由器越来越多，成千上万，再搞“全局路由表”已经不太现实了—— 一方面，“全局路由表”越来越大（查询的速度就越来越慢） 另一方面，由于互联网的流量越来越大，每来一个数据包都要查表，查询越来越频繁。 于是，路由器开始吃不消了。为了解决困境，想出一个新招数：引入“分级路由”（hierarchical routing）。所谓的“分级路由”就是：把整个互联网分为多个大区域，每个大区域内部再分小区域，小区域内部再分小小区域 …… 看到这里，熟悉“数据结构与算法”的同学就会意识到——这相当于构造了一个【树状】层次结构。 有了这个层次结构，每个路由器重点关注：自己所在的那个最小化区域里面的网络拓扑。如此一来，每个路由器的“路由表”都会大幅度减小。 （全局路由表 VS 分级路由表） ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:24:5","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇互联网的路由——从“CAS”的角度看其健壮性 　去年（2020）俺写了一篇博文《“政治体制”与“系统健壮性”——基于“复杂性科学”的思考》，其中介绍了“CAS”（复杂自适应系统）的概念。互联网的路由机制，就是一个典型的 CAS。 如果把互联网视作一个系统，每个公网上的路由器都是一个自适应的主体。假如某个地区的网络流量突然暴涨，骨干网路由器会自动分流；假如因为地震或战争，导致某个地区的骨干网路由器全部下线，周边地区的路由器也会自动避开这个区域 ….. 所有这些工作，【不需要】依靠任何最高指挥中枢，去进行协调。 相反，如果互联网的路由系统中，设立了某种“中央委员会”进行实时调度，那互联网早就完蛋了，根本无法成长为今天这种规模。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:24:6","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇网络层的两种交换技术——电路交换（circuit switching） VS 分组交换（packet switching） 　（技术菜鸟可以跳过这个小节） 前面聊“互联网诞生”，说到兰德公司的“Baran 方案”。该方案对当时的电信系统提出几大革命性的变化，其中之一就是“分组交换”技术（也称“数据包交换”or“封包交换”）。 一般来说，网络层的设计有两种截然不同的风格：【电路交换 VS 分组交换】。有时候也分别称之为“有连接的网络层 VS 无连接的网络层”。此处所说的“连接”指的是某种“虚电路”（洋文叫做“virtual circuit”，简称 VC）。 　要理解“虚电路”，首先要从老式的电话系统说起。 最早期的电话，既没有拨号盘也没有按键，全靠一张嘴。当你拿起电话，先告诉接线员你要打给谁，接线员会用一根跳接线，插入电话交换设备的某个插孔，从而把你的电话机与对方的电话机相连。于是建立了一条两人之间的电话通路，也就是“电路”。你可以把“接线员”想象成某种“人肉路由器” :) （1900年法国巴黎的电话交换局，可以看到接线员在操作电话交换设备） 后来发明了“自动电话交换机”，导致“接线员”全体下岗。虽然自动化了，但原理还是一样——当你在电话上拨了某人的号码，电话局的交换机会自动选择一条线路。只有当这条线路建立起来，对方的电话才会响。一旦双方开始通话，双方之间的语音都是通过这条线路传输。并且这条线路是独占的——只要通话不挂断，这条线路就不会再分配给其他人使用。 　前面提到“互联网诞生的历史”，当时军方推动的“Baran 方案”被 AT＆T 断然拒绝。因为这个方案完全颠覆了传统的电话系统—— 颠覆之1：把“模拟信号”颠覆为“数字信号”（这点比较好理解，俺就不解释了） 颠覆之2：把“星形拓扑”颠覆为“网状拓扑”（关于这点，前面的小节已经讨论了） 颠覆之3：把“电路交换”颠覆为“分组交换”（这就是本小节的重点） 　为了帮大伙儿理解上述第3点，举个例子： 假设主机 A 要向主机 B 发送一大坨数据。因为数据太多，肯定要分成好几坨小一点的（分成多个数据包）。如何把这些数据包发送给对方捏？ 　“电路交换”的实现方式 在发送数据之前，要先建立连接通道（通过路由算法，找出 A ＆ B 之间的某条通路）。这条通路就是所谓的“虚电路/VC”。一旦 VC 建立，每一个数据包都是从这条拓扑路径进行路由。 　“分组交换”的实现方式 在发送数据之前，【不需要】建立通道，让每个数据包独立进行路由。这种情况下，这几个数据包可能会走【不同的】拓扑路径。因此，数据包到达的顺序与发送的顺序【不一定】相同。接收方收到所有数据包之后，还要自己进行排序。 维基百科上有一个 GIF 动画（这个链接），比较直观地演示“分组交换/封包交换”的效果。由于这个动画稍微有点大（超过 1MB），俺就不贴到博文中了。 　当时的电话系统主要承载语音传输，“电路交换”显然性能更高。那为啥 Baran 的设计要采用“分组交换”捏？俺又要再次提到【效率 VS 健壮性】之间的矛盾与均衡。 对于“电路交换”，一旦建立连接，同一个连接的所有数据都走相同的路径（会经过完全相同的路由器）。也就是说，传输的过程中，如果某个路由器挂掉了（网络掉线 or 硬件当机 or 软件崩溃）。那么，该路由器正在处理的 N 个连接全都要报废。而“分组交换”则更加灵活——即使某个路由器挂掉了，后续的数据包会自动转向另外的路由器，损失很小。 “Baran 方案”之所以采用“分组交换”的设计，因为人家这个方案是提交给军方用来应对【全面核战争】滴，当然要考虑健壮性啦。 　话说这两种交换机制，各有很多支持者，并分裂为两大阵营，分别是：“电信阵营 VS 互联网阵营”。两大阵营的口水战持续了 N 年，都无法说服对方。到了后来设计 OSI 模型的时候，为了保持中立性与通用性，OSI 模型本身并没有强制要求网络层采用哪一种风格。 经过几十年之后，咱们已经可以看出来：“互联网阵营”占据主导地位。如今，连电信系统都是架构在互联网之上。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:24:7","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"★网络层：具体实例 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:25:0","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇网络层的【协议】 　网络层的协议有很多。由于“互联网”已经成为全球的事实标准，因此俺只列出属于“互联网协议族”的那些“网络层协议”： IP 协议（含 IPv4 ＆ IPv6） ICMP IGMP IPSec …… （考虑到篇幅）俺不可能具体细聊这些协议，只是贴出每个的维基百科链接，感兴趣的同学自己点进去看。 对上述这些协议，最重要的当然是 IP 协议。如果你想要深入了解 IP 协议，可以参考如下这本书。关于 IP 协议的书，此书的影响力最大。这本书共3卷，通常只需看第1卷。 《TCP-IP 详解》 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:25:1","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇网络层的【协议实现】 　对于电脑主机（含移动设备），网络层的协议实现通常包含在操作系统自带的网络模块中（也就是“操作系统协议栈”）。具体参见如下示意图。 另外，还有一些专门的【3层】网络设备，也提供网络层的功能（参见本章节的后续小节）。 （OSI 模型中，不同层次的协议实现） ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:25:2","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇IP 地址的格式及含义 　当年设计阿帕网的时候，采用了【4字节】（32比特）来表示“网络层地址”（也就是 IP 地址）。 “IP 地址”的含义很重要，俺有必要解释一下： 咱们平时所说的 IP 地址，采用【点分十进制】来表示。就是把地址的4个字节，先翻译为十进制，然后每个字节用一个小数点分隔开（参见如下示意图）： （4字节 IP 地址：“二进制”与“点分十进制”的对照示意图） “IP 地址”的32比特，分为两部分：第1部分用来标识【子网】，第2部分用来标识该子网中的【主机】。 这两部分各占用多少比特，是不确定的。在这种情况下，“操作系统协议栈”如何知道哪些比特标识“子网”，哪些比特标识“主机”捏？奥妙在于【子网掩码】。所以，大伙儿在给系统配置 IP 地址的时候，通常都需要再设置一个【子网掩码】，就这个用途。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:25:3","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇IP 地址枯竭，及其解决方法 　前一个小节提到：IP地址包含【4字节】（32比特）。因此，最多只能表示【2的32次方】（42亿左右）的不同地址。考虑到还有很多地址保留给特殊用途，实际可用地址远远不到42亿。 到了如今，全球网民都已经几十亿了，IP 地址开始枯竭。咋办捏？为了解决这个问题，发展出若干技术手段。简单说一下最常见的几种手段： 　IPv6 名气最大（最多人知道）的技术手段，大概是 IPv6 了。这招想要一劳永逸地解决地址枯竭的问题，采用了16字节（128比特）来表示 IP 地址。 设计 IPv6 的人自豪地宣称：即使给地球上的每一粒沙子分配一个 IPv6 地址，依然绰绰有余（确实没有吹牛，“2的128次方”是天文数字）。 但 IPv6 的缺点在于，【无法】向下兼容原有的 IP 协议（原有的协议叫“IPv4”）。IPv6 的普及一直比较慢，这是主要原因。 　代理服务器（proxy） 一看到代理，很多人就想到翻墙。其实它也可以用来解决“地址枯竭”的问题。 比如说，某个公司有100人，100台电脑。如果每台电脑都分配公网 IP 地址，就要消耗100个公网地址（太浪费啦）。 可以只申请一个公网 IP，然后在内网搞一个代理服务器，公网 IP 分配给它（代理服务器有两个网卡，一个接内网，一个接公网）。然后在其它电脑上设置代理，指向这台代理服务器，就都可以上外网啦。 （注：在本文的末尾有一个 ★杂项 的章节，会专门聊一下“代理”这个话题） 　网络地址转换（NAT） 前面 proxy 那招有个缺点：内网的每台电脑里面的每个上网软件，都要单独设置代理。实在太麻烦啦！ 后来就发明了某种更牛逼的招数——网络地址转换（洋文是“Network Address Translation”，简称 NAT）。 用了这招，还是只要申请一个公网 IP，分配给内网的网关（网关有两个网卡，一个接内网，一个接公网）。然后在内网的网关配置 NAT 功能，自动就可以让内网的每台电脑访问外网。 在这篇博文，俺介绍了虚拟机的几种“网卡模式”，其中有一种模式叫做【NAT 模式】，就是指这个玩意儿。 采用了 NAT 技术之后，可能会对某些应用软件（尤其是 P2P 类型的）造成兼容性问题，于是又发明了一些“NAT 穿透技术”（NAT traversal）。这类技术有好几种，如果有空的话，俺会单独写教程介绍。 　其它解决方法 关于“IPv4 地址空间耗尽”，解决方法肯定不止上面这几招。限于篇幅，就此打住。更多的讨论参见维基百科的“这个链接”。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:25:4","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇网络层相关的【网络设备】 路由器（router） （前面章节聊“路由原理”的时候，已经介绍过它；这里就不再浪费口水啦） 　3层交换机（Layer 3 switching） “3层交换机”是在“2层交换机”的基础上，增加了对网络层的处理。因此，它可以做到类似路由器的效果——在几个子网之间转发数据。 与路由器的差别在于——“3层交换机”链接的几个子网是【同种】网络；而路由器可以连接【异种】网络。 从上面这句话看，“3层交换机”的能力显然不如“路由器”。既然已经有“路由器”，为啥还要发明“3层交换机”捏？这就要说到【单臂路由器】的弊端。 对于企业内网的“2层交换机”，通常都支持 VLAN 功能。通俗地说：可以在交换机中划分多个【虚拟子网】。其实这些子网的中所有的电脑，都还是接入这台交换机，只不过这些子网配置了不同的网络地址。对于同一个 VLAN 内部的通讯，“2层交换机”自己就可以搞定（只需要用到2层协议）；但对于【跨】VLAN 主机之间的通讯，“2层交换机”就没戏啦（它没有路由功能）。因此，就必须在它旁边外加一个路由器，形成如下拓扑结构。在这个拓扑中，路由器只与单个设备（2层交换机）相连，所以称之为“单臂”。 请注意：如下示意图只画了两台电脑，位于两个 VLAN。实际上可能有很多个 VLAN，每个里面有几十台电脑。于是，交换机与路由器之间的传输通道就会成为瓶颈——【跨】VLAN 的任意两台电脑通讯，数据包都要到路由器那里兜一圈。为了消除这种瓶颈，才发明了“3层交换机”——把路由功能直接集成到交换机内部。 （“单臂路由器”的拓扑结构） 无线热点（Wireless Access Point） “无线热点”通常用来提供无线接入，使得某个【无线】设备能接入到某个【有线】网络中。一般来说，热点都内置了路由功能，那么它就是“无线路由器”，对应到“3层”（网络层）。反之，如果没有路由功能，它就是“网桥”，属于“2层”（链路层）。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:25:5","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇网络层相关的【软件工具】 ping 这个命令，很多人应该都知道。早在 Win9x 就有这个命令了。它使用（网络层的）ICMP 协议来测试某个远程主机是否可达。 提醒一下： 如果 ping 命令显示某个 IP 地址不可达，有很多种情况。比如说： 这个 IP 地址对应的主机已经关机 这个 IP 地址对应的主机已经断线 这个 IP 地址对应的主机拒绝响应 ICMP 协议 从你本机到这个 IP 地址之间，有某个防火墙拦截了 ICMP 协议 …… traceroute 这是一个通用的工具，用来测试路由。很早以前的 Windows 就已经内置了它，命令是 tracert。在 POSIX（Linux＆UNIX）上通常叫 traceroute 你可以用这个命令，测试你本机与互联网另一台主机之间的路由（也就是：从你本机到对方主机，要经过哪些路由器） ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:25:6","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"★传输层：概述 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:26:0","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇传输层的必要性 屏蔽“有连接 or 无连接”的差异 （上一个章节提到）网络层本身已经屏蔽了【异种网络】的差异（比如“以太网、ATM、帧中继”之间的差异），而且网络层也屏蔽了路由的细节。但网络层本身还有一个差异，也就是网络层的两种交换技术：电路交换（有连接） VS 分组交换（无连接）。 前面章节也提到了：上述两种交换技术各有很多支持者，并分裂为两大阵营。当年设计 OSI 模型的时候，为了保持中立性与通用性，并没有强制规定“网络层”必须采用何种交换机制。 对于开发网络软件的程序员来说，当然不想操心“网络层用的是哪一种交换机制”。因此，需要对网络层的上述差异再加一个抽象层（也就是“传输层”）。 　从“主机”到“进程” 前面介绍的“网络层”，其设计是面向主机（电脑）。“网络层地址”也就是某个主机的地址。 而“传输层”是面向【进程】滴！因为传输层要提供给【网络软件】使用，而网络软件打交道的对象是【另一个网络软件】。因此，传输层必须在“网络层地址”的基础上，再引入某种新的标识，用来区分同一台主机上的不同【进程】。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:26:1","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇传输层的特殊性 　在 OSI 7层模型中，传输层正好居中。这是一个很特殊的位置。 OSI 模型最下面3层，与【网络设备】比较密切。这里面所说的“网络设备”，既包括那些独立的主机（比如“路由器、交换机、等”），也包括电脑上的硬件（比如“网卡”）。 OSI 模型最上面3层，与【网络软件】比较密切（或者说，与“用户的业务逻辑”比较密切）。 而中间的传输层，正好是承上启下。对于开发应用软件的程序猿/程序媛，“传输层”是他们能感知的最低一层。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:26:2","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇传输层的【端口】 　刚才谈“传输层的必要性”，提到说——“网络层地址”只能标识【主机】，而传输层必须要能标识【进程】。为了达到这个目的，于是就引入了“传输层端口”这个概念（为了打字省力，后续讨论简称为“端口”）。 在 OSI 模型中，“端口”的官方称呼是“传输服务访问点”（洋文缩写 TSAP）。但是作为程序员，俺已经习惯于“端口”这个称呼。后续介绍依然用“端口”一词。 当程序员使用传输层提供的 API 开发网络软件时，通常把“端口”与“网络地址”一起使用（构成“二元组”），就可以定位到某个主机上的某个进程。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:26:3","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"★传输层：具体实例 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:27:0","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇传输层的【协议】 　为了让程序员可以更爽地使用传输层来开发网络软件，传输层既要提供“有连接”的风格，也要提供“无连接”的风格。关于这两种风格的对比，前面已经聊过，这里不再浪费口水。 具体到“互联网协议族”，有两个主要的传输层实现，分别是 TCP ＆ UDP（前者是“有连接”，后者是“无连接”）。 除了 TCP ＆ UDP，“互联网协议族”还提供了其它一些传输层协议。因为比较冷门，俺就不介绍啦。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:27:1","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇传输层的【协议实现】 　对于电脑主机（含移动设备），传输层的协议实现通常包含在操作系统自带的网络模块中（也就是“操作系统协议栈”）。具体参见如下示意图。 另外，还有一些专门的【4层】网络设备，也提供传输层的功能（参见后续的小节）。 （OSI 模型中，不同层次的协议实现） ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:27:2","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇套接字（socket API） 　前面说了：传输层是面向程序员（让他们可以更方便地开发网络软件）。因此，就需要提供一些封装传输层的【库】（API）。程序员只需要调用这些【库】，就可以使用传输层的协议进行通讯啦。 影响力最大的传输层封装库，当然是 socket API。它来自加州大学伯克利分校。 在互联网诞生初期，伯克利分校开发了一个 UNIX 操作系统的的变种，叫做“伯克利 UNIX 发行版”（BSD Unix），也就是如今 BSD 操作系统的前身。伯克利发行版内置了一套用来进行网络编程的 API，当时叫做“伯克利套接字”（Berkeley sockets）。由于这套 API 用起来很方便，很多其它的 UNIX 变种也移植了这套 API，于是就逐渐成了业界的事实标准。到了上世纪90年代，Windows ＆ Linux 也都提供了这套 API。 由于大部分读者不是程序员，“套接字”这个话题就到此为止。如果你是个程序员，并且对网络编程感兴趣，可以参考俺的电子书清单，其中有一个分类目录是【IT 类 / 软件开发 / 网络相关】。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:27:3","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇传输层相关的【网络设备】 4层交换机（Layer 4 switching） 前面已经介绍了“3层交换机”，“4层交换机”是其进一步的改良，可以识别传输层的协议，获取 TCP or UDP 的端口号。 有了这个能力，网管就可以在这种交换机上配置一些管理策略。比如说：（根据传输层端口号）过滤掉某种流量，或者对某种流量设置转发的优先级。 　状态防火墙（stateful firewall） 网络防火墙分好几种，大部分属于这种。它能完全处理 TCP 协议的状态，显然它属于“4层”（传输层）。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:27:4","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇传输层相关的【软件工具】 netcat 家族——传输层的“瑞士军刀” 关于 netcat，俺已经写过一篇比较详细的教程：《扫盲 netcat（网猫）的 N 种用法——从“网络诊断”到“系统入侵”》。看完这篇教程，你肯定能体会它功能的强大——很多与 TCP/UDP 相关的事情，都可以用 netcat 搞定。 另外，netcat 还有很多衍生品（衍生的开源项目），构成一个丰富的 netcat 家族。在上述教程也有介绍。 　netstat ＆ ss Windows 和 POSIX（Linux＆UNIX）都有一个 netstat 命令，可以查看当前系统的 TCP/UDP 状态（包括当前系统开启了哪些监听端口）。 另外，Linux 上还有一个 ss 命令，功能更强（但这个命令在 Windows 上默认没有） 　nmap 这是最著名的开源的扫描器，可以扫描远程主机监听了哪些传输层端口（注：前面提到的“netcat 家族”也可以干这事儿） nmap 的功能很强，“端口扫描”只是其功能之一。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:27:5","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"★业务层（OSI 上三层）：概述 　一不小心，这篇教程已经写了这么长。为了照顾那些有“阅读障碍”的读者，俺要稍微控制一下篇幅，就把 OSI 的【上三层】合在一起讨论。 前面的章节说过：【上三层】更接近于“网络软件”，对应的是应用软件的业务逻辑，因此俺统称为“业务层”。 注：有些书（比如《计算机网络》）会把 OSI 的上三层统称为“应用层”。由于 OSI 模型中本来就有一个“应用层”，俺认为这样容易搞混（尤其不利于技术菜鸟），所以另外起了一个“业务层”的名称。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:28:0","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇业务层的必要性 　业务层显然是必要滴。因为传输层位于操作系统，它不可能去了解网络软件的业务逻辑。为了让网络软件能够相互通讯，肯定要在传输层之上再定义更高层的协议。 问题在于：网络软件千奇百怪，其业务逻辑各不相同，因此，“业务层如何设计”，【无】一定之规。有些软件只用一个协议来搞定所有的业务逻辑（只有一层）；有些软件会参考 OSI，把业务逻辑的协议分为三层；还有些软件可能会分出更多的层次。 再强调一下：业务层的协议如何分层，完全看具体的业务逻辑，不要生搬硬套任何现有的参考模型。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:28:1","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇会话层 ＆ 表示层 ＆ 应用层 　对于大部分读者来说，【没必要】花时间去了解 OSI 最上面三层之间的区别。你只需把最上面三层视作【一坨】——他们都是与网络软件的业务逻辑密切相关滴。 那么，哪些人需要详细了解“这三层的差异”捏？ 如果你是个程序员，并且你正好是开发【网络】软件，俺建议你了解一下 OSI 模型的最上面三层，有助于你更深刻地思考某些网络协议的设计。所谓的“更深刻”指的是：你不能光停留在 WHAT 层面，要提升到 HOW 甚至 WHY 层面（参见《学习技术的三部曲：WHAT、HOW、WHY》） ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:28:2","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"★业务层（OSI 上三层）：具体实例 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:29:0","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇业务层的【协议】 　业务层的协议非常多。即使光把各种协议的名称列出来，也很费劲。所以俺就偷懒一下，只点评几个特别重要的协议。 　HTTP 协议 如果让俺评选最重要的业务层协议，俺首推 HTTP 协议。互联网的普及推动了 Web 的普及，而 Web 的普及使得 HTTP 成为信息时代的重要支柱。当你上网的时候，你看到的网页（HTML 页面）就是通过 HTTP 协议传输到你的浏览器上。 如今 HTTP 已经不仅仅用来展示网页，还有很多业务层的协议是建立在 HTTP 协议之上。比如说：如果你用 RSS 订阅俺的博客，RSS 阅读器需要调用 blogspot 博客平台提供的 RSS 接口，这些 RSS 接口就是基于 HTTP 协议传输滴。 考虑到本文的篇幅，俺不可能在这里细聊 HTTP 协议的规格，有兴趣的同学可以去看《HTTP 权威指南》这本书。 　SSL/TLS 协议 最早的 HTTP 协议是【明文】滴；为了强化安全性，后来又设计了 SSL 协议，用来【加密】HTTP 流量；再后来，SSL 升级为 TLS（这俩是同义词）。如今经常看到的 HTTPS 相当于“HTTP over TLS”。 SSL/TLS 设计得比较优雅（很灵活），使得其它业务层的协议可以很方便地架构在 SSL/TLS 之上。这样的好处是：其它协议就不用自己再设计一套加密机制＆认证机制。 SSL/TLS 对于安全性很重要，因此俺专门写了一个系列教程（如下），详细介绍该协议的技术细节。 《扫盲 HTTPS 和 SSL／TLS 协议》（系列） 　域名相关的协议（DNS 及其它） 域名相关的协议，也很重要。因为域名系统是整个互联网的基础设施。最早的域名查询协议是“DNS 协议”，由于这个协议【没有】加密，导致了一些安全隐患。比如 GFW 就利用 DNS 的这个弱点，搞“域名污染/域名投毒”。因此，后来又设计了一系列新的域名协议，引入了加密的机制。 关于这些协议的扫盲教程，可以参考如下几篇博文： 《扫盲 DNS 原理，兼谈“域名劫持”和“域名欺骗／域名污染”》 《对比4种强化域名安全的协议——DNSSEC，DNSCrypt，DNS over TLS，DNS over HTTPS》 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:29:1","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇业务层相关的【网络设备】 应用层防火墙（application firewall） 前面提到了：大多数网络防火墙处于4层（状态防火墙），另外还有少数处于7层，也就是“应用层防火墙”（有时候也称之为“7层防火墙”）。 一般来说，这类防火墙具备了【深度包检测】（deep packet inspection，简称 DPI）的能力，可以分析应用层协议的【内容】。 简单说一下“深度包检测”： 如果某个网络设备，仅仅分析“应用层协议”本身，它还【不够格】称之为 DPI。为了做到 DPI，还要能理解应用层协议所承载的【内容】。 比如说：某人通过【明文】的 HTTP 协议从网上下载了一个 zip 压缩包。对于这个下载行为，那些做得好的 DPI 设备不光能识别出“HTTP 协议的内容是 ZIP 压缩包”，而且还能从 ZIP 压缩包中提取出里面的文件。 　一般来说，“入侵检测”如果不加定语，通常指“【网络】入侵检测”（洋文叫 NIDS）；另外还有一种“【主机】入侵检测”（洋文叫 HIDS）。HIDS 与本文无关。 “入侵检测”是一种网络安全设备，它通过嗅探（sniffer）的方式抓取网上的数据包，然后进行分析，尝试发现网络中是否存在黑客/骇客的入侵的行为。故名“入侵检测”。 由于 IDS 需要理解【应用层】（7层）的内容，因此它与“应用层防火墙”有个共同点，需要具备某种程度的 DPI（深度包检测）能力。它俩的一大差异是【部署方式】。 考虑到很多读者是 IT 外行，简单说一下“旁路部署”—— 如果你学过中学物理，应该知道电路有“串联 ＆ 并联”。所谓的“旁路部署”类似于电路中的【并联】。通俗地说：IDS 是【并联】部署，防火墙是【串联】部署。 　GFW（Great Firewall） 本博客已经写了很多翻墙教程，大伙儿肯定都知道 GFW 了。 由于“Great Firewall”中有“Firewall”字样，很多天朝网民【误以为】GFW 是防火墙，其实不然！GFW 本质上就是 IDS——其部署方式类似于 IDS（旁路部署），其工作方式有很大一部分也类似于 IDS（当然啦，GFW 的功能比 IDS 更多）。 大约七八年前，就有热心读者建议俺写一篇技术博文，介绍 GFW 的工作原理。由于俺比较懒，拖到今年（2021）都没动手，很惭愧 :( ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:29:2","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"★杂项 　有些概念，并不属于某个特定的层次，单独放到这个章节。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:30:0","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇VPN（virtual private network） 　咱们天朝的网民使用 VPN，一多半是为了翻墙。其实 VPN 的本意（如其名称所示）是为了提供某种虚拟化的私有的网络，让身处异地的多个人，可以用 VPN 构建出一个虚拟的内网，从而能在这个内网中协同工作。 VPN 的类型很多，使用的技术也各不相同，因此 VPN 对应的 OSI 层次很宽（“1层”到“6层”）。俺到维基百科剽窃了如下这张图，让你见识一下 VPN 的多样性。 （名目繁多的 VPN，分类示意图） ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:30:1","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇代理（proxy） 　那些经常翻墙的同学，对“代理”应该都很熟悉了。“代理”与 VPN 类似，一开始并不是用来翻墙滴，“翻墙”只是这俩的副业。 　代理服务器（proxy server） “代理服务器”部署在“客户端 ＆ 服务端”之间，起到某种“中介”的作用。“代理服务器”的类型有很多，干的事情各不相同。 （“代理服务器”的简单示意图） 代理客户端（proxy client） 早期的代理服务器，【不】需要“代理客户端”。因为早期的“代理服务器”支持的是【标准协议】。比如“HTTP proxy server”支持的是标准 HTTP协议，而用户的电脑上，已经有浏览器（原生支持 HTTP 协议）。这种情况下，自然不需要再有“代理客户端”。 后来，为了满足某些特殊需求（比如翻墙），“代理服务器”必须使用某种特殊的（非标准的）协议。因此，就必须在用户的环境中安装“代理客户端”。对于翻墙来说，你装的翻墙软件，相当于“代理客户端”。 　代理的层次 “代理”也分不同的层次。比较常见的有如下几种： TCP 代理（TCP 端口转发）——4层（传输层） SOCKS 代理——5层（会话层） HTTP 代理——7层（应用层） …… ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:30:2","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇网关（gateway） 　前面的某些章节，已经稍微提及了“网关”这个概念，但还没有具体介绍它。 严格来讲，“网关”是一个逻辑概念，【不要】把它当成具体的网络设备。充当“网关”的东东，可能是：路由器 or XX层交换机 or XX层防火墙 or 代理服务器 …… “网关”也分不同的层次。如果不加定语，通常指的是“3层网关”（网络层网关）。列几种比较常见的，供参考： 路由器充当网关——3层（网络层） 3层交换机充当网关——3层（网络层） 4层交换机充当网关——4层（传输层） 应用层防火墙充当网关——7层（应用层） 代理服务器充当网关——（取决于代理的层次，参见前一个小节） …… ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:30:3","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["计算机网络"],"content":"◇隧道协议（tunneling protocol） 　所谓的“隧道协议”，通俗地说就是：用某种协议包裹另一种协议，以满足某些特殊的需求。 看到这里，估计某些同学会感到纳闷——因为俺在本文开头介绍“协议栈”的时候提到说：相邻的两层协议，下层会包裹上层。“隧道协议的包裹”与“上下层协议的包裹”，差别在哪捏？ 俺来解释一下： “隧道协议”可以做到更灵活的包裹——既可以对层次相隔很远的协议进行包裹，也可以对同一层的协议进行包裹，甚至可以“倒挂”——所谓的“倒挂”就是让【上】层反过来包裹【下】层。 举例： 俺曾经写过一篇《如何让【不支持】代理的网络软件，通过代理进行联网（不同平台的 N 种方法）》，其中介绍了“HTTP 代理”的两种模式：“转发模式 ＆ 隧道模式”。对于“HTTP 代理”的隧道模式，可以实现【TCP over HTTP】（把 TCP 协议打包到 HTTP 协议内部），这就是刚才所说的“倒挂”。 另外，VPN 小节的那张图中，有些类型的 VPN 就是用“隧道协议”的机制实现。 ","date":"2021-05-20","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/:30:4","tags":["网络通信"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%89%AB%E7%9B%B2/"},{"categories":["SQL"],"content":"MySQL的相关概念介绍 MySQL 为关系型数据库(Relational Database Management System), 这种所谓的\"关系型\"可以理解为\"表格\"的概念, 一个关系型数据库由一个或数个表格组成。 表头(header): 每一列的名称; 列(row): 具有相同数据类型的数据的集合; 行(col): 每一行用来描述某个人/物的具体信息; 值(value): 行的具体信息, 每个值必须与该列的数据类型相同; 键(key): 表中用来识别某个特定的人\\物的方法, 键的值在当前列中具有唯一性。 ","date":"2021-05-20","objectID":"/21%E5%88%86%E9%92%9F-mysql-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-wid/:1:0","tags":["SQL"],"title":"MySQL入门","uri":"/21%E5%88%86%E9%92%9F-mysql-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-wid/"},{"categories":["SQL"],"content":"Windows下MySQL的配置 以 MySQL 5.1 免安装版为例, 下载 mysql-noinstall-5.1.69-win32.zip ( 官方下载页: http://dev.mysql.com/downloads/mysql/5.1.html#downloads ) ","date":"2021-05-20","objectID":"/21%E5%88%86%E9%92%9F-mysql-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-wid/:2:0","tags":["SQL"],"title":"MySQL入门","uri":"/21%E5%88%86%E9%92%9F-mysql-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-wid/"},{"categories":["SQL"],"content":"配置步骤: 1. 将下载的 mysql-noinstall-5.1.69-win32.zip 解压至需要安装的位置, 如: C:\\Program Files; 2. 在安装文件夹下找到 my-small.ini 配置文件, 将其重命名为 my.ini , 打开进行编辑, 在 [client] 与 [mysqld] 下均添加一行: default-character-set = gbk 3. 打开 Windows 环境变量设置, 新建变量名 MYSQL_HOME , 变量值为 MySQL 安装目录路径, 这里为 C:\\Program Files\\mysql-5.1.69-win32 4. 在 环境变量 的 Path 变量中添加 ;%MYSQL_HOME%\\bin; 5. 安装 MySQL 服务, 打开Windows命令提示符, 执行命令: mysqld –install MySQL –defaults-file=“my.ini” 提示\"Service successfully installed.“表示成功; ","date":"2021-05-20","objectID":"/21%E5%88%86%E9%92%9F-mysql-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-wid/:2:1","tags":["SQL"],"title":"MySQL入门","uri":"/21%E5%88%86%E9%92%9F-mysql-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-wid/"},{"categories":["SQL"],"content":"MySQL服务的启动、停止与卸载 在 Windows 命令提示符下运行: 启动: net start MySQL 停止: net stop MySQL 卸载: sc delete MySQL ","date":"2021-05-20","objectID":"/21%E5%88%86%E9%92%9F-mysql-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-wid/:2:2","tags":["SQL"],"title":"MySQL入门","uri":"/21%E5%88%86%E9%92%9F-mysql-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-wid/"},{"categories":["SQL"],"content":"MySQL脚本的基本组成 与常规的脚本语言类似, MySQL 也具有一套对字符、单词以及特殊符号的使用规定, MySQL 通过执行 SQL 脚本来完成对数据库的操作, 该脚本由一条或多条MySQL语句(SQL语句 + 扩展语句)组成, 保存时脚本文件后缀名一般为 .sql。在控制台下, MySQL 客户端也可以对语句进行单句的执行而不用保存为.sql文件。 ","date":"2021-05-20","objectID":"/21%E5%88%86%E9%92%9F-mysql-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-wid/:3:0","tags":["SQL"],"title":"MySQL入门","uri":"/21%E5%88%86%E9%92%9F-mysql-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-wid/"},{"categories":["SQL"],"content":"标识符 标识符用来命名一些对象, 如数据库、表、列、变量等, 以便在脚本中的其他地方引用。MySQL标识符命名规则稍微有点繁琐, 这里我们使用万能命名规则: 标识符由字母、数字或下划线(_)组成, 且第一个字符必须是字母或下划线。 对于标识符是否区分大小写取决于当前的操作系统, Windows下是不敏感的, 但对于大多数 linux\\unix 系统来说, 这些标识符大小写是敏感的。 ","date":"2021-05-20","objectID":"/21%E5%88%86%E9%92%9F-mysql-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-wid/:3:1","tags":["SQL"],"title":"MySQL入门","uri":"/21%E5%88%86%E9%92%9F-mysql-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-wid/"},{"categories":["SQL"],"content":"关键字: MySQL的关键字众多, 这里不一一列出, 在学习中学习。 这些关键字有自己特定的含义, 尽量避免作为标识符。 ","date":"2021-05-20","objectID":"/21%E5%88%86%E9%92%9F-mysql-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-wid/:3:2","tags":["SQL"],"title":"MySQL入门","uri":"/21%E5%88%86%E9%92%9F-mysql-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-wid/"},{"categories":["SQL"],"content":"语句: MySQL语句是组成MySQL脚本的基本单位, 每条语句能完成特定的操作, 他是由 SQL 标准语句 + MySQL 扩展语句组成。 ","date":"2021-05-20","objectID":"/21%E5%88%86%E9%92%9F-mysql-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-wid/:3:3","tags":["SQL"],"title":"MySQL入门","uri":"/21%E5%88%86%E9%92%9F-mysql-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-wid/"},{"categories":["SQL"],"content":"函数: MySQL函数用来实现数据库操作的一些高级功能, 这些函数大致分为以下几类: 字符串函数、数学函数、日期时间函数、搜索函数、加密函数、信息函数。 ","date":"2021-05-20","objectID":"/21%E5%88%86%E9%92%9F-mysql-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-wid/:3:4","tags":["SQL"],"title":"MySQL入门","uri":"/21%E5%88%86%E9%92%9F-mysql-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-wid/"},{"categories":["SQL"],"content":"MySQL中的数据类型 MySQL有三大类数据类型, 分别为数字、日期\\时间、字符串, 这三大类中又更细致的划分了许多子类型: 数字类型 整数: tinyint、smallint、mediumint、int、bigint 浮点数: float、double、real、decimal 日期和时间: date、time、datetime、timestamp、year 字符串类型 字符串: char、varchar 文本: tinytext、text、mediumtext、longtext 二进制(可用来存储图片、音乐等): tinyblob、blob、mediumblob、longblob 这里不能详细对这些类型进行介绍了, 篇幅可能会很长, 详细介绍参见: 《MySQL数据类型》 : http://www.cnblogs.com/zbseoag/archive/2013/03/19/2970004.html ","date":"2021-05-20","objectID":"/21%E5%88%86%E9%92%9F-mysql-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-wid/:4:0","tags":["SQL"],"title":"MySQL入门","uri":"/21%E5%88%86%E9%92%9F-mysql-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-wid/"},{"categories":["SQL"],"content":"使用MySQL数据库 ","date":"2021-05-20","objectID":"/21%E5%88%86%E9%92%9F-mysql-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-wid/:5:0","tags":["SQL"],"title":"MySQL入门","uri":"/21%E5%88%86%E9%92%9F-mysql-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-wid/"},{"categories":["SQL"],"content":"登录到MySQL 当 MySQL 服务已经运行时, 我们可以通过MySQL自带的客户端工具登录到MySQL数据库中, 首先打开命令提示符, 输入以下格式的命名: mysql -h 主机名 -u 用户名 -p -h : 该命令用于指定客户端所要登录的MySQL主机名, 登录当前机器该参数可以省略; -u : 所要登录的用户名; -p : 告诉服务器将会使用一个密码来登录, 如果所要登录的用户名密码为空, 可以忽略此选项。 以登录刚刚安装在本机的MySQL数据库为例, 在命令行下输入 mysql -u root -p 按回车确认, 如果安装正确且MySQL正在运行, 会得到以下响应: Enter password: 若密码存在, 输入密码登录, 不存在则直接按回车登录, 按照本文中的安装方法, 默认 root 账号是无密码的。登录成功后你将会看到 Welecome to the MySQL monitor… 的提示语。 然后命令提示符会一直以 mysql\u003e 加一个闪烁的光标等待命令的输入, 输入 exit 或 quit 退出登录。 ","date":"2021-05-20","objectID":"/21%E5%88%86%E9%92%9F-mysql-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-wid/:5:1","tags":["SQL"],"title":"MySQL入门","uri":"/21%E5%88%86%E9%92%9F-mysql-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-wid/"},{"categories":["SQL"],"content":"创建一个数据库 使用 create database 语句可完成对数据库的创建, 创建命令的格式如下: create database 数据库名 [其他选项]; 例如我们需要创建一个名为 samp_db 的数据库, 在命令行下执行以下命令: create database samp_db character set gbk; 为了便于在命令提示符下显示中文, 在创建时通过 character set gbk 将数据库字符编码指定为 gbk。创建成功时会得到 Query OK, 1 row affected(0.02 sec) 的响应。 注意: MySQL语句以分号(;)作为语句的结束, 若在语句结尾不添加分号时, 命令提示符会以 -\u003e 提示你继续输入(有个别特例, 但加分号是一定不会错的); 提示: 可以使用 show databases; 命令查看已经创建了哪些数据库。 ","date":"2021-05-20","objectID":"/21%E5%88%86%E9%92%9F-mysql-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-wid/:5:2","tags":["SQL"],"title":"MySQL入门","uri":"/21%E5%88%86%E9%92%9F-mysql-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-wid/"},{"categories":["SQL"],"content":"选择所要操作的数据库 要对一个数据库进行操作, 必须先选择该数据库, 否则会提示错误: ERROR 1046(3D000): No database selected 两种方式对数据库进行使用的选择: 一: 在登录数据库时指定, 命令: mysql -D 所选择的数据库名 -h 主机名 -u 用户名 -p 例如登录时选择刚刚创建的数据库: mysql -D samp_db -u root -p 二: 在登录后使用 use 语句指定, 命令: use 数据库名; use 语句可以不加分号, 执行 use samp_db 来选择刚刚创建的数据库, 选择成功后会提示: Database changed ","date":"2021-05-20","objectID":"/21%E5%88%86%E9%92%9F-mysql-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-wid/:5:3","tags":["SQL"],"title":"MySQL入门","uri":"/21%E5%88%86%E9%92%9F-mysql-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-wid/"},{"categories":["SQL"],"content":"创建数据库表 使用 create table 语句可完成对表的创建, create table 的常见形式: create table 表名称(列声明); 以创建 students 表为例, 表中将存放 学号(id)、姓名(name)、性别(sex)、年龄(age)、联系电话(tel) 这些内容: create table students （ id int unsigned not null auto_increment primary key, name char(8) not null, sex char(4) not null, age tinyint unsigned not null, tel char(13) null default “-” ); 对于一些较长的语句在命令提示符下可能容易输错, 因此我们可以通过任何文本编辑器将语句输入好后保存为 createtable.sql 的文件中, 通过命令提示符下的文件重定向执行执行该脚本。 打开命令提示符, 输入: mysql -D samp_db -u root -p \u003c createtable.sql (提示: 1.如果连接远程主机请加上 -h 指令; 2. createtable.sql 文件若不在当前工作目录下需指定文件的完整路径。) 语句解说: create table tablename(columns) 为创建数据库表的命令, 列的名称以及该列的数据类型将在括号内完成; 括号内声明了5列内容, id、name、sex、age、tel为每列的名称, 后面跟的是数据类型描述, 列与列的描述之间用逗号(,)隔开; 以 “id int unsigned not null auto_increment primary key” 行进行介绍: “id” 为列的名称; “int” 指定该列的类型为 int(取值范围为 -8388608到8388607), 在后面我们又用 “unsigned” 加以修饰, 表示该类型为无符号型, 此时该列的取值范围为 0到16777215; “not null” 说明该列的值不能为空, 必须要填, 如果不指定该属性, 默认可为空; “auto_increment” 需在整数列中使用, 其作用是在插入数据时若该列为 NULL, MySQL将自动产生一个比现存值更大的唯一标识符值。在每张表中仅能有一个这样的值且所在列必须为索引列。 “primary key” 表示该列是表的主键, 本列的值必须唯一, MySQL将自动索引该列。 下面的 char(8) 表示存储的字符长度为8, tinyint的取值范围为 -127到128, default 属性指定当该列值为空时的默认值。 更多的数据类型请参阅 《MySQL数据类型》 : http://www.cnblogs.com/zbseoag/archive/2013/03/19/2970004.html 提示: 1. 使用 show tables; 命令可查看已创建了表的名称; 2. 使用 describe 表名; 命令可查看已创建的表的详细信息。 ","date":"2021-05-20","objectID":"/21%E5%88%86%E9%92%9F-mysql-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-wid/:5:4","tags":["SQL"],"title":"MySQL入门","uri":"/21%E5%88%86%E9%92%9F-mysql-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-wid/"},{"categories":["SQL"],"content":"操作MySQL数据库 ","date":"2021-05-20","objectID":"/21%E5%88%86%E9%92%9F-mysql-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-wid/:6:0","tags":["SQL"],"title":"MySQL入门","uri":"/21%E5%88%86%E9%92%9F-mysql-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-wid/"},{"categories":["SQL"],"content":"向表中插入数据 insert 语句可以用来将一行或多行数据插到数据库表中, 使用的一般形式如下: insert [into] 表名 [(列名1, 列名2, 列名3, …)] values (值1, 值2, 值3, …); 其中 [] 内的内容是可选的, 例如, 要给 samp_db 数据库中的 students 表插入一条记录, 执行语句: insert into students values(NULL, “王刚”, “男”, 20, “13811371377”); 按回车键确认后若提示 Query Ok, 1 row affected (0.05 sec) 表示数据插入成功。 若插入失败请检查是否已选择需要操作的数据库。 有时我们只需要插入部分数据, 或者不按照列的顺序进行插入, 可以使用这样的形式进行插入: insert into students (name, sex, age) values(“孙丽华”, “女”, 21); ","date":"2021-05-20","objectID":"/21%E5%88%86%E9%92%9F-mysql-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-wid/:6:1","tags":["SQL"],"title":"MySQL入门","uri":"/21%E5%88%86%E9%92%9F-mysql-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-wid/"},{"categories":["SQL"],"content":"查询表中的数据 select 语句常用来根据一定的查询规则到数据库中获取数据, 其基本的用法为: select 列名称 from 表名称 [查询条件]; 例如要查询 students 表中所有学生的名字和年龄, 输入语句 select name, age from students; 执行结果如下: mysql\u003e select name, age from students; +——–+—–+ | name | age | +——–+—–+ | 王刚 | 20 | | 孙丽华 | 21 | | 王永恒 | 23 | | 郑俊杰 | 19 | | 陈芳 | 22 | | 张伟朋 | 21 | +——–+—–+ 6 rows in set (0.00 sec) mysql\u003e 也可以使用通配符 * 查询表中所有的内容, 语句: select * from students; ","date":"2021-05-20","objectID":"/21%E5%88%86%E9%92%9F-mysql-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-wid/:6:2","tags":["SQL"],"title":"MySQL入门","uri":"/21%E5%88%86%E9%92%9F-mysql-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-wid/"},{"categories":["SQL"],"content":"按特定条件查询: where 关键词用于指定查询条件, 用法形式为: select 列名称 from 表名称 where 条件; 以查询所有性别为女的信息为例, 输入查询语句: select * from students where sex=“女”; where 子句不仅仅支持 “where 列名 = 值” 这种名等于值的查询形式, 对一般的比较运算的运算符都是支持的, 例如 =、\u003e、\u003c、\u003e=、\u003c、!= 以及一些扩展运算符 is [not] null、in、like 等等。 还可以对查询条件使用 or 和 and 进行组合查询, 以后还会学到更加高级的条件查询方式, 这里不再多做介绍。 示例: 查询年龄在21岁以上的所有人信息: select * from students where age \u003e 21; 查询名字中带有 “王” 字的所有人信息: select * from students where name like “%王%”; 查询id小于5且年龄大于20的所有人信息: select * from students where id\u003c5 and age\u003e20; ","date":"2021-05-20","objectID":"/21%E5%88%86%E9%92%9F-mysql-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-wid/:6:3","tags":["SQL"],"title":"MySQL入门","uri":"/21%E5%88%86%E9%92%9F-mysql-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-wid/"},{"categories":["SQL"],"content":"更新表中的数据 update 语句可用来修改表中的数据, 基本的使用形式为: update 表名称 set 列名称=新值 where 更新条件; 使用示例: 将id为5的手机号改为默认的”-\": update students set tel=default where id=5; 将所有人的年龄增加1: update students set age=age+1; 将手机号为 13288097888 的姓名改为 “张伟鹏”, 年龄改为 19: update students set name=“张伟鹏”, age=19 where tel=“13288097888”; ","date":"2021-05-20","objectID":"/21%E5%88%86%E9%92%9F-mysql-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-wid/:6:4","tags":["SQL"],"title":"MySQL入门","uri":"/21%E5%88%86%E9%92%9F-mysql-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-wid/"},{"categories":["SQL"],"content":"删除表中的数据 delete 语句用于删除表中的数据, 基本用法为: delete from 表名称 where 删除条件; 使用示例: 删除id为2的行: delete from students where id=2; 删除所有年龄小于21岁的数据: delete from students where age\u003c20; 删除表中的所有数据: delete from students; ","date":"2021-05-20","objectID":"/21%E5%88%86%E9%92%9F-mysql-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-wid/:6:5","tags":["SQL"],"title":"MySQL入门","uri":"/21%E5%88%86%E9%92%9F-mysql-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-wid/"},{"categories":["SQL"],"content":"创建后表的修改 alter table 语句用于创建后对表的修改, 基础用法如下: ","date":"2021-05-20","objectID":"/21%E5%88%86%E9%92%9F-mysql-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-wid/:7:0","tags":["SQL"],"title":"MySQL入门","uri":"/21%E5%88%86%E9%92%9F-mysql-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-wid/"},{"categories":["SQL"],"content":"添加列 基本形式: alter table 表名 add 列名 列数据类型 [after 插入位置]; 示例: 在表的最后追加列 address: alter table students add address char(60); 在名为 age 的列后插入列 birthday: alter table students add birthday date after age; ","date":"2021-05-20","objectID":"/21%E5%88%86%E9%92%9F-mysql-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-wid/:7:1","tags":["SQL"],"title":"MySQL入门","uri":"/21%E5%88%86%E9%92%9F-mysql-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-wid/"},{"categories":["SQL"],"content":"修改列 基本形式: alter table 表名 change 列名称 列新名称 新数据类型; 示例: 将表 tel 列改名为 telphone: alter table students change tel telphone char(13) default “-”; 将 name 列的数据类型改为 char(16): alter table students change name name char(16) not null; ","date":"2021-05-20","objectID":"/21%E5%88%86%E9%92%9F-mysql-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-wid/:7:2","tags":["SQL"],"title":"MySQL入门","uri":"/21%E5%88%86%E9%92%9F-mysql-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-wid/"},{"categories":["SQL"],"content":"删除列 基本形式: alter table 表名 drop 列名称; 示例: 删除 birthday 列: alter table students drop birthday; ","date":"2021-05-20","objectID":"/21%E5%88%86%E9%92%9F-mysql-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-wid/:7:3","tags":["SQL"],"title":"MySQL入门","uri":"/21%E5%88%86%E9%92%9F-mysql-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-wid/"},{"categories":["SQL"],"content":"重命名表 基本形式: alter table 表名 rename 新表名; 示例: 重命名 students 表为 workmates: alter table students rename workmates; ","date":"2021-05-20","objectID":"/21%E5%88%86%E9%92%9F-mysql-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-wid/:7:4","tags":["SQL"],"title":"MySQL入门","uri":"/21%E5%88%86%E9%92%9F-mysql-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-wid/"},{"categories":["SQL"],"content":"删除整张表 基本形式: drop table 表名; 示例: 删除 workmates 表: drop table workmates; ","date":"2021-05-20","objectID":"/21%E5%88%86%E9%92%9F-mysql-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-wid/:7:5","tags":["SQL"],"title":"MySQL入门","uri":"/21%E5%88%86%E9%92%9F-mysql-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-wid/"},{"categories":["SQL"],"content":"删除整个数据库 基本形式: drop database 数据库名; 示例: 删除 samp_db 数据库: drop database samp_db; ","date":"2021-05-20","objectID":"/21%E5%88%86%E9%92%9F-mysql-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-wid/:7:6","tags":["SQL"],"title":"MySQL入门","uri":"/21%E5%88%86%E9%92%9F-mysql-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-wid/"},{"categories":["SQL"],"content":"附录 ","date":"2021-05-20","objectID":"/21%E5%88%86%E9%92%9F-mysql-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-wid/:8:0","tags":["SQL"],"title":"MySQL入门","uri":"/21%E5%88%86%E9%92%9F-mysql-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-wid/"},{"categories":["SQL"],"content":"修改 root 用户密码 按照本文的安装方式, root 用户默认是没有密码的, 重设 root 密码的方式也较多, 这里仅介绍一种较常用的方式。 使用 mysqladmin 方式: 打开命令提示符界面, 执行命令: mysqladmin -u root -p password 新密码 执行后提示输入旧密码完成密码修改, 当旧密码为空时直接按回车键确认即可。 ","date":"2021-05-20","objectID":"/21%E5%88%86%E9%92%9F-mysql-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-wid/:8:1","tags":["SQL"],"title":"MySQL入门","uri":"/21%E5%88%86%E9%92%9F-mysql-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-wid/"},{"categories":["SQL"],"content":"可视化管理工具 MySQL Workbench 尽管我们可以在命令提示符下通过一行行的输入或者通过重定向文件来执行mysql语句, 但该方式效率较低, 由于没有执行前的语法自动检查, 输入失误造成的一些错误的可能性会大大增加, 这时不妨试试一些可视化的MySQL数据库管理工具, MySQL Workbench 就是 MySQL 官方 为 MySQL 提供的一款可视化管理工具, 你可以在里面通过可视化的方式直接管理数据库中的内容, 并且 MySQL Workbench 的 SQL 脚本编辑器支持语法高亮以及输入时的语法检查, 当然, 它的功能强大, 绝不仅限于这两点。 MySQL Workbench官方介绍: http://www.mysql.com/products/workbench/ MySQL Workbench 下载页: http://dev.mysql.com/downloads/tools/workbench/ -——————- wid, 2013.05.09 ","date":"2021-05-20","objectID":"/21%E5%88%86%E9%92%9F-mysql-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-wid/:8:2","tags":["SQL"],"title":"MySQL入门","uri":"/21%E5%88%86%E9%92%9F-mysql-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-wid/"},{"categories":["物理"],"content":"10 Myths About The Quantum Universe For centuries, the laws of physics seemed completely deterministic. If you knew where every particle was, how fast it was moving, and what the forces were between them at any one instant, you could know exactly where they’d be and what they’d be doing at any point in the future. From Newton to Maxwell, the rules that governed the Universe had no built-in, inherent uncertainty to them in any form. Your only limits arose from your limited knowledge, measurements, and calculational power. 几个世纪以来，物理定律似乎是完全确定的。 如果你知道每个粒子的位置，运动的速度，以及在任何一个时刻它们之间的作用力，你就能准确地知道它们在未来的任何一个时刻会在哪里，以及它们会做什么。 从牛顿到麦克斯韦，支配宇宙的规则没有内在的、固有的任何形式的不确定性。 你们唯一的限制来自于你们有限的知识、测量和计算能力。 All of that changed a little over 100 years ago. From radioactivity to the photoelectric effect to the behavior of light when you passed it through a double slit, we began realizing that under many circumstances, we could only predict the probability that various outcomes would arise as a consequence of the quantum nature of our Universe. But along with this new, counterintuitive picture of reality, many myths and misconceptions have arisen. Here’s the true science behind 10 of them. 这一切在100多年前发生了改变。 从放射性到光电效应，再到光通过双缝时的行为，我们开始意识到，在许多情况下，我们只能预测宇宙的量子特性会产生各种结果的可能性。 但是伴随着这个新的，违反直觉的现实图景，许多神话和误解已经产生。 以下是其中10种方法背后的真正科学原理。 1.) Quantum effects only happen on small scales. When we think of quantum effects, we typically think about individual particles (or waves) and the bizarre properties they display. But large-scale, macroscopic effects happen that are inherently quantum in nature. 1.) 量子效应只发生在小尺度上。 当我们想到量子效应时，我们通常会想到单个粒子(或波)以及它们所表现出来的奇异属性。 但是大规模的宏观效应，本质上是量子效应。 Conducting metals cooled below a certain temperature become superconductors: where their resistance drops to zero. Building superconducting tracks where magnets levitate above them and travel around them without ever slowing down is a routine student science project these days, built on an inherently quantum effects. 导电金属在低于一定温度时冷却成为超导体: 在这种情况下，它们的电阻降到零。 建造超导轨道，磁铁悬浮在轨道上方，绕轨道飞行而不放慢速度，如今已成为学生们的常规科学项目，建立在固有的量子效应之上。 Superfluids can be created on large, macroscopic scales, as can quantum drums that simultaneously do and don’t vibrate. Over the past 25 years, 6 Nobel Prizes have been awarded for various macroscopic quantum phenomena. 超流体可以在宏观的大尺度上产生，就像量子鼓可以同时振动和不振动一样。 在过去的25年里，有6个诺贝尔奖被授予各种宏观量子现象。 2.) Quantum always means “discrete.” The idea that you can chop up matter (or energy) into individual chunks — or quanta — is an important concept in physics, but it doesn’t fully encompass what it means for something to be “quantum” in nature. For example: consider an atom. Atoms are made of atomic nuclei with electrons bound to them. 2.) 量子总是意味着“离散” 你可以把物质(或能量)分割成单独的块(或量子) ，这是物理学中的一个重要概念，但它并没有完全涵盖“量子”在自然界中的含义。 例如: 考虑一个原子。 原子是由原子核构成的，原子核上有与原子核相连的电子。 Now, think about this question: where is the electron at any moment in time? 现在，想想这个问题: 电子在任何时刻在哪里？ Even though the electron is a quantum entity, its position is uncertain until you measure it. Take many atoms and bind them together (such as in a conductor), and you’ll frequently discover that although there are discrete energy levels that the electrons occupy, their positions can literally be anywhere within the conductor. Many quantum effects are continuous in nature, and it’s eminently possible that space and time, at a fundamental, quantum level, are continuous, too. 即使电子是一个量子实体，它的位置在你测量它之前是不确定的。 把许多原子绑在一起(比如在导体中) ，你会经常发现，尽管电子占据着离散的能级，但是它们的位置可以在导体中的任何地方。 许多量子效应在本质上是连续的，而且在基本的量子水平上，空间和时间也很有可能是连续的。 3.) Quantum entanglement allows information to travel faster-than-light. Here’s an experiment we can perform: 3.)量子纠缠可以让信息以超光速的方式传播。下面是我们可以做的一个实验: create two entangled particles, 创造两个相互纠缠的粒子, separate them by a great distance, 把他们隔得很远, measure certain quantum properties (like the spin) of one particle on your end, 测量你那一端一个粒子的某些量子属性(如自旋), and you can know some information about the quantum state of other particle instantaneously: faster than the speed of light. 你可以立刻知道其他粒子的量子态的一些信","date":"2020-06-11","objectID":"/%E5%85%B3%E4%BA%8E%E9%87%8F%E5%AD%90%E5%AE%87%E5%AE%99%E7%9A%8410%E4%B8%AA%E8%AF%AF%E5%8C%BA/:0:0","tags":["量子","物理"],"title":"关于量子宇宙的10个误区","uri":"/%E5%85%B3%E4%BA%8E%E9%87%8F%E5%AD%90%E5%AE%87%E5%AE%99%E7%9A%8410%E4%B8%AA%E8%AF%AF%E5%8C%BA/"},{"categories":["安全"],"content":"基础 ","date":"2020-02-07","objectID":"/web%E5%AE%89%E5%85%A8/:0:0","tags":["安全","web"],"title":"web安全笔记","uri":"/web%E5%AE%89%E5%85%A8/"},{"categories":["安全"],"content":"前端与后端知识 ","date":"2020-02-07","objectID":"/web%E5%AE%89%E5%85%A8/:1:0","tags":["安全","web"],"title":"web安全笔记","uri":"/web%E5%AE%89%E5%85%A8/"},{"categories":["安全"],"content":"web漏洞 ","date":"2020-02-07","objectID":"/web%E5%AE%89%E5%85%A8/:2:0","tags":["安全","web"],"title":"web安全笔记","uri":"/web%E5%AE%89%E5%85%A8/"},{"categories":["安全"],"content":"XSS ","date":"2020-02-07","objectID":"/web%E5%AE%89%E5%85%A8/:2:1","tags":["安全","web"],"title":"web安全笔记","uri":"/web%E5%AE%89%E5%85%A8/"},{"categories":["安全"],"content":"CSRF ","date":"2020-02-07","objectID":"/web%E5%AE%89%E5%85%A8/:2:2","tags":["安全","web"],"title":"web安全笔记","uri":"/web%E5%AE%89%E5%85%A8/"},{"categories":["安全"],"content":"点击劫持 ","date":"2020-02-07","objectID":"/web%E5%AE%89%E5%85%A8/:2:3","tags":["安全","web"],"title":"web安全笔记","uri":"/web%E5%AE%89%E5%85%A8/"},{"categories":["安全"],"content":"URL跳转 ","date":"2020-02-07","objectID":"/web%E5%AE%89%E5%85%A8/:2:4","tags":["安全","web"],"title":"web安全笔记","uri":"/web%E5%AE%89%E5%85%A8/"},{"categories":["安全"],"content":"SQL注入 ","date":"2020-02-07","objectID":"/web%E5%AE%89%E5%85%A8/:2:5","tags":["安全","web"],"title":"web安全笔记","uri":"/web%E5%AE%89%E5%85%A8/"},{"categories":["安全"],"content":"命令注入 ","date":"2020-02-07","objectID":"/web%E5%AE%89%E5%85%A8/:2:6","tags":["安全","web"],"title":"web安全笔记","uri":"/web%E5%AE%89%E5%85%A8/"},{"categories":["安全"],"content":"上传下载漏洞 ","date":"2020-02-07","objectID":"/web%E5%AE%89%E5%85%A8/:2:7","tags":["安全","web"],"title":"web安全笔记","uri":"/web%E5%AE%89%E5%85%A8/"},{"categories":["安全"],"content":"web安全工具 ","date":"2020-02-07","objectID":"/web%E5%AE%89%E5%85%A8/:3:0","tags":["安全","web"],"title":"web安全笔记","uri":"/web%E5%AE%89%E5%85%A8/"},{"categories":["安全"],"content":"浏览器 Chrome Firefox(hackbar,cookie manager) IE ","date":"2020-02-07","objectID":"/web%E5%AE%89%E5%85%A8/:3:1","tags":["安全","web"],"title":"web安全笔记","uri":"/web%E5%AE%89%E5%85%A8/"},{"categories":["安全"],"content":"代理抓包 Burpsuite Charles Fiddler ","date":"2020-02-07","objectID":"/web%E5%AE%89%E5%85%A8/:3:2","tags":["安全","web"],"title":"web安全笔记","uri":"/web%E5%AE%89%E5%85%A8/"},{"categories":["安全"],"content":"漏洞扫描 御剑 AWVS Netsparker APPScan sqlmap ","date":"2020-02-07","objectID":"/web%E5%AE%89%E5%85%A8/:3:3","tags":["安全","web"],"title":"web安全笔记","uri":"/web%E5%AE%89%E5%85%A8/"},{"categories":["安全"],"content":"暴力破解 ZAP ","date":"2020-02-07","objectID":"/web%E5%AE%89%E5%85%A8/:3:4","tags":["安全","web"],"title":"web安全笔记","uri":"/web%E5%AE%89%E5%85%A8/"},{"categories":["安全"],"content":"实战 DVWA ","date":"2020-02-07","objectID":"/web%E5%AE%89%E5%85%A8/:4:0","tags":["安全","web"],"title":"web安全笔记","uri":"/web%E5%AE%89%E5%85%A8/"},{"categories":["python"],"content":"利用init破解权限和免注册com #coding=utf-8 from ctypes import windll from comtypes import client #加载init.dll Reg = windll.LoadLibrary(\"./init.dll\") Reg.init() dm=client.CreateObject(\"dm.dmsoft\") print(dm.ver()) dm.MoveTO(10,10) 附件 ","date":"2020-02-03","objectID":"/python%E8%B0%83%E7%94%A8%E5%A4%A7%E6%BC%A0%E6%8F%92%E4%BB%B6/:1:0","tags":["python","dll"],"title":"python调用大漠插件","uri":"/python%E8%B0%83%E7%94%A8%E5%A4%A7%E6%BC%A0%E6%8F%92%E4%BB%B6/"},{"categories":["rust"],"content":"rust导出dll ","date":"2020-02-02","objectID":"/rust%E5%AF%BC%E5%87%BAdll/:1:0","tags":["rust","dll"],"title":"rust导出Dll","uri":"/rust%E5%AF%BC%E5%87%BAdll/"},{"categories":["rust"],"content":"首先创建lib项目 cargo new addlib -lib ","date":"2020-02-02","objectID":"/rust%E5%AF%BC%E5%87%BAdll/:1:1","tags":["rust","dll"],"title":"rust导出Dll","uri":"/rust%E5%AF%BC%E5%87%BAdll/"},{"categories":["rust"],"content":"编辑lib.rs //添加一个标记 #[no_mangle]，防止编译器在编译的时候，重命名函数。 #[no_mangle]//pub 公开 extern,导出 //\"stdcall\"是调用约定ABI，rust支持stdcall，aapcs，cdecl，fastcall，vectorcall，Rust，rust-intrinsic，system，C，win64，sysv64 pubextern\"stdcall\"fn add(a: i32,b:i32)-\u003e i32 {returna+b;} ","date":"2020-02-02","objectID":"/rust%E5%AF%BC%E5%87%BAdll/:1:2","tags":["rust","dll"],"title":"rust导出Dll","uri":"/rust%E5%AF%BC%E5%87%BAdll/"},{"categories":["rust"],"content":"编辑cargo.toml，添加 [lib] name=\"addlib\" crate-type = [\"cdylib\"] ","date":"2020-02-02","objectID":"/rust%E5%AF%BC%E5%87%BAdll/:1:3","tags":["rust","dll"],"title":"rust导出Dll","uri":"/rust%E5%AF%BC%E5%87%BAdll/"},{"categories":["rust"],"content":"终端运行 cargo build --release 编译成功之后会在相关目录生成动态库文件。 ","date":"2020-02-02","objectID":"/rust%E5%AF%BC%E5%87%BAdll/:1:4","tags":["rust","dll"],"title":"rust导出Dll","uri":"/rust%E5%AF%BC%E5%87%BAdll/"},{"categories":["rust"],"content":"官网下载初始化包 官网 ","date":"2020-02-01","objectID":"/rust%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/:1:0","tags":["rust","编程"],"title":"rust环境配置","uri":"/rust%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"categories":["rust"],"content":"根据初始化包安装对应的工具 主要安装rustup和cargo工具链 ","date":"2020-02-01","objectID":"/rust%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/:2:0","tags":["rust","编程"],"title":"rust环境配置","uri":"/rust%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"categories":["rust"],"content":"国内原因换源 ","date":"2020-02-01","objectID":"/rust%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/:3:0","tags":["rust","编程"],"title":"rust环境配置","uri":"/rust%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"categories":["rust"],"content":"rustup源 linux $ # for bash $ echo 'export RUSTUP_DIST_SERVER=https://mirrors.tuna.tsinghua.edu.cn/rustup' \u003e\u003e ~/.bash_profile windows 修改环境变量： 变量名为 RUSTUP_DIST_SERVER 变量值为 https://mirrors.tuna.tsinghua.edu.cn/rustup ","date":"2020-02-01","objectID":"/rust%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/:3:1","tags":["rust","编程"],"title":"rust环境配置","uri":"/rust%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"categories":["rust"],"content":"cargo源 windows # 新建 %USERPROFILE%\\.cargo\\config [source.crates-io] replace-with = \"rustcc\" [source.rustcc] registry = \"https://code.aliyun.com/rustcc/crates.io-index\" linux tee $HOME/.cargo/config \u003c\u003c-'EOF' [source.crates-io] replace-with = \"rustcc\" [source.rustcc] registry = \"https://code.aliyun.com/rustcc/crates.io-index\" ","date":"2020-02-01","objectID":"/rust%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/:3:2","tags":["rust","编程"],"title":"rust环境配置","uri":"/rust%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"categories":["rust"],"content":"配置ide 安装vscode后，安装rust(rls)插件,用cargo new hello_cargo新建工程文件，打开工程按照提示安装rls等工具。 调试环境，windows安装C/C++插件，linux安装codelldb插件 配置launch.json调试文件如下： { \"version\": \"0.2.0\", \"configurations\": [ \"name\": \"Debug\", \"type\": \"cppvsdbg\", \"request\": \"launch\", //调试程序位置 \"program\": \"${workspaceFolder}/target/debug/YOUR_EXECUTABLE.exe\", \"args\": [], \"stopAtEntry\": false, \"externalConsole\": false, \"preLaunchTask\": \"cargo build\", \"type\": \"cppvsdbg\", // rust源码文件 \"sourceFileMap\": { \"/rustc/4560ea788cb760f0a34127156c78e2552949f734\": \"${env:HOME}${env:USERPROFILE}\\\\.rustup\\\\toolchains\\\\stable-x86_64-pc-windows-msvc\\\\lib\\\\rustlib\\\\src\\\\rust\" } ] } rust中文文档 ","date":"2020-02-01","objectID":"/rust%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/:4:0","tags":["rust","编程"],"title":"rust环境配置","uri":"/rust%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"categories":["ssh"],"content":"SSH服务器 ","date":"2019-11-13","objectID":"/windows%E5%BC%80%E5%90%AFssh%E6%9C%8D%E5%8A%A1%E5%99%A8/:0:0","tags":["windows","ssh"],"title":"windows开启SSH服务器","uri":"/windows%E5%BC%80%E5%90%AFssh%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["ssh"],"content":"安装 openssh 设置-应用-应用和功能-管理可选功能-添加功能-OpenSSH 服务器 ","date":"2019-11-13","objectID":"/windows%E5%BC%80%E5%90%AFssh%E6%9C%8D%E5%8A%A1%E5%99%A8/:1:0","tags":["windows","ssh"],"title":"windows开启SSH服务器","uri":"/windows%E5%BC%80%E5%90%AFssh%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["ssh"],"content":"开启SSH 服务 PowerShell 管理员运行： 启动 SSH 服务net start sshd net start sshd 启动成功显示： OpenSSH SSH Server 服务正在启动 . OpenSSH SSH Server 服务已经启动成功。 停止 SSH 服务net stop sshd net stop sshd OpenSSH SSH Server 服务已成功停止。 ##　在 Windows 中为 OpenSSH 配置默认 shell PowerShell 管理员运行： New-ItemProperty -Path \"HKLM:\\SOFTWARE\\OpenSSH\" -Name DefaultShell -Value \"C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe\" -PropertyType String -Force SSH客户端 命令ssh username@127.0.0.1即ssh 用户名@用户ip ","date":"2019-11-13","objectID":"/windows%E5%BC%80%E5%90%AFssh%E6%9C%8D%E5%8A%A1%E5%99%A8/:2:0","tags":["windows","ssh"],"title":"windows开启SSH服务器","uri":"/windows%E5%BC%80%E5%90%AFssh%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["C++"],"content":"调用约定 _stdcall,_cdecl _stdcall调用 按C编译方式，_stdcall调用约定在输出函数名前面加下划线，后面加“@”符号和参数的字节数，形如_func@12 _cdecl调用 _cdecl是C/C++的缺省调用方式，参数采用从右到左的压栈方式，由调用者完成压栈操作 ，传送参数的内存栈由调用者维护。 _cedcl约定的函数只能被C/C++调用，每一个调用它的函数都包含清空堆栈的代码，所以产生的可执行文件大小会比调用_stdcall函数的大。 按C编译方式，_cdecl调用约定仅在输出函数名前面加下划线，形如_functionname。 区别 在跨（开发） 平台的调用中，我们都使用_stdcall（虽然有时是以WINAPI的样子出现）。当遇到这样的函数如 fprintf()它的参数是可变的，不定长的，被调用者事先无法知道参数的长度，事后的清除工作也无法正常的进行，因此，这种情况我们只能使用 _cdecl。如果你的程序中没有涉及可变参数，最好使用__stdcall关键字。 //add.cpp int __stdcall Add(int a, int b) { return a + b; } //__stdcall可不写,但是要在项目中设置 导出Add.dll方式有两种 ","date":"2019-11-08","objectID":"/vc-%E5%AF%BC%E5%87%BAdll%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95/:0:0","tags":["c++","dll"],"title":"VC++导出Dll常见方法","uri":"/vc-%E5%AF%BC%E5%87%BAdll%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95/"},{"categories":["C++"],"content":"1-模块定义(.def) 文件声明,函数名不变化 LIBRARY Add EXPORTS Add @1 ","date":"2019-11-08","objectID":"/vc-%E5%AF%BC%E5%87%BAdll%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95/:1:0","tags":["c++","dll"],"title":"VC++导出Dll常见方法","uri":"/vc-%E5%AF%BC%E5%87%BAdll%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95/"},{"categories":["C++"],"content":"2-导出函数 _declspec(dllexport) //add.h头文件 #ifndef ADD_H #define ADD_H #ifdef __cplusplus // if used by C++ code extern \"C\" { // we need to export the C interface #endif __declspec(dllexport) int Add(int a, int b); #ifdef __cplusplus } #endif #endif ","date":"2019-11-08","objectID":"/vc-%E5%AF%BC%E5%87%BAdll%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95/:2:0","tags":["c++","dll"],"title":"VC++导出Dll常见方法","uri":"/vc-%E5%AF%BC%E5%87%BAdll%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95/"},{"categories":["git"],"content":"git push常见问题 ","date":"2019-10-08","objectID":"/git-psuh%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/:0:0","tags":["git","error"],"title":"git push常见问题","uri":"/git-psuh%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["git"],"content":"fatal: refusing to merge unrelated histories 在git pull或者git push中都有可能会遇到，这是因为两个分支没有取得关系，解决办法是在操作命令后面加--allow-unrelated-histories ","date":"2019-10-08","objectID":"/git-psuh%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/:1:0","tags":["git","error"],"title":"git push常见问题","uri":"/git-psuh%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["git"],"content":"error: failed to push some refs to 解决方案：首先git pull origin master --allow-unrelated-histories ","date":"2019-10-08","objectID":"/git-psuh%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/:2:0","tags":["git","error"],"title":"git push常见问题","uri":"/git-psuh%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["数学"],"content":"计算的极限（零） 计算的极限（一）：所有机器的机器，与无法计算的问题 计算的极限（二）：自我指涉与不可判定 计算的极限（三）：函数构成的世界 计算的极限（四）：机械计算的圭臬 计算的极限（五）：有限的障壁 计算的极限（六）：无穷的彼岸 计算的极限（七）：宛如神谕 计算的极限（八）：符号的框架 计算的极限（九）：叹息与奋斗 计算的极限（十）：无限绵延的层级 计算的极限（十一）：黄金时代 计算的极限（十二）：不会出错的程序 计算的极限（十三）：数字空间的幽灵 人算不如天算：内存中的进化 人算不如天算：微分方程，分子，有限差分方法 人算不如天算：电脑中的微型大脑 希尔伯特之梦，以及梦的破灭 纳什：无常命运中的美丽心灵 有限单群：一段百年征程 素数并不孤独 从玩具陀螺到终极理论 小朋友的涂鸦 解构与复原：望月新一与他的证明 数和符号的轨迹：2020年阿贝尔奖解析 镜城 废城 闭城 ","date":"2019-04-26","objectID":"/%E8%AE%A1%E7%AE%97%E7%9A%84%E6%9E%81%E9%99%90/:0:0","tags":["数学","历史"],"title":"计算的极限","uri":"/%E8%AE%A1%E7%AE%97%E7%9A%84%E6%9E%81%E9%99%90/"},{"categories":["哲学"],"content":"哥德尔不完备定理 在数理逻辑中，哥德尔不完备定理是库尔特·哥德尔于1931年证明并发表的两条定理。简单地说，第一条定理指出： 任何兼容的形式系统，只要蕴涵皮亚诺算术公理，就可以在其中构造在体系中不能被证明的真命题，因此通过推演不能得到所有真命题（即体系是不完备的）。 把第一条定理的证明过程在体系内部形式化后，哥德尔证明了第二条定理。该定理指出： 任何逻辑自洽的形式系统，只要蕴涵皮亚诺算术公理，它就不能用于证明它本身的兼容性。 道德经第一章 “道”如果可以用言语来表述，那它就是常“道”(“道”是可以用言语来表述的，它并非一般的“道”)；“名”如果可以用文辞去命名，那它就是常“名”(“名”也是可以说明的，它并非普通的“名”)。“无”可以用来表述天地浑沌未开之际的状况；而“有”，则是宇宙万物产生之本原的命名。因此，要常从“无”中去观察领悟“道”的奥妙；要常从“有”中去观察体会“道”的端倪。无与有这两者，来源相同而名称相异，都可以称之为玄妙、深远。它不是一般的玄妙、深奥，而是玄妙又玄妙、深远又深远，是宇宙天地万物之奥妙的总门(从“有名”的奥妙到达无形的奥妙，“道”是洞悉一切奥妙变化的门径)。 人的“确定感” 人们所坚持的完全确定的态度会使他们放弃对不同意见的思考，而这种“确定感”往往是一个彻底的错误；如果人们开始质疑“确定感”的本质，意识到人类的思维的局限性，那么，我们可能就会展现出某种程度的宽容，并乐于思考不同的观点。一旦人们思想渐趋开明，就可能为许多看似无法解决的困境提供解决的契机。 感悟 人们总是相信自己所相信，所以说出的话也是自以为对的，这不仅在体现在人们的生活中，而且也体现在科学当中，不同的是科学可以改正自己的错误，但生活却不一样，因为没有一个标准，所以人们认为自己就是对的，他们相信社会带给他们的价值观，周围环境给他们的价值观，这样他们就没有思考的负担，随大流走完一生，却不知自己一生都在干什么。 ","date":"2019-04-25","objectID":"/%E4%BA%BA%E7%B1%BB%E6%80%9D%E7%BB%B4%E7%9A%84%E5%B1%80%E9%99%90/:0:0","tags":["哲学"],"title":"思维局限","uri":"/%E4%BA%BA%E7%B1%BB%E6%80%9D%E7%BB%B4%E7%9A%84%E5%B1%80%E9%99%90/"},{"categories":["JavaScript"],"content":"闭包 ","date":"2019-04-16","objectID":"/%E9%97%AD%E5%8C%85/:0:0","tags":["JavaScript","编程"],"title":"闭包","uri":"/%E9%97%AD%E5%8C%85/"},{"categories":["JavaScript"],"content":"定义 闭包是由函数以及创建该函数的词法环境组合而成。这个环境包含了这个闭包创建时所能访问的所有局部变量。 ","date":"2019-04-16","objectID":"/%E9%97%AD%E5%8C%85/:1:0","tags":["JavaScript","编程"],"title":"闭包","uri":"/%E9%97%AD%E5%8C%85/"},{"categories":["JavaScript"],"content":"实质 将函数当作对象处理，栈（Stack）内存没有释放，没有完成GC操作 ","date":"2019-04-16","objectID":"/%E9%97%AD%E5%8C%85/:2:0","tags":["JavaScript","编程"],"title":"闭包","uri":"/%E9%97%AD%E5%8C%85/"},{"categories":["JavaScript"],"content":"实例 ","date":"2019-04-16","objectID":"/%E9%97%AD%E5%8C%85/:3:0","tags":["JavaScript","编程"],"title":"闭包","uri":"/%E9%97%AD%E5%8C%85/"},{"categories":["JavaScript"],"content":"共享函数定义 function makeAdder(x) { return function(y) { return x + y; }; } var add5 = makeAdder(5); var add10 = makeAdder(10); //在makeAdder中共享函数定义 console.log(add5(2)); // 7 console.log(add10(2)); // 12 ","date":"2019-04-16","objectID":"/%E9%97%AD%E5%8C%85/:3:1","tags":["JavaScript","编程"],"title":"闭包","uri":"/%E9%97%AD%E5%8C%85/"},{"categories":["JavaScript"],"content":"模拟私有方法 var makeCounter = function() { var privateCounter = 0; function changeBy(val) { privateCounter += val; } return { increment: function() { changeBy(1); }, decrement: function() { changeBy(-1); }, value: function() { return privateCounter; } } }; var Counter1 = makeCounter(); var Counter2 = makeCounter(); console.log(Counter1.value()); /* logs 0 */ Counter1.increment(); Counter1.increment(); console.log(Counter1.value()); /* logs 2 */ Counter1.decrement(); console.log(Counter1.value()); /* logs 1 */ console.log(Counter2.value()); /* logs 0 */ ","date":"2019-04-16","objectID":"/%E9%97%AD%E5%8C%85/:3:2","tags":["JavaScript","编程"],"title":"闭包","uri":"/%E9%97%AD%E5%8C%85/"},{"categories":["JavaScript"],"content":"解决var作用域问题 \u003cp id=\"help\"\u003eHelpful notes will appear here\u003c/p\u003e \u003cp\u003eE-mail: \u003cinput type=\"text\" id=\"email\" name=\"email\"\u003e\u003c/p\u003e \u003cp\u003eName: \u003cinput type=\"text\" id=\"name\" name=\"name\"\u003e\u003c/p\u003e \u003cp\u003eAge: \u003cinput type=\"text\" id=\"age\" name=\"age\"\u003e\u003c/p\u003e \u003cscript\u003e function showHelp(help) { document.getElementById('help').innerHTML = help; } function setupHelp() { var helpText = [ {'id': 'email', 'help': 'Your e-mail address'}, {'id': 'name', 'help': 'Your full name'}, {'id': 'age', 'help': 'Your age (you must be over 16)'} ]; for (var i = 0; i \u003c helpText.length; i++) { var item = helpText[i]; document.getElementById(item.id).onfocus = function() { showHelp(item.help); } } } setupHelp(); \u003c/script\u003e 代码运行后，循环在事件触发前执行完毕，item全部指向最后一项 解决方案：使用闭包创建私有变量 function showHelp(help) { document.getElementById('help').innerHTML = help; } function setupHelp() { var helpText = [ {'id': 'email', 'help': 'Your e-mail address'}, {'id': 'name', 'help': 'Your full name'}, {'id': 'age', 'help': 'Your age (you must be over 16)'} ]; for (var i = 0; i \u003c helpText.length; i++) { (function() { var item = helpText[i]; document.getElementById(item.id).onfocus = function() { showHelp(item.help); } })(); // 马上把当前循环项的item与事件回调相关联起来 } } setupHelp(); ES6 let方案 function showHelp(help) { document.getElementById('help').innerHTML = help; } function setupHelp() { var helpText = [ {'id': 'email', 'help': 'Your e-mail address'}, {'id': 'name', 'help': 'Your full name'}, {'id': 'age', 'help': 'Your age (you must be over 16)'} ]; for (var i = 0; i \u003c helpText.length; i++) { let item = helpText[i]; document.getElementById(item.id).onfocus = function() { showHelp(item.help); } } } setupHelp(); ","date":"2019-04-16","objectID":"/%E9%97%AD%E5%8C%85/:3:3","tags":["JavaScript","编程"],"title":"闭包","uri":"/%E9%97%AD%E5%8C%85/"},{"categories":["JavaScript"],"content":"性能问题 使用闭包会加大内存消耗和减慢脚本的处理速度，因此应该尽量避免使用闭包。 总结自MDN ","date":"2019-04-16","objectID":"/%E9%97%AD%E5%8C%85/:4:0","tags":["JavaScript","编程"],"title":"闭包","uri":"/%E9%97%AD%E5%8C%85/"},{"categories":["JavaScript"],"content":"关于 ES6 中的箭头函数，网上有很多文章解释其作用和语法，如果你刚开始接触 ES6，可以从这里开始。任何事物都具有两面性，语言的新特性常常被误解、滥用，比如箭头函数的使用就存在很多误区。接下来，笔者会通过实例介绍该避免使用箭头函数的场景，以及在这些场景下该如何使用函数表达式（function expressions）、函数声明或者方法简写（shorthand method）来保障代码正确性和可读性。 ","date":"2019-04-13","objectID":"/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/:0:0","tags":["JavaScript","编程"],"title":"箭头函数","uri":"/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"},{"categories":["JavaScript"],"content":"1. 定义对象方法 JS 中对象方法的定义方式是在对象上定义一个指向函数的属性，当方法被调用的时候，方法内的 this 就会指向方法所属的对象。 1.1 定义字面量方法 因为箭头函数的语法很简洁，可能不少同学会忍不住用它来定义字面量方法，比如下面的例子 JS Bin： const calculator = { array: [1, 2, 3], sum: () =\u003e { console.log(this === window); // =\u003e true return this.array.reduce((result, item) =\u003e result + item); } }; console.log(this === window); // =\u003e true // Throws \"TypeError: Cannot read property 'reduce' of undefined\" calculator.sum(); calculator.sum 使用箭头函数来定义，但是调用的时候会抛出 TypeError，因为运行时 this.array 是未定义的，调用 calculator.sum 的时候，执行上下文里面的 this 仍然指向的是 window，原因是箭头函数把函数上下文绑定到了 window 上，this.array 等价于 window.array，显然后者是未定义的。 解决的办法是，使用函数表达式或者方法简写（ES6 中已经支持）来定义方法，这样能确保 this 是在运行时是由包含它的上下文决定的，修正后的代码如下 JS Bin： const calculator = { array: [1, 2, 3], sum() { console.log(this === calculator); // =\u003e true return this.array.reduce((result, item) =\u003e result + item); } }; calculator.sum(); // =\u003e 6 这样 calculator.sum 就变成了普通函数，执行时 this 就指向 calculator 对象，自然能得到正确的计算结果。 1.2 定义原型方法 同样的规则适用于原型方法（prototype method）的定义，使用箭头函数会导致运行时的执行上下文错误，比如下面的例子 JS Bin： function Cat(name) { this.name = name; } Cat.prototype.sayCatName = () =\u003e { console.log(this === window); // =\u003e true return this.name; }; const cat = new Cat('Mew'); cat.sayCatName(); // =\u003e undefined 使用传统的函数表达式就能解决问题 JS Bin： function Cat(name) { this.name = name; } Cat.prototype.sayCatName = function () { console.log(this === cat); // =\u003e true return this.name; }; const cat = new Cat('Mew'); cat.sayCatName(); // =\u003e 'Mew' sayCatName 变成普通函数之后，被调用时的执行上下文就会指向新创建的 cat 实例。 ","date":"2019-04-13","objectID":"/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/:1:0","tags":["JavaScript","编程"],"title":"箭头函数","uri":"/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"},{"categories":["JavaScript"],"content":"2. 定义事件回调函数 this 是 JS 中很强大的特性，可以通过多种方式改变函数执行上下文，JS 内部也有几种不同的默认上下文指向，但普适的规则是在谁上面调用函数 this 就指向谁，这样代码理解起来也很自然，读起来就像在说，某个对象上正在发生某件事情。 但是，箭头函数在声明的时候就绑定了执行上下文，要动态改变上下文是不可能的，在需要动态上下文的时候它的弊端就凸显出来。比如在客户端编程中常见的 DOM 事件回调函数（event listenner）绑定，触发回调函数时 this 指向当前发生事件的 DOM 节点，而动态上下文这个时候就非常有用，比如下面这段代码试图使用箭头函数来作事件回调函数 JS Bin： const button = document.getElementById('myButton'); button.addEventListener('click', () =\u003e { console.log(this === window); // =\u003e true this.innerHTML = 'Clicked button'; }); 在全局上下文下定义的箭头函数执行时 this 会指向 window，当单击事件发生时，浏览器会尝试用 button 作为上下文来执行事件回调函数，但是箭头函数预定义的上下文是不能被修改的，这样 this.innerHTML 就等价于 window.innerHTML，而后者是没有任何意义的。 使用函数表达式就可以在运行时动态的改变 this，修正后的代码 JS Bin： const button = document.getElementById('myButton'); button.addEventListener('click', function() { console.log(this === button); // =\u003e true this.innerHTML = 'Clicked button'; }); 当用户单击按钮时，事件回调函数中的 this 实际指向 button，这样的 this.innerHTML = ‘Clicked button’ 就能按照预期修改按钮中的文字。 ","date":"2019-04-13","objectID":"/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/:2:0","tags":["JavaScript","编程"],"title":"箭头函数","uri":"/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"},{"categories":["JavaScript"],"content":"3. 定义构造函数 构造函数中的 this 指向新创建的对象，当执行 new Car() 的时候，构造函数 Car 的上下文就是新创建的对象，也就是说 this instanceof Car === true。显然，箭头函数是不能用来做构造函数， 实际上 JS 会禁止你这么做，如果你这么做了，它就会抛出异常。 换句话说，箭头构造函数的执行并没有任何意义，并且是有歧义的。比如，当我们运行下面的代码 JS Bin： const Message = (text) =\u003e { this.text = text; }; // Throws \"TypeError: Message is not a constructor\" const helloMessage = new Message('Hello World!'); 构造新的 Message 实例时，JS 引擎抛了错误，因为 Message 不是构造函数。在笔者看来，相比旧的 JS 引擎在出错时悄悄失败的设计，ES6 在出错时给出具体错误消息是非常不错的实践。可以通过使用函数表达式或者函数声明 来声明构造函数修复上面的例子 JS Bin： const Message = function(text) { this.text = text; }; const helloMessage = new Message('Hello World!'); console.log(helloMessage.text); // =\u003e 'Hello World!' ","date":"2019-04-13","objectID":"/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/:3:0","tags":["JavaScript","编程"],"title":"箭头函数","uri":"/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"},{"categories":["JavaScript"],"content":"4. 追求过短的代码 箭头函数允许你省略参数两边的括号、函数体的花括号、甚至 return 关键词，这对编写更简短的代码非常有帮助。这让我想起大学计算机老师给学生留过的有趣作业：看谁能使用 C 语言编写出最短的函数来计算字符串的长度，这对学习和探索新语言特性是个不错的法子。但是，在实际的软件工程中，代码写完之后会被很多工程师阅读，真正的 write once, read many times，在代码可读性方面，最短的代码可能并不总是最好的。一定程度上，压缩了太多逻辑的简短代码，阅读起来就没有那么直观，比如下面的例子 JS Bin： const multiply = (a, b) =\u003e b === undefined ? b =\u003e a * b : a * b; const double = multiply(2); double(3); // =\u003e 6 multiply(2, 3); // =\u003e 6 multiply 函数会返回两个数字的乘积或者返回一个可以继续调用的固定了一个参数的函数。代码看起来很简短，但大多数人第一眼看上去可能无法立即搞清楚它干了什么，怎么让这段代码可读性更高呢？有很多办法，可以在箭头函数中加上括号、条件判断、返回语句，或者使用普通的函数 JS Bin： function multiply(a, b) { if (b === undefined) { return function (b) { return a * b; } } return a * b; } const double = multiply(2); double(3); // =\u003e 6 multiply(2, 3); // =\u003e 6 为了让代码可读性更高，在简短和啰嗦之间把握好平衡是非常有必要的。 ","date":"2019-04-13","objectID":"/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/:4:0","tags":["JavaScript","编程"],"title":"箭头函数","uri":"/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"},{"categories":["JavaScript"],"content":"5. 总结 箭头函数无疑是 ES6 带来的重大改进，在正确的场合使用箭头函数能让代码变的简洁、短小，但某些方面的优势在另外一些方面可能就变成了劣势，在需要动态上下文的场景中使用箭头函数你要格外的小心，这些场景包括：定义对象方法、定义原型方法、定义构造函数、定义事件回调函数。 ","date":"2019-04-13","objectID":"/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/:5:0","tags":["JavaScript","编程"],"title":"箭头函数","uri":"/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"},{"categories":["Termux"],"content":"Termux 高级终端安装使用配置教程,这篇文章拖了有小半年.因为网上相关的文章相对来说还是比较少的,恰好今天又刷了机,所以就特意来总结一下,希望本文可以帮助到其他的小伙伴.发挥Android平台更大的DIY空间. 简介 Termux是一个Android下一个高级的终端模拟器,开源且不需要root,支持apt管理软件包，十分方便安装软件包,完美支持Python,PHP,Ruby,Go,Nodejs,MySQL等。随着智能设备的普及和性能的不断提升，如今的手机、平板等的硬件标准已达到了初级桌面计算机的硬件标准,用心去打造完全可以把手机变成一个强大的工具. 官网 Github项目地址 Google Play下载地址 Google Play下载的版本比酷安要新,有能力建议下载Google PLay版本的. 基本操作 ","date":"2019-03-18","objectID":"/termux/:0:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"长按屏幕 显示菜单项（包括复制、粘贴、更多），此时屏幕出现可选择的复制光标 长按屏幕 ├── COPY:复制 ├── PASTE:更多 ├── More:更多 ├── Select URL: 选择网址 └── Share transcipt: 分享命令脚本 └── Reset: 重置 └── Kill process: 杀掉当前终端会话进程 └── Style: 风格配色 └── Help: 帮助文档 ","date":"2019-03-18","objectID":"/termux/:1:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"从左向右滑动 显示隐藏式导航栏，可以新建、切换、重命名会话session和调用弹出输入法 ","date":"2019-03-18","objectID":"/termux/:2:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"显示扩展功能按键 扩展功能键是什么?就是PC端常用的按键如:ESC键，CTR键，TAB键,但是手机上难以操作的一些按键. 效果图 ","date":"2019-03-18","objectID":"/termux/:3:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"方法一 从左向右滑动,显示隐藏式导航栏,长按左下角的KEYBOARD. ","date":"2019-03-18","objectID":"/termux/:3:1","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"方法二 使用Termux快捷键:音量++Q键 常用快捷键\" 常用快捷键\"\u003e常用快捷键 Ctrl键是终端用户常用的按键 - 但大多数触摸键盘都没有这个按键。为此，Termux使用音量减小按钮来模拟Ctrl键。 例如，在触摸键盘上按音量减小+ L发送与在硬件键盘上按Ctrl + L相同的输入。 Ctrl+A -\u003e 将光标移动到行首 Ctrl+C -\u003e 中止当前进程 Ctrl+D -\u003e 注销终端会话 Ctrl+E -\u003e 将光标移动到行尾 Ctrl+K -\u003e 从光标删除到行尾 Ctrl+L -\u003e 清除终端 Ctrl+Z -\u003e 挂起（发送SIGTSTP到）当前进程 音量加键也可以作为产生特定输入的特殊键. 音量加+E -\u003e Esc键 音量加+T -\u003e Tab键 音量加+1 -\u003e F1（和音量增加+ 2→F2等） 音量加+0 -\u003e F10 音量加+B -\u003e Alt + B，使用readline时返回一个单词 音量加+F -\u003e Alt + F，使用readline时转发一个单词 音量加+X -\u003e Alt+X 音量加+W -\u003e 向上箭头键 音量加+A -\u003e 向左箭头键 音量加+S -\u003e 向下箭头键 音量加+D -\u003e 向右箭头键 音量加+L -\u003e | （管道字符） 音量加+H -\u003e 〜（波浪号字符） 音量加+U -\u003e _ (下划线字符) 音量加+P -\u003e 上一页 音量加+N -\u003e 下一页 音量加+. -\u003e Ctrl + \\（SIGQUIT） 音量加+V -\u003e 显示音量控制 音量加+Q -\u003e 显示额外的按键视图 基本命令 Termux除了支持apt命令外,还在此基础上封装了pkg命令,pkg命令向下兼容apt命令.apt命令大家应该都比较熟悉了,这里直接简单的介绍下pkg命令: pkg search \u003cquery\u003e 搜索包 pkg install\u003cpackage\u003e 安装包 pkg uninstall \u003cpackage\u003e 卸载包 pkg reinstall \u003cpackage\u003e 重新安装包 pkg update 更新源 pkg upgrade 升级软件包 pkg list-all 列出可供安装的所有包 pkg list-installed 列出已经安装的包 pkg shoe \u003cpackage\u003e 显示某个包的详细信息 pkg files \u003cpackage\u003e 显示某个包的相关文件夹路径 目录环境结构 ~ \u003eecho$HOME /data/data/com.termux/files/home ~ \u003eecho$PREFIX /data/data/com.termux/files/usr ~ \u003eecho$TMPPREFIX /data/data/com.termux/files/usr/tmp/zsh 长期使用Linux的朋友可能会发现，这个HOME路径看上去可能不太一样,为了方便,Termux 提供了一个特殊的环境变量:PREFIX 更换国内源 更换Termux清华大学源,加快软件包下载速度. ","date":"2019-03-18","objectID":"/termux/:3:2","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"设置默认编辑器 export EDITOR=vi ","date":"2019-03-18","objectID":"/termux/:4:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"编辑源文件 apt edit-sources 将原来的https://termux.net官方源替换为http://mirrors.tuna.tsinghua.edu.cn/termux 保存并退出 ","date":"2019-03-18","objectID":"/termux/:5:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"直接编辑源文件 上面是官方推荐的方法,其实还有更简单的方法,类似于Linux下直接去编辑源文件: vi$PREFIX/etc/apt/sources.list 安装基本工具 pkg update pkg install vim curl wgetgit unzip unrar Termux优化 ","date":"2019-03-18","objectID":"/termux/:6:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"终端配色 主要使用了zsh来替代bash作为默认shell. 使用一键安装脚本来安装,一步到位,顺便启动了外置存储,可以直接访问SD卡下的目录. 执行下面这个命令确保已经安装好了curl sh -c \"$(curl -fsSL https://github.com/Cabbagec/termux-ohmyzsh/raw/master/install.sh)\" Android6.0以上会弹框确认是否授权,允许授权后Termux可以方便的访问SD卡文件. 脚本允许后先后有如下两个选项: Enter a number, leave blank to not to change: 14 Enter a number, leave blank to not to change: 6 分别选择背景色和字体 想要继续更改挑选配色的话,继续运行脚本来再次筛选: $ ~/termux-ohmyzsh/install.sh exit重启sessions会话生效配置 ","date":"2019-03-18","objectID":"/termux/:7:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"访问外置存储优化 执行过上面的zsh一键配置脚本后,并且授予文件访问权限的话,会在家目录生成storage目录，并且生成若干目录，软连接都指向外置存储卡的相应目录 创建QQ文件夹软连接 手机上一般经常使用手机QQ来接收文件,这里为了方便文件传输,直接在storage目录下创建软链接. QQ ln -s /data/data/com.termux/files/home/storage/shared/tencent/QQfile_recv QQ TIM ln -s /data/data/com.termux/files/home/storage/shared/tencent/TIMfile_recv TIM 最后效果图如下: 这样可以直接在home目录下去访问QQ文件夹,非常方便文件的传输,大大提升了工作效率. http://mirrors.tuna.tsinghua.edu.cn/termux ","date":"2019-03-18","objectID":"/termux/:8:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"oh-my-zsh主题配色\" oh my zsh主题配色\"\u003eoh my zsh主题配色 编辑.zshrc配置文件 $ vim .zshrc 第一行可以看到,默认的主题是agnoster主题: 在.oh-my-zsh/themes目录下放着oh-my-zsh所有的主题配置文件. 下面是国光认为还不错的几款主题 agnoster robbyrussell jaischeema re5et junkfood cloud random 当然如果你是个变态的话,可以尝试random主题,每打开一个会话配色主题都是随机的. ZSH_THEME=\"random\" ","date":"2019-03-18","objectID":"/termux/:9:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"修改启动问候语 默认的启动问候语如下: 这个对于初学者有一定的帮助在前期,随着对Termux的熟悉,这个默认的问候语就会显得比较臃肿. 编辑问候语文件直接修改问候语: vim $PREFIX/etc/motd 修改完的效果如下: 这样启动新的会话的时候看上去就会简洁很多. 管理员身份 ","date":"2019-03-18","objectID":"/termux/:10:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"手机没有root 利用proot工具来模拟某些需要root的环境 pkg install proot 然后终端下面输入: termux-chroot 即可模拟root环境 在这个proot环境下面,相当于是进入了home目录,可以很方便地进行一些配置. 在管理员身份下，输入exit可回到普通用户身份。 ","date":"2019-03-18","objectID":"/termux/:11:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"手机已经root 安装tsu,这是一个su的termux版本,用来在termux上替代su: pkg install tsu 然后终端下面输入: tsu 即可切换root用户,这个时候会弹出root授权提示,给予其root权限,效果图如下: 在管理员身份下，输入exit可回到普通用户身份。 信息安全 因为termux可以很好的支持Python,所以几乎所有用Python编写的安全工具都是可以完美的运行使用的. 总的来说可玩性还是比较高的. ","date":"2019-03-18","objectID":"/termux/:12:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"Metasploit 安装Ｍetasploit Termux官方提供的自动话脚本安装方法如下: cd ～ pkg install wget wget https://Auxilus.github.io/metasploit.sh bash metasploit.sh 注　在x86平台下自动化安装失败，想在x86平台下安装的参考　官方的文档 手动去安装．　 这个过程平均耗时大约3分钟左右（使用国内的清华源的情况下）．　配置msf数据库缓存 意外发现数据库居然都配置好了，启动msfconsole会自动连接数据库了．　接下来重建数据库缓存 msf \u003e db_rebuild_cache 这个时候立刻去搜索发现缓存依然没有建立，只能使用慢速搜索，这里其实是这个缓存建立需要时间，只要稍微等待一下就可以了． 国光以前这里做过测试，缓存建立的平均时间是3分钟左右． 然后就可以实现msf秒搜索的效果了，无需等待，感觉比电脑上还要快呐　","date":"2019-03-18","objectID":"/termux/:13:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"解决metasploit启动后无法连接数据库 使用自动化脚本安装好Metasploit后使用db_status发现数据库是处于连接状态的,然后在使用db_rebuild_cache重新建立缓存,等待大约3分钟后,便可以使用快速搜索了,没毛病~ 但是 在一段日子过后,可能会出现以下情况: msfconsole [-] Failed to connect to the database: could not connect to server: Connection refused Is the server running on host \"127.0.0.1\" and accepting TCP/IP connections on port 5432? 报这个错误是因为postgresql数据库没有启动造成的.解决方法就是启动数据库: 本方法只针对termux上使用自动化脚本安装msf pg_ctl -D $PREFIX/var/lib/postgresql start 启动数据库后重新进入msfconsole会发现启动没有报错了,db_status查看下数据库连接,也正常了: ","date":"2019-03-18","objectID":"/termux/:13:1","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"Nmap\" Nmap\"\u003eNmap 端口扫描必备工具 pkg install nmap ","date":"2019-03-18","objectID":"/termux/:14:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"hydra Hydra是著名的黑客组织THC的一款开源暴力破解工具这是一个验证性质的工具，主要目的是：展示安全研究人员从远程获取一个系统认证权限。 pkg install hydra ","date":"2019-03-18","objectID":"/termux/:15:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"sslscan SSLscan主要探测基于ssl的服务，如https。SSLscan是一款探测目标服务器所支持的SSL加密算法工具。 SSlscan的代码托管在Github pkg install sslscan ","date":"2019-03-18","objectID":"/termux/:16:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"whatportis whatportis是一款可以通过服务查询默认端口，或者是通过端口查询默认服务的工具，简单易用。在渗透测试过程中，如果需要查询某个端口绑定什么服务器，或者某个应用绑定的默认端口，可以使用whatportis查询。 pip2 install whatportis ","date":"2019-03-18","objectID":"/termux/:17:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"SQLmap SQLmap是一款用来检测与利用SQL注入漏洞的免费开源工具 官方项目地址 直接git clone源码 git clone https://github.com/sqlmapproject/sqlmap.git cd sqlmap python2 sqlmap.py sqlmap支持pip安装了,所以建议直接 pip install sqlmap 来进行安装,然后终端下直接sqlmap就可以了,十分方便. ","date":"2019-03-18","objectID":"/termux/:18:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"RouterSploit RouteSploit框架是一款开源的路由器等嵌入式设备漏洞检测及利用框架。 pip2 install requests git clone https://github.com/reverse-shell/routersploit cd routersploit python2 rsf.py ","date":"2019-03-18","objectID":"/termux/:19:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"Slowloris 低带宽的DoS工具 git clone https://github.com/gkbrk/slowloris.git cd slowloris chmod +x slowloris.py ","date":"2019-03-18","objectID":"/termux/:20:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"RED-HAWK 一款采用PHP语言开发的多合一型渗透测试工具，它可以帮助我们完成信息采集、SQL漏洞扫描和资源爬取等任务。 pkg install php git clone https://github.com/Tuhinshubhra/RED_HAWK.git cd RED_HAWK php rhawk.php ","date":"2019-03-18","objectID":"/termux/:21:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"Cupp Cupp是一款用Python语言写成的可交互性的字典生成脚本。尤其适合社会工程学，当你收集到目标的具体信息后，你就可以通过这个工具来智能化生成关于目标的字典。 git clone https://github.com/Mebus/cupp.git cd cupp python2 cupp.py ","date":"2019-03-18","objectID":"/termux/:22:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"Hash-Buster Hash Buster是一个用python编写的在线破解Hash的脚本，官方说5秒内破解,速度实际测试还不错哦~ git clone https://github.com/UltimateHackers/Hash-Buster.git cd Hash-Buster python2 hash.py ","date":"2019-03-18","objectID":"/termux/:23:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"D-TECT D-TECT是一个用Python编写的先进的渗透测试工具, wordpress用户名枚举 敏感文件检测 子域名爆破 端口扫描 Wordperss扫描 XSS扫描 SQL注入扫描等 git clone https://github.com/shawarkhanethicalhacker/D-TECT.git cd D-TECT python2 d-tect.py ","date":"2019-03-18","objectID":"/termux/:24:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"WPSeku WPSeku 是一个用 Python 写的简单的 WordPress 漏洞扫描器，它可以被用来扫描本地以及远程安装的 WordPress 来找出安全问题。被评为2017年最受欢迎的十大开源黑客工具. git clone https://github.com/m4ll0k/WPSeku.git cd WPSeku pip3 install -r requirements.txt python3 wpseku.py ","date":"2019-03-18","objectID":"/termux/:25:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"XSStrike XSStrike是一种先进的XSS检测工具。它具有强大的模糊测试引擎. git clone https://github.com/UltimateHackers/XSStrike.git cd XSStrike pip2 install -r requirements.txt python2 xsstrike ","date":"2019-03-18","objectID":"/termux/:26:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"小结 因为Termux完美的支持Python和Perl等语言,所以有太多优秀的信息安全工具值得大家去发现了,这里我就不一一列举了. Python环境部署 ","date":"2019-03-18","objectID":"/termux/:27:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"安装python2-7 pkg install python2 安装完成后,使用python2命令启动python 2.7.14环境. ","date":"2019-03-18","objectID":"/termux/:28:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"安装python3 pkg install python 安装完成后,使用python命令启动python 3.6.5环境. ","date":"2019-03-18","objectID":"/termux/:29:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"升级pip版本 python2 -m pip install --upgrade pip python -m pip install --upgrade pip 这两条命令分别升级了pip2和pip3到最新版. pip版本查看 ","date":"2019-03-18","objectID":"/termux/:30:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"ipython ipython是一个python的交互式shell，支持变量自动补全，自动缩进，支持bash shell命令，内置了许多很有用的功能和函数。学习ipython将会让我们以一种更高的效率来使用python。 先安装clang,否则直接使用pip安装ipython会失败报错. pkg install clang pip install ipython pip3.6 install ipython 然后分别使用ipython和ipython2进入py2和py3控制台: ","date":"2019-03-18","objectID":"/termux/:31:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"编辑器 终端下有vim神器,并且官方也已经封装了vim-python,对vim进行了Python相关的优化. pkg install vim-python 解决termux下的vim汉字乱码 在家目录下,新建.vimrc文件 vim .vimrc 添加内容如下: set fileencodings=utf-8,gb2312,gb18030,gbk,ucs-bom,cp936,latin1 set enc=utf8 set fencs=utf8,gbk,gb2312,gb18030 然后source下变量: source .vimrc 效果图 nodejs ","date":"2019-03-18","objectID":"/termux/:32:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"安装nodejs pkg install nodejs 安装比较方便,但是在安装的时候报错了 Cannot read property \u0026#39;length\u0026#39; of undefined 查了下是这边版本的问题 官方的解决方法如下 disable concurrency in case of libuv/libuv#1459 ","date":"2019-03-18","objectID":"/termux/:33:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"解决npm安装报错 vim $PREFIX/lib/node_modules/npm/node_modules/worker-farm/lib/farm.js 我这里修改length的是4,这个好像和CPU有关,总之这里的length得指定一个数字. 然后在重新安装下npm install hexo-cli -g成功. MariaDB-MySQL-安装 MariaDB数据库管理系统是MySQL的一个分支，主要由开源社区在维护，采用GPL授权许可。开发这个分支的原因之一是：甲骨文公司收购了MySQL后，有将MySQL闭源的潜在风险，因此社区采用分支的方式来避开这个风险。 ","date":"2019-03-18","objectID":"/termux/:34:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"安装mariadb pkg install mariadb ","date":"2019-03-18","objectID":"/termux/:35:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"安装基本数据 mysql_install_db ","date":"2019-03-18","objectID":"/termux/:36:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"启动mariadb服务 mysqld 启动完成后,这个会话就一直存活,类似与debug调试一样,只有新建会话才可以操作. 关于隐藏会话可以使用nohup命令和tmux命令,这里我建议使用tmux命令 ","date":"2019-03-18","objectID":"/termux/:37:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"新建termux会话 由于mariadb安装的时候没有设置密码,当前的mariadb密码为空. mysql 直接进入mariadb数据库.输入exit退出数据库. ","date":"2019-03-18","objectID":"/termux/:38:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"修改密码\" 修改密码\"\u003e修改密码 输入一下命令,进行密码相关的安全设置: mysql_secure_installation 输入当前输入密码 因为是空密码,这里默认 回车 Enter current password for root (enter for none): 设置新密码 这里设置新的root密码 Set root password? [Y/n] y New password: Re-enter new password: 其他设置 下面根据个人偏好来进行设置,没有绝对的要求 Remove anonymous users? [Y/n] Y #是否移除匿名用户 Disallow root login remotely? [Y/n] n #是否不允许root远程登录 Remove test database and access to it? [Y/n] n #是否移除test数据库 Reload privilege tables now? [Y/n] y #是否重新加载表的权限 ","date":"2019-03-18","objectID":"/termux/:39:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"使用密码登录数据库\" 使用密码登录数据库\"\u003e使用密码登录数据库 $ mysql -uroot -p Enter password: ***apache2 tmux Tmux是一个优秀的终端复用软件，类似GNU Screen，但来自于OpenBSD，采用BSD授权。一旦你熟悉了 tmux 后， 它就像一个加速器一样加速你的工作效率。 ","date":"2019-03-18","objectID":"/termux/:40:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"安装tmux pkg install tmux ","date":"2019-03-18","objectID":"/termux/:41:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"新建mysql会话 上面介绍的mysqld后会一直卡在那里,强迫症表示接受不了,重启手机,现在尝试使用tmux来管理会话. tmux new -s mysql 可以看到最下面的提示,表明现在是在mysql的会话下面操作 ","date":"2019-03-18","objectID":"/termux/:42:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"启动mysqld并断开会话 启动mysqld mysqld 让会话后台运行 使用快捷键组合Ctrl+b + d，三次按键就可以断开当前会话。 ","date":"2019-03-18","objectID":"/termux/:43:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"使用mysql 现在那个mysqld会话被放在后台运行了,整个界面看上去很简介,使用 mysql -uroot -p 可以优雅的使用数据库了. 效果图 关于tmux更多进阶的用法这里不在过多介绍了. php termux封装的php版本是php 7.2.5 ","date":"2019-03-18","objectID":"/termux/:44:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"安装PHP pkg install php 查看下版本 自PHP5.4之后 PHP内置了一个Web 服务器,来在termux下尝试下PHP Web Server的简单使. ","date":"2019-03-18","objectID":"/termux/:45:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"编写测试文件 在家目录下建一个www文件夹:mkdir www 在www文件夹下新建一个index.php文件,其内容为 \u003c?phpphpinfo();?\u003e ","date":"2019-03-18","objectID":"/termux/:46:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"启动WebServer php -S 127.0.0.1:8080 -t www/ 浏览器访问效果如下: nginx Nginx 是一个高性能的 Web 和反向代理服务器, 它具有有很多非常优越的特性. ","date":"2019-03-18","objectID":"/termux/:47:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"安装nginx包 pkg install nginx ","date":"2019-03-18","objectID":"/termux/:48:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"切换root用户 尝试下能不能解析默认的index.html主页 这个文件在termux上的默认位置为/data/data/com.termux/files/usr/share/nginx/html/index.html 切换root用户 默认的普通权限无法启动nginx,需要模拟root权限才可以 没有这个命令的话,手动安装pkg install proot包 termux-chroot 进入模拟的root环境 ","date":"2019-03-18","objectID":"/termux/:49:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"启动nginx 在模拟的root环境下启动nginx nginx termux上nginx默认的端口是8080 查看下8080端口是否在运行 netstat -an |grep 8080 然后手机本地直接访问:http://127.0.0.1:8080 查看下nginx是否正常启动. 效果图 这样一个默认的nginx服务就起来了,但是意义不大,得配置一下可以解析php才会有更大的意义. ","date":"2019-03-18","objectID":"/termux/:50:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"停止nginx服务 这里是直接杀掉占用端口的进程,具体端口以实际情况为准. fuser -k 8080/tcp ","date":"2019-03-18","objectID":"/termux/:51:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"重启nginx服务 nginx -s reload nginx解析PHP nginx解析PHP这里单独拿出一级标题来叙述,成功解析的话,下面安装wordpress等cms就会轻松很多. nginx本身不能处理PHP，它只是个web服务器，当接收到php请求后发给php解释器处理,nginx一般是把请求发fastcgi管理进程处理,PHP-FPM是一个PHP FastCGI管理器,所以这里得先安装php-fpm. 这里默已经安装了nginx和php,没有安装的话,使用pkg install php nginx来进行安装,参考上面部分进行配置 ","date":"2019-03-18","objectID":"/termux/:52:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"安装并配置php-fpm 安装php-fpm pkg install php-fpm 配置php-fpm 进入proot环境,然后编辑配置文件www.conf(先进proot可以更方便操作编写相关配置文件) termux-chroot vim /etc/php-fpm.d/www.conf 定位搜索listen找到 listen = /data/data/com.termux/files/usr/var/run/php-fpm.sock 将其改为 listen = 127.0.0.1:9000 ","date":"2019-03-18","objectID":"/termux/:53:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"配置nginx 在proot环境下,然后编辑配置文件nginx.conf vim /etc/nginx/nginx.conf 下面给出已经配置好的模板文件,直接编辑替换整个文件即可: worker_processes 1; events { worker_connections 1024;} ​ http { include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; ​ server { listen 8080; server_name localhost; root /data/data/com.termux/files/usr/share/nginx/html; index index.html index.htm; ​ error_page 500 502 503 504 /50x.html; location = /50x.html { root /data/data/com.termux/files/usr/share/nginx/html;} ​ location ~ .php$ { root html; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME /usr/share/nginx/html$fastcgi_script_name; include fastcgi_params;}}} 里面的网站默认路径就是nginx默认的网站根目录: root /data/data/com.termux/files/usr/share/nginx/html; fastcgi_param SCRIPT_FILENAME /usr/share/nginx/html$fastcgi_script_name; 要修改网站默认路径的话,只需要修改这两处即可. ","date":"2019-03-18","objectID":"/termux/:54:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"建立php测试文件 在/usr/share/nginx/html目录下新建一个phpinfo.php文件,其内容是:\u003c?php phpinfo();?\u003e went ","date":"2019-03-18","objectID":"/termux/:55:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"启动php-fpm和nginx 在proot环境下面分别启动php-fpm和nginx,这里的nginx不在proot环境下启动后会出一些问题,感兴趣的可以自己去研究看看. php-fpm nginx ","date":"2019-03-18","objectID":"/termux/:56:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"浏览器访问测试 浏览器访问http://127.0.0.1:8080/phpinfo.php 查询php文件是否解析了. 搭建WordPress 这里只是用wordpress做个典型安利来讲解,类似地可以安装Discuz,DeDecms等国内主流的PHP应用程序. ","date":"2019-03-18","objectID":"/termux/:57:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"方法一-使用PHP内置的Web-Server 确保安装并配置了php和mariadb,没有安装好的话,参考本文中具体细节部分来进行安装. 新建数据库 *** 这里是mysql的密码 mysql -uroot -p***-e\"create database wordpress;show databases;\" 下载解压wordpress wget https://cn.wordpress.org/wordpress-4.9.4-zh_CN.zip pkg install unzip unzip wordpress-4.9.4-zh_CN.zip 启动PHP Web Server 到解压后的wordpress目录下,执行 cd wordpress php -S 127.0.0.1:8080 然后浏览器访问127.0.0.1:8080开始进行wordperss的安装. 效果图 ","date":"2019-03-18","objectID":"/termux/:58:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"方法二-nginx-PHP-Mariadb 上面使用的方法一是直接使用PHP自带的PHP Web Server来运行的,看上去不够严谨~,所以这里用nginx来部署wordpress. 确保安装了PHP,php-fpm,mariadb,没有安装的话,参考本文中具体细节部分来进行安装和配置. 新建数据和wordpress下载参考上面的方法一,这里主要介绍使用nginx去解析wordpress源文件. 当前解压后wordpress的绝对路径是: /data/data/com.termux/files/home/wordpress 编辑nginx.conf vim /etc/nginx/nginx.conf 修改为如下几处: root /data/data/com.termux/files/home/wordpress; index index.html index.htm index.php; fastcgi_param SCRIPT_FILENAME /data/data/com.termux/files/home/wordpress$fastcgi_script_name; 启动php-fpm和nginx 在proot环境下面分别启动php-fpm和nginx,这里的nginx不在proot环境下启动后会出一些问题,感兴趣的可以自己去研究看看. php-fpm nginx 安装wordpress 浏览器访问:http://127.0.0.1:8080/wp-admin/setup-config.php进行安装. 效果图 同理安装其他博客也就轻而易举了,可玩性大大增加~ 搭建hexo博客 ","date":"2019-03-18","objectID":"/termux/:59:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"安装hexo npm install hexo-cli -g ","date":"2019-03-18","objectID":"/termux/:60:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"部署hexo博客环境 然后建立一个目录,然后到这个目录下初始化hexo环境 mkdir hexoblog #手动创建一个目录 cd hexoblog hexo init #初始化hexo环境 hexo g #生成静态文件 hexo s #启动hexo 然后就跑起来一个最基本的hexo博客 关于hexo博客的详细教程,建议搭建去参考hexo官方文档,我这里重点在于 termux 其他的不作过多的叙述. 效果图 termux-ssh-连接电脑 有时候要操作电脑,这个时候有了termux,躺在床上就可以操作电脑了,岂不是美滋滋~~ 安装openssh pkg install openssh 然后就可以直接ssh连接你的电脑了 前提是电脑安装了ssh服务 $ ssh sqlsec@192.168.1.8 手机连接操作电脑效果图: 电脑ssh连接Termux emmm 这个需求比较鸡肋,但是写文字嘛就得写全了~ 安装openssh 同样也需要openssh才可以 pkg install openssh 启动sshd 安装完成后,sshd服务默认没有启动,所以得手动启动下: sshd 因为手机上面低的端口有安全限制,所以这里的openssh默认的sshd默认的服务是8022端口上的. ssh的用户名用whoami命令看下. 可以看到sshd启动后,端口才可以看到. PC端生成公钥 ssh登录是key公钥模式登录,首先在PC端生成秘钥: sqlsec@ubuntu:-\u003e ssh-keygen -t rsa 执行完成后，会在家目录下创建3个文件 id_rsa, id_rsa.pub , known_hosts 拷贝公钥到手机 然后把公钥id_rsa.pub拷贝到手机的data\\data\\com.termux\\files\\home\\.ssh文件夹中. 将公钥拷贝到验证文件中 在Termux下操作 cat id_rsa.pub \u003e authorized_keys PC端连接手机termux sqlsec@ubuntu-\u003essh -p8022 u0_a119@192.168.1.3 效果图 pc端连接手机termux 真心鸡肋呀~(忍不住自己吐槽下自己) 使用Aria2打造自己的下载工具 Aria2是一个轻量级多协议和多源命令行下载实用工具。它支持 HTTP / HTTPS, FTP, SFTP, bt 和 Metalink。通过内置 Aria2 可以操作 json - rpc 和 xml - rpc。配置好的话还可以高速下载百度云文件. ","date":"2019-03-18","objectID":"/termux/:61:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"安装aria2 pkg install aria2 ","date":"2019-03-18","objectID":"/termux/:62:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"本地启动服务 aria2c --enable-rpc --rpc-listen-all 这个rpc服务默认监听的是6800端口,启动后方便下面的Web界面连接操作. ","date":"2019-03-18","objectID":"/termux/:63:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"webui-aria2 这是个Aria2的热门项目,把Aria2封装在了Web平台,操作起来更加简单便捷。 git clone https://github.com/ziahamza/webui-aria2.git cd webui-aria2 node node-server.js 需要node来运行,没有安装的 话使用pkg install nodejs来安装 使用效果图 ,速度蛮快的 ,有兴趣的可以研究如何利用aria2来下载百度云文件,等你们来探索. 多功能文件分享 官方项目地址 ","date":"2019-03-18","objectID":"/termux/:64:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"安装caddy 官方:到目前为止，在Android上运行Caddy有两种方式：Termux和adb,所以那就顺便折腾一下看看吧: cd ~ curl https://getcaddy.com |bash -s personal http.filemanager 这一步可能执行要3番钟左右,耐心等待一下即可. ","date":"2019-03-18","objectID":"/termux/:65:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"编写配置文件 cd ~ vim Caddyfile 内容如下: :8080 { filemanager / /sdcard timeouts none gzip} 这里的8080端口号可以随意指定,因为手机权限比较低,所以一般设置1024以上的端口. 注意8080和{之间有一个空格 注意/ / sdcard 两个斜杠之间也有一个空格 ","date":"2019-03-18","objectID":"/termux/:66:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"启动caddy caddy ","date":"2019-03-18","objectID":"/termux/:67:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"效果 浏览器访问:http://127.0.0.1:8080即可,局域网内的用户访问手机ip地址即可. 默认账号和密码为admin,admin. 可以在设置界面里面 设置简体中文,可以修改更新默认密码. 可以直接查看文件,也支持Linux命令搜索. Termux-api Termux:API，用于访问手机硬件,实现更多的可玩性,可以实现如下等功能: 访问电池信息 获取相机设备信息 获取本机设备信息 获取设置剪贴板信息 获取通讯录信息 获取设置手机短信 拨打号码 振动设备 ","date":"2019-03-18","objectID":"/termux/:68:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"安装Termux-api Termux-api Google Play下载地址 补充一下链接如何在电脑上下载Google play上的应用？ ","date":"2019-03-18","objectID":"/termux/:69:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"安装Termux-api软件包 安装完Termux-apiAPP后,Termux里面必须安装对应的包后才可以实现操作手机底层. pkg install termux-api 下面只列举一些可能会用到的,想要获取更多关于Termux-api的话,那就去参考官方文档. ","date":"2019-03-18","objectID":"/termux/:70:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"获取电池信息 termux-battery-status 可以看到电池的-健康状况-电量百分比-温度情况等 {\"health\":\"GOOD\", \"percentage\": 67, \"plugged\":\"UNPLUGGED\", \"status\":\"DISCHARGING\", \"temperature\": 24.600000381469727 } ","date":"2019-03-18","objectID":"/termux/:71:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"获取相机信息 termux-camera-info ","date":"2019-03-18","objectID":"/termux/:72:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"获取与设置剪贴板 查看当前剪贴板内容 termux-clipboard-get 设置新的剪贴板内容 termux-clipboard-set PHP是世界上最好的语言 效果演示 ","date":"2019-03-18","objectID":"/termux/:73:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"获取通讯录列表 termux-contact-list ","date":"2019-03-18","objectID":"/termux/:74:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"查看短信内容列表 termux-sms-inbox ","date":"2019-03-18","objectID":"/termux/:75:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"发送短信 termux-sms-send 支持同时发送多个号码,实现群发的效果,官方介绍如下: termux-sms-send -n number(s) recipient number(s) - separate multiple numbers by commas 发送测试 termux-sms-send -n 10001 cxll ","date":"2019-03-18","objectID":"/termux/:76:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"拨打电话 termux-telephony-call 拨打电话给10001中国电信,查看下话费有没有欠费~? termux-telephony-call 10001 ","date":"2019-03-18","objectID":"/termux/:77:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"WiFi相关 获取当前WiFi连接信息 termux-wifi-connectioninfo 获取最近一次WiFi扫描信息 termux-wifi-scaninfo ","date":"2019-03-18","objectID":"/termux/:78:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"小结-1 直接操作调动系统底层的话,可以通过编程来实现自动定时短信发送,语音播报等 DIY空间无线 一些无聊的尝试 一些无聊有趣的版块,如果你是一个正经讲究人,可以跳过这个板块以节约你的阅读时间. ","date":"2019-03-18","objectID":"/termux/:79:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"nyancat-彩虹猫 彩虹貓（英语：Nyan Cat）是在2011年4月上传在Youtube 的视频，并且迅速爆红于网络，並在2011年YouTube浏览量最高的视频中排名第五. pkg install nyancat nyancat 什么鬼~完全Get不到国外人的趣味点~ ","date":"2019-03-18","objectID":"/termux/:80:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"终端二维码 Linux 命令行下的二维码,主要核心是这个网址:http://qrenco.de/ echo\"http://www.sqlsec.com\"|curl -F-=\\\u003c- qrenco.de 如果你不嫌无聊的话还可以扫描这个二维码,然后就打开我的博客了. ","date":"2019-03-18","objectID":"/termux/:81:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"终端地图 一个基于nodejs编写的命令行下的地图. npm install mapscii -g mapscii 进入终端地图 操作方法 方向键 移动 a和z键 放大缩小 q键 退出 终端下的地图!讲究人~ 如果你足够无聊的话,还可以尝试能不能在这个地图上找到自己所在的位置. 在termux下安装linux操作系统 这里只讲系统的安装，对termux的折腾请见我另外的博文。 没有linux基础的就别忙往下看了。 ","date":"2019-03-18","objectID":"/termux/:82:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"安装步骤 ","date":"2019-03-18","objectID":"/termux/:83:0","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"1. 下载安装脚本 $ wget http://funs.ml/file/atilo ","date":"2019-03-18","objectID":"/termux/:83:1","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"2.设置执行权限 $ chmod +x atilo ","date":"2019-03-18","objectID":"/termux/:83:2","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"3. 运行atilo $ ./atilo 此时会出现如下界面： 通过信息我们可以知道 ./atilo + 系统名 就可以按照 ","date":"2019-03-18","objectID":"/termux/:83:3","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"4. 我们来安装一个arch试试 $ ./atilo arch 安装完成之后会提示你通过startarch指令启动arch ","date":"2019-03-18","objectID":"/termux/:83:4","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"5.启动arch $ startarch 启动之后你可以安装screenfetch秀一秀 $ paceman -S screenfetch $ screenfetch Screenshot_20170926-143923.png 是不是酷毙了。 ","date":"2019-03-18","objectID":"/termux/:83:5","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["Termux"],"content":"6. 删除arch 删除系统的方法很简单 $ ./atilo -r arch ","date":"2019-03-18","objectID":"/termux/:83:6","tags":["Termux","编程"],"title":"Termux 高级终端安装使用配置教程","uri":"/termux/"},{"categories":["JavaScript"],"content":"JavaScript: Slice, Substring, or Substr的选择！ ","date":"2019-03-17","objectID":"/javascript%E5%AD%97%E7%AC%A6%E4%B8%B2string%E6%8F%90%E5%8F%96%E6%96%B9%E6%B3%95%E6%AF%94%E8%BE%83/:0:0","tags":["JavaScript","编程"],"title":"JavaScript字符串String提取方法比较","uri":"/javascript%E5%AD%97%E7%AC%A6%E4%B8%B2string%E6%8F%90%E5%8F%96%E6%96%B9%E6%B3%95%E6%AF%94%E8%BE%83/"},{"categories":["JavaScript"],"content":"在JavaScript中，子字符串主要通过以下String方法之一提取： // slice // syntax: string.slice(start [, stop]) \"Good news, everyone!\".slice(5,9); // 'news' // substring // syntax: string.substring(start [, stop]) \"Good news, everyone!\".substring(5,9); // 'news' // substr // syntax: string.substr(start [, length]) \"Good news, everyone!\".substr(5,4); // 'news' ","date":"2019-03-17","objectID":"/javascript%E5%AD%97%E7%AC%A6%E4%B8%B2string%E6%8F%90%E5%8F%96%E6%96%B9%E6%B3%95%E6%AF%94%E8%BE%83/:1:0","tags":["JavaScript","编程"],"title":"JavaScript字符串String提取方法比较","uri":"/javascript%E5%AD%97%E7%AC%A6%E4%B8%B2string%E6%8F%90%E5%8F%96%E6%96%B9%E6%B3%95%E6%AF%94%E8%BE%83/"},{"categories":["JavaScript"],"content":"这三种方法都采用了开始索引和可选的结束索引（或长度）参数，但它们在某些重要方面有所不同： substr可以给出不一致的结果。现代浏览器允许使用负数索引，但IE8和更低版本将负开始索引视为0。 substring的参数是可逆的，因为它总是使用其最小参数值作为开始索引，最大值作为结束索引。substring将负开始索引视为0。 slice如果开始索引为负，则从字符串末尾开始切片。 ","date":"2019-03-17","objectID":"/javascript%E5%AD%97%E7%AC%A6%E4%B8%B2string%E6%8F%90%E5%8F%96%E6%96%B9%E6%B3%95%E6%AF%94%E8%BE%83/:2:0","tags":["JavaScript","编程"],"title":"JavaScript字符串String提取方法比较","uri":"/javascript%E5%AD%97%E7%AC%A6%E4%B8%B2string%E6%8F%90%E5%8F%96%E6%96%B9%E6%B3%95%E6%AF%94%E8%BE%83/"},{"categories":["JavaScript"],"content":"负数作为参数 \"Good news, everyone!\".substring(-4); // \"Good news, everyone!\" \"Good news, everyone!\".substr(-4); // \"one!\" modern browsers, including IE9 // \"Good news, everyone!\" IE8 and lower \"Good news, everyone!\".slice(-4); // \"one!\" 由于所有三种方法都具有大致相同的性能，我的偏好是使用slice。它支持从字符串的末尾提取，我觉得在start index\u003e stop 时返回一个空字符串更遵循常人思维，比substring的参数交换更好。我避免使用substr，因为浏览器不一致。 ","date":"2019-03-17","objectID":"/javascript%E5%AD%97%E7%AC%A6%E4%B8%B2string%E6%8F%90%E5%8F%96%E6%96%B9%E6%B3%95%E6%AF%94%E8%BE%83/:3:0","tags":["JavaScript","编程"],"title":"JavaScript字符串String提取方法比较","uri":"/javascript%E5%AD%97%E7%AC%A6%E4%B8%B2string%E6%8F%90%E5%8F%96%E6%96%B9%E6%B3%95%E6%AF%94%E8%BE%83/"},{"categories":["技巧"],"content":"文章长期更新 公共图床排名 ","date":"2019-01-08","objectID":"/%E5%9B%BE%E5%BA%8A%E8%AF%84%E6%B5%8B/:0:0","tags":["图床"],"title":"图床选择","uri":"/%E5%9B%BE%E5%BA%8A%E8%AF%84%E6%B5%8B/"},{"categories":["技巧"],"content":"第一名 新浪微博图床 新浪微博图床无论是国内外速度还是CDN和HTTPS的支持都一样不少，谷歌商店也有相应的插件，我目前使用的是＂微博图床＂这个插件，相册上传位置可以在微相册中找到。缺点是微博并没有公开表示微相册可以一直提供外链，图片存在压缩。 评分 速度：★★★★★ 插件：★★★★★ CDN：★★★★★ 稳定性：★★★★ 费用: 免费 ","date":"2019-01-08","objectID":"/%E5%9B%BE%E5%BA%8A%E8%AF%84%E6%B5%8B/:1:0","tags":["图床"],"title":"图床选择","uri":"/%E5%9B%BE%E5%BA%8A%E8%AF%84%E6%B5%8B/"},{"categories":["技巧"],"content":"解决新浪图床的防盗链问题 ","date":"2019-01-08","objectID":"/%E5%9B%BE%E5%BA%8A%E8%AF%84%E6%B5%8B/:1:1","tags":["图床"],"title":"图床选择","uri":"/%E5%9B%BE%E5%BA%8A%E8%AF%84%E6%B5%8B/"},{"categories":["技巧"],"content":"方法1 网站头部添加下面代码，记得添加至 \u003c/head\u003e之前 \u003cmetaname=\"referrer\"content=\"no-referrer\"\u003e 加这个的意思是新浪图片就无法追踪到请求图片的域名，可解决一些防盗链的限制！ 但是加这个对于一些AFF，友链都会导致无法追踪请求的域名，目前已知百度统计无法与这玩意共存，CNZZ、51la正常。 ####方法2 可以通过批量修改前缀来暂时恢复正常访问，新浪图片都是多台服务器寄存的，分别是wx1.sinaimg.cn、wx2.sinaimg.cn、wx3.sinaimg.cn、wx4.sinaimg.cn，这里我们需要将其替换成tva1.sinaimg.com、tva2.sinaimg.com、tva3.sinaimg.com、tva4.sinaimg.com，数字对不上也没关系，将wx后面的数字1~4打乱图片都能打开，但为了保险起见以及后期管理还是按照数字进行修改网址吧！ 一个个在文章中修改太麻烦，这里直接使用SQL命令批量处理，在此之前登录至网站的数据库导出备份一下，就算操作不当也能及时数据回滚。 ##第二名 imgur 这是著名的老牌图床,稳定性非常可靠(不被墙的情况下)，提供的上传工具也非常多。 评分 速度：★★★★ 插件：★★★★★ CDN：★★★★ 稳定性：★★★★★ 费用: 免费 ","date":"2019-01-08","objectID":"/%E5%9B%BE%E5%BA%8A%E8%AF%84%E6%B5%8B/:1:2","tags":["图床"],"title":"图床选择","uri":"/%E5%9B%BE%E5%BA%8A%E8%AF%84%E6%B5%8B/"},{"categories":["技巧"],"content":"第二名 sm.ms 大佬自建的图床，小于5M，不能管理图库，可批量上传，一次最多10张，无损，速度快,稳定性肯定不如上面的，不考虑未来收费的可能性。当然还有一些其他的免费图床，这里不再推荐，因为图床多了更不好管理。 评分 速度：★★★★ 插件：★★★★ CDN：★★★★ 稳定性：★★★ 费用: 免费 其他方案 ","date":"2019-01-08","objectID":"/%E5%9B%BE%E5%BA%8A%E8%AF%84%E6%B5%8B/:2:0","tags":["图床"],"title":"图床选择","uri":"/%E5%9B%BE%E5%BA%8A%E8%AF%84%E6%B5%8B/"},{"categories":["技巧"],"content":"最稳妥的方案 七牛云对象云存储：免费10G，无免费外链。 腾讯云对象云存储： 免费50G，外链。 网易云对象云存储： 免费50G，外链。 阿里云对象云存储： 收费，外链。 onedrive：免费10-20G，外链。 ","date":"2019-01-08","objectID":"/%E5%9B%BE%E5%BA%8A%E8%AF%84%E6%B5%8B/:3:0","tags":["图床"],"title":"图床选择","uri":"/%E5%9B%BE%E5%BA%8A%E8%AF%84%E6%B5%8B/"},{"categories":["技巧"],"content":"偏门的方案 百度空间 360搜图 搜狗搜图 简书 其他网站的免费空间 ","date":"2019-01-08","objectID":"/%E5%9B%BE%E5%BA%8A%E8%AF%84%E6%B5%8B/:4:0","tags":["图床"],"title":"图床选择","uri":"/%E5%9B%BE%E5%BA%8A%E8%AF%84%E6%B5%8B/"},{"categories":["技巧"],"content":"整理的图片上传地址（不定期更新） 别人的整理 微博插件 ","date":"2019-01-08","objectID":"/%E5%9B%BE%E5%BA%8A%E8%AF%84%E6%B5%8B/:5:0","tags":["图床"],"title":"图床选择","uri":"/%E5%9B%BE%E5%BA%8A%E8%AF%84%E6%B5%8B/"},{"categories":["哲学"],"content":"抑郁时的随想 关键词：起源 混沌 无为 道 量子 时间 循环 菩提 生死 ","date":"2019-01-06","objectID":"/%E6%8A%91%E9%83%81%E6%9C%9F%E9%9A%8F%E6%83%B3/:0:0","tags":["哲学"],"title":"抑郁期随想","uri":"/%E6%8A%91%E9%83%81%E6%9C%9F%E9%9A%8F%E6%83%B3/"},{"categories":["哲学"],"content":"起源 “宇宙”中文词来源于道家著作《文子，自然》宙指时间，宇指空间。道家早就指出宇宙无限的概念。这看起来很不可思议，当然现代物理也证明了宇宙镶嵌重复的形状决定了它的有限无界，道家一些理论似乎对现代物理都解释的通，但是物理和哲学界限还没有到达能够一通的水平，物理将成为哲学的终极答案，这一点似乎是已经很明确的了。 ","date":"2019-01-06","objectID":"/%E6%8A%91%E9%83%81%E6%9C%9F%E9%9A%8F%E6%83%B3/:1:0","tags":["哲学"],"title":"抑郁期随想","uri":"/%E6%8A%91%E9%83%81%E6%9C%9F%E9%9A%8F%E6%83%B3/"},{"categories":["哲学"],"content":"混沌 混沌一词历史上出现次数非常多，描述也不太统一。万事万物皆有混沌，在 詹姆斯·格雷克 的书《混沌》中用一个例子来描述就是北京的一只蝴蝶拍了一下翅膀，竟引起加勒比海的飓风。这个世界的运行规律远没有想象的那么简单，人类的思维限制了世界的边界。所谓“混沌”，是指看来遵从确定规律的事物也会显现超乎想象的繁复多样，只要有些微的条件差异，就会导致令人瞠目结舌的不同结果。混沌不是哲学上的想当然，它对于人类理解这个世界的运行规律提供了一种强有力的方法论。这也引出了人工智能的重要性，因为人类的智慧短时间内是有限的，就拿对数据极其敏感的天气来说，人工智能可以分析全部可能的要素，正确得出结论，人工智能的进化是人类想象不到的。 ","date":"2019-01-06","objectID":"/%E6%8A%91%E9%83%81%E6%9C%9F%E9%9A%8F%E6%83%B3/:2:0","tags":["哲学"],"title":"抑郁期随想","uri":"/%E6%8A%91%E9%83%81%E6%9C%9F%E9%9A%8F%E6%83%B3/"},{"categories":["哲学"],"content":"无为 无为是道家文化思想，无为的解释随着历史发展的也出现了各种各样的误解，无为的境界一般人难以达到，老庄认为真正道德修为很高的任是已无为为有为的，因为已经达到高度理性的境界。无为主张洞悉自然，顺应天道，所谓“人定胜天”更是无知的表现。王阳明对于自我的顿悟，提出了“知行合一”的思想，我认为这是“无为”一种境界，即知天命，行人道。对于“无为”的理解和如何做到“无为为有为”才能真正知天命？ ","date":"2019-01-06","objectID":"/%E6%8A%91%E9%83%81%E6%9C%9F%E9%9A%8F%E6%83%B3/:3:0","tags":["哲学"],"title":"抑郁期随想","uri":"/%E6%8A%91%E9%83%81%E6%9C%9F%E9%9A%8F%E6%83%B3/"},{"categories":["哲学"],"content":"道 老君曰：大道无形，生育天地；大道无情，运行日月；大道无名，长养万物；吾不知其名，强名曰道。道即万物的的终极的真理，其实理解为物理的TOE也颇为合适，这又回到了起源，道是万物的起源，不知其名。 ","date":"2019-01-06","objectID":"/%E6%8A%91%E9%83%81%E6%9C%9F%E9%9A%8F%E6%83%B3/:4:0","tags":["哲学"],"title":"抑郁期随想","uri":"/%E6%8A%91%E9%83%81%E6%9C%9F%E9%9A%8F%E6%83%B3/"},{"categories":["哲学"],"content":"量子 一个物理量如果存在最小的不可分割的基本单位，则这个物理量是量子化的，并把最小单位称为量子。量子是近年来兴起的热词，但是在1900年左右，M·普朗克试图解决黑体辐射问题，他大胆提出量子假设，并得出了普朗克辐射定律，沿用至今。后来为了指出量子力学哥本哈根解释的不完备性，由伟大的物理学家薛定谔提出的一个薛定谔猫的理想实验。虽然量子理论还有很长的路要走，但是根据客观规律，人们已经研制出量子加密，量子计算机的基础产品。所以说量子理论也为我们了解世界提供了一种方法论。所以说“上帝”掷不掷骰子？ ","date":"2019-01-06","objectID":"/%E6%8A%91%E9%83%81%E6%9C%9F%E9%9A%8F%E6%83%B3/:5:0","tags":["哲学"],"title":"抑郁期随想","uri":"/%E6%8A%91%E9%83%81%E6%9C%9F%E9%9A%8F%E6%83%B3/"},{"categories":["哲学"],"content":"时间 时间大家并陌生，是除空间以外第四维，估计很多人都看过许多科幻影视作品中穿越时空到过去或者未来，很明显这是不符合相对论的描述，但有一种方案似乎可行，看过神盾局特工的应该知道有一场景为了躲避地球末日而建立的避难所的冷冻装置，他将你身体冷冻，到一定时间解冻，似乎也完成了穿越到未来的过程，也就是相对的与被冷冻者思想，他穿越到了未来。 ","date":"2019-01-06","objectID":"/%E6%8A%91%E9%83%81%E6%9C%9F%E9%9A%8F%E6%83%B3/:6:0","tags":["哲学"],"title":"抑郁期随想","uri":"/%E6%8A%91%E9%83%81%E6%9C%9F%E9%9A%8F%E6%83%B3/"},{"categories":["哲学"],"content":"循环 循环的威力是无穷的，它广泛应用各个领域，许多数学上的问题比如n的阶乘很难表示，但如果加上循环的思想则非常简单，计算机语言中都会有循环的概念。从广义上说人类社会也可以看作循环的结果，后人站在前人的肩膀上，往复。当然循环效应也可以解释我为什么没有提时空穿梭的虫洞理论。 ","date":"2019-01-06","objectID":"/%E6%8A%91%E9%83%81%E6%9C%9F%E9%9A%8F%E6%83%B3/:7:0","tags":["哲学"],"title":"抑郁期随想","uri":"/%E6%8A%91%E9%83%81%E6%9C%9F%E9%9A%8F%E6%83%B3/"},{"categories":["哲学"],"content":"菩提 人之于地球万物可说达到了“菩提”的境界，这不得归公功于人的大脑，准确来说是人的大脑皮层，它使人类拥有了智慧。当然这里还有一个自制力相关的理论：乔纳森·海特（Jonathan Haidt），将大脑比作大象与骑象人。(《the happiness hypothesis》)骑象人是自觉的、控制的，而大象则是知觉、身体、情绪等构成的无意识系统。这是有解剖学证据支撑的：骑象人部分就是人的大脑皮层，而大象部分就是人的原始脑。现代心理学的双加工模型也支持了这一点。在我们现今的世界里，一天24小时全天候地充斥着各种各样的信息，分散着人们的注意力；有很多额外的事物试图控制我们的时间和注意力。注意力其实是很有限的，对吗？如果没有办法集中注意力，无论你有什么样的雄心壮志也没有用。 ","date":"2019-01-06","objectID":"/%E6%8A%91%E9%83%81%E6%9C%9F%E9%9A%8F%E6%83%B3/:8:0","tags":["哲学"],"title":"抑郁期随想","uri":"/%E6%8A%91%E9%83%81%E6%9C%9F%E9%9A%8F%E6%83%B3/"},{"categories":["哲学"],"content":"生死 生死是万物更新进化的必然结果，从古代来看人们认为生死是转世投胎的轮回，现代看来这并没有什么说服力，因为人死了变为尘土，仅此而已，留下只有你存在于这个世界的一些多少不同痕迹，就像愚公移山，子子孙孙无穷匮也，每个人存在的意义就是使人类社会能够进步。以后的发展，人类如果能够突破生死的束缚，找到可以进化的更好的方法，那人类或许可以找到真正的“道”。 ","date":"2019-01-06","objectID":"/%E6%8A%91%E9%83%81%E6%9C%9F%E9%9A%8F%E6%83%B3/:9:0","tags":["哲学"],"title":"抑郁期随想","uri":"/%E6%8A%91%E9%83%81%E6%9C%9F%E9%9A%8F%E6%83%B3/"}]