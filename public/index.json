[{"categories":["excel"],"content":"\rvba Function IsFileExists(ByVal strFileName As String) As Boolean If Dir(strFileName, 16) \u003c\u003e Empty Then IsFileExists = True Else IsFileExists = False End If End Function Sub Macro1() i = 1 Do While i \u003c 73 Path = \"C:\\Users\\xinxi\\Desktop\\pdf\\\" Newname = Path \u0026 Range(\"B\" \u0026 i) \u0026 Range(\"A\" \u0026 i) \u0026 \".pdf\" Oldname = Path \u0026 Range(\"A\" \u0026 i) \u0026 \".pdf\" If IsFileExists(Oldname) = True Then Name Oldname As Newname End If i = i + 1 Loop End Sub\r","date":"2023-01-05","objectID":"/excel%E6%89%B9%E9%87%8F%E9%87%8D%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6/:0:0","series":null,"tags":["办公","excel"],"title":"excel批量重命名文件","uri":"/excel%E6%89%B9%E9%87%8F%E9%87%8D%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6/#"},{"categories":["excel"],"content":"\rvba Sub Macro() i = 1 mypath = \"C:\\Users\\xinxi\\Desktop\\123\\\" '文件路径 Do While i \u003c 73 '循环次数，需替换的文本行数 Newname = Range(\"A\" \u0026 i) \u0026 \".docx\" '给新生成的表起个名称 FileCopy mypath \u0026 \"申请表.docx\", mypath \u0026 Newname '复制模板文件 Set docApp = CreateObject(\"Word.Application\") With docApp .Visible = False .Documents.Open mypath \u0026 Newname '打开我们复制的新文件进行模板文字替换 Do While .Selection.Find.Execute(\"门店名称\") .Selection.Text = Range(\"A\" \u0026 i).Text '替换字符串 .Selection.HomeKey Unit:=6 Loop Do While .Selection.Find.Execute(\"门店社会信用代码\") .Selection.Text = Range(\"B\" \u0026 i).Text '替换字符串 .Selection.HomeKey Unit:=6 Loop Do While .Selection.Find.Execute(\"门店电话\") .Selection.Text = Range(\"C\" \u0026 i).Text '替换字符串 .Selection.HomeKey Unit:=6 Loop Do While .Selection.Find.Execute(\"门店地址\") .Selection.Text = Range(\"E\" \u0026 i).Text '替换字符串 .Selection.HomeKey Unit:=6 Loop .Documents.Save .Quit End With i = i + 1 Loop End Sub\r","date":"2023-01-04","objectID":"/excel%E6%89%B9%E9%87%8F%E7%94%9F%E6%88%90word/:0:0","series":null,"tags":["办公","excel"],"title":"excel批量生成word","uri":"/excel%E6%89%B9%E9%87%8F%E7%94%9F%E6%88%90word/#"},{"categories":["python"],"content":"\rpython from collections import OrderedDict import hashlib import base64 def ksort(obj): sorted_obj = sorted(obj) d = OrderedDict() i = 0 for key in sorted_obj: if isinstance(obj[key], dict): d[sorted_obj[i]] = ksort(obj[key]) else: d[sorted_obj[i]] = obj[key] i += 1 return d def implode(obj): return \"\".join(map(str, obj)) def md5(obj): md5 = hashlib.md5() md5.update(obj.encode(encoding='utf-8')) return md5.hexdigest() def base64_encode(obj): return base64.b64encode(obj.encode()).decode()\r","date":"2022-05-25","objectID":"/python%E5%B0%81%E8%A3%85%E5%9B%9B%E4%B8%AAphp%E5%87%BD%E6%95%B0/:0:0","series":null,"tags":["python","php"],"title":"python封装四个常用PHP函数","uri":"/python%E5%B0%81%E8%A3%85%E5%9B%9B%E4%B8%AAphp%E5%87%BD%E6%95%B0/#"},{"categories":["python"],"content":"\rpython import threading import time import inspect import ctypes def _async_raise(tid, exctype): \"\"\"raises the exception, performs cleanup if needed\"\"\" tid = ctypes.c_long(tid) if not inspect.isclass(exctype): exctype = type(exctype) res = ctypes.pythonapi.PyThreadState_SetAsyncExc(tid, ctypes.py_object(exctype)) if res == 0: raise ValueError(\"invalid thread id\") elif res != 1: # \"\"\"if it returns a number greater than one, you're in trouble, # and you should call it again with exc=NULL to revert the effect\"\"\" ctypes.pythonapi.PyThreadState_SetAsyncExc(tid, None) raise SystemError(\"PyThreadState_SetAsyncExc failed\") def stop_thread(thread): _async_raise(thread.ident, SystemExit) def test(): while True: for i in range(1,1000): time.sleep(0.1) print(str(i)) def test1(): while True: for i in range(200,1000): time.sleep(0.1) print(str(i)) if __name__ == \"__main__\": t = threading.Thread(target=test) t1 = threading.Thread(target=test1) t.start() t1.start() time.sleep(5.2) print(\"t thread sleep finish\") print(\"t2 thread sleep finish\") stop_thread(t) stop_thread(t1)\r","date":"2022-05-19","objectID":"/python%E7%BB%88%E6%AD%A2%E8%BF%90%E8%A1%8C%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B/:0:0","series":null,"tags":["python","线程"],"title":"python线程操作","uri":"/python%E7%BB%88%E6%AD%A2%E8%BF%90%E8%A1%8C%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B/#"},{"categories":["JavaScript"],"content":"\rnodejs通过ffi-napi调用系统dll文件\rjs const ffi = require('ffi-napi'); function showText(str) { return Buffer.from(str+'\\0','ucs2'); }; // 通过ffi加载user32.dll const myUser32 = new ffi.Library('user32', { 'MessageBoxW': // 声明这个dll中的一个函数 [ 'int32', ['int32', 'string', 'string', 'int32'], // 用json的格式罗列其返回类型和参数类型 ], }); // 调用user32.dll中的MessageBoxW()函数, 弹出一个对话框 myUser32.MessageBoxW( 0, showText('I am Node.JS!'), showText('你好，世界!'), 1 );\r","date":"2021-10-06","objectID":"/node%E8%B0%83%E7%94%A8dll/:1:0","series":null,"tags":["JavaScript","nodejs"],"title":"nodejs调用dll","uri":"/node%E8%B0%83%E7%94%A8dll/#nodejs通过ffi-napi调用系统dll文件"},{"categories":["python"],"content":"libxl官网 ","date":"2021-09-28","objectID":"/python%E8%B0%83%E7%94%A8libxl%E6%8F%92%E4%BB%B6/:0:0","series":null,"tags":["python","dll"],"title":"python调用libxl插件","uri":"/python%E8%B0%83%E7%94%A8libxl%E6%8F%92%E4%BB%B6/#"},{"categories":["python"],"content":"\r封装libxl.py示例\rpython #coding=utf-8 from ctypes import * class Excel: def __init__(self): self.xl = CDLL(\"./libxl.dll\") def getxl(self): return self.xl def createXML(self): bhandle = self.xl.xlCreateXMLBookCA() return bhandle class Book: def __init__(self,excel,bhandle): self.xl = excel self.bookhandle = bhandle def pr(self): print(self.bookhandle) def setKey(self): self.xl.xlBookSetKeyA (self.bookhandle, b\"HeiYe\", b\"windows-2220200f01c5e9016fb86160afo5raf1\") def createXML(self): self.bookhandle = self.xl.xlCreateXMLBookCA() def addSheet(self,sheetname): shandle=self.xl.xlBookAddSheetA (self.bookhandle, sheetname,0) return shandle def save(self,name): self.xl.xlBookSaveA (self.bookhandle, name) def release(self): self.xl.xlBookReleaseA (self.bookhandle) class Sheet: def __init__(self,excel,shandle): self.xl = excel self.sheethandle = shandle def writestr(self,x,y,string): self.xl.xlSheetWriteStrA (self.sheethandle, x, y, string, 0)\r","date":"2021-09-28","objectID":"/python%E8%B0%83%E7%94%A8libxl%E6%8F%92%E4%BB%B6/:1:0","series":null,"tags":["python","dll"],"title":"python调用libxl插件","uri":"/python%E8%B0%83%E7%94%A8libxl%E6%8F%92%E4%BB%B6/#封装libxlpy示例"},{"categories":["python"],"content":"\r调用libxl.py示例，将libxl.py和stdcall形式的libxl.dll放到同一个目录下\rpython from libxl import * excel = Excel() bh = excel.createXML() xl = excel.getxl() book = Book(xl,bh) book.setKey() sh = book.addSheet(b\"sheet1\") sheet = Sheet(xl, sh) sheet.writestr(0, 0, \"Hello World! 你好\".encode(\"gbk\")) book.save(b\"test.xlsx\") book.release()\r","date":"2021-09-28","objectID":"/python%E8%B0%83%E7%94%A8libxl%E6%8F%92%E4%BB%B6/:2:0","series":null,"tags":["python","dll"],"title":"python调用libxl插件","uri":"/python%E8%B0%83%E7%94%A8libxl%E6%8F%92%E4%BB%B6/#调用libxlpy示例将libxlpy和stdcall形式的libxldll放到同一个目录下"},{"categories":["安全"],"content":"\r基础","date":"2020-02-07","objectID":"/web%E5%AE%89%E5%85%A8/:0:0","series":null,"tags":["安全","web"],"title":"web安全笔记","uri":"/web%E5%AE%89%E5%85%A8/#基础"},{"categories":["安全"],"content":"\r前端与后端知识","date":"2020-02-07","objectID":"/web%E5%AE%89%E5%85%A8/:1:0","series":null,"tags":["安全","web"],"title":"web安全笔记","uri":"/web%E5%AE%89%E5%85%A8/#前端与后端知识"},{"categories":["安全"],"content":"\rweb漏洞","date":"2020-02-07","objectID":"/web%E5%AE%89%E5%85%A8/:2:0","series":null,"tags":["安全","web"],"title":"web安全笔记","uri":"/web%E5%AE%89%E5%85%A8/#web漏洞"},{"categories":["安全"],"content":"\rXSS","date":"2020-02-07","objectID":"/web%E5%AE%89%E5%85%A8/:2:1","series":null,"tags":["安全","web"],"title":"web安全笔记","uri":"/web%E5%AE%89%E5%85%A8/#xss"},{"categories":["安全"],"content":"\rCSRF","date":"2020-02-07","objectID":"/web%E5%AE%89%E5%85%A8/:2:2","series":null,"tags":["安全","web"],"title":"web安全笔记","uri":"/web%E5%AE%89%E5%85%A8/#csrf"},{"categories":["安全"],"content":"\r点击劫持","date":"2020-02-07","objectID":"/web%E5%AE%89%E5%85%A8/:2:3","series":null,"tags":["安全","web"],"title":"web安全笔记","uri":"/web%E5%AE%89%E5%85%A8/#点击劫持"},{"categories":["安全"],"content":"\rURL跳转","date":"2020-02-07","objectID":"/web%E5%AE%89%E5%85%A8/:2:4","series":null,"tags":["安全","web"],"title":"web安全笔记","uri":"/web%E5%AE%89%E5%85%A8/#url跳转"},{"categories":["安全"],"content":"\rSQL注入","date":"2020-02-07","objectID":"/web%E5%AE%89%E5%85%A8/:2:5","series":null,"tags":["安全","web"],"title":"web安全笔记","uri":"/web%E5%AE%89%E5%85%A8/#sql注入"},{"categories":["安全"],"content":"\r命令注入","date":"2020-02-07","objectID":"/web%E5%AE%89%E5%85%A8/:2:6","series":null,"tags":["安全","web"],"title":"web安全笔记","uri":"/web%E5%AE%89%E5%85%A8/#命令注入"},{"categories":["安全"],"content":"\r上传下载漏洞","date":"2020-02-07","objectID":"/web%E5%AE%89%E5%85%A8/:2:7","series":null,"tags":["安全","web"],"title":"web安全笔记","uri":"/web%E5%AE%89%E5%85%A8/#上传下载漏洞"},{"categories":["安全"],"content":"\rweb安全工具","date":"2020-02-07","objectID":"/web%E5%AE%89%E5%85%A8/:3:0","series":null,"tags":["安全","web"],"title":"web安全笔记","uri":"/web%E5%AE%89%E5%85%A8/#web安全工具"},{"categories":["安全"],"content":"\r浏览器 Chrome Firefox(hackbar,cookie manager) IE ","date":"2020-02-07","objectID":"/web%E5%AE%89%E5%85%A8/:3:1","series":null,"tags":["安全","web"],"title":"web安全笔记","uri":"/web%E5%AE%89%E5%85%A8/#浏览器"},{"categories":["安全"],"content":"\r代理抓包\rBurpsuite\rCharles\rFiddler","date":"2020-02-07","objectID":"/web%E5%AE%89%E5%85%A8/:3:2","series":null,"tags":["安全","web"],"title":"web安全笔记","uri":"/web%E5%AE%89%E5%85%A8/#代理抓包"},{"categories":["安全"],"content":"\r代理抓包\rBurpsuite\rCharles\rFiddler","date":"2020-02-07","objectID":"/web%E5%AE%89%E5%85%A8/:3:2","series":null,"tags":["安全","web"],"title":"web安全笔记","uri":"/web%E5%AE%89%E5%85%A8/#burpsuite"},{"categories":["安全"],"content":"\r代理抓包\rBurpsuite\rCharles\rFiddler","date":"2020-02-07","objectID":"/web%E5%AE%89%E5%85%A8/:3:2","series":null,"tags":["安全","web"],"title":"web安全笔记","uri":"/web%E5%AE%89%E5%85%A8/#charles"},{"categories":["安全"],"content":"\r代理抓包\rBurpsuite\rCharles\rFiddler","date":"2020-02-07","objectID":"/web%E5%AE%89%E5%85%A8/:3:2","series":null,"tags":["安全","web"],"title":"web安全笔记","uri":"/web%E5%AE%89%E5%85%A8/#fiddler"},{"categories":["安全"],"content":"\r漏洞扫描 御剑 AWVS Netsparker APPScan sqlmap ","date":"2020-02-07","objectID":"/web%E5%AE%89%E5%85%A8/:3:3","series":null,"tags":["安全","web"],"title":"web安全笔记","uri":"/web%E5%AE%89%E5%85%A8/#漏洞扫描"},{"categories":["安全"],"content":"\r暴力破解 ZAP ","date":"2020-02-07","objectID":"/web%E5%AE%89%E5%85%A8/:3:4","series":null,"tags":["安全","web"],"title":"web安全笔记","uri":"/web%E5%AE%89%E5%85%A8/#暴力破解"},{"categories":["安全"],"content":"\r实战 DVWA ","date":"2020-02-07","objectID":"/web%E5%AE%89%E5%85%A8/:4:0","series":null,"tags":["安全","web"],"title":"web安全笔记","uri":"/web%E5%AE%89%E5%85%A8/#实战"},{"categories":["python"],"content":"\r利用init破解权限和免注册com\rpython #coding=utf-8 from ctypes import windll from comtypes import client #加载init.dll Reg = windll.LoadLibrary(\"./init.dll\") Reg.init() dm=client.CreateObject(\"dm.dmsoft\") print(dm.ver()) dm.MoveTO(10,10)\r用到的文件 ","date":"2020-02-03","objectID":"/python%E8%B0%83%E7%94%A8%E5%A4%A7%E6%BC%A0%E6%8F%92%E4%BB%B6/:1:0","series":null,"tags":["python","dll"],"title":"python调用大漠插件","uri":"/python%E8%B0%83%E7%94%A8%E5%A4%A7%E6%BC%A0%E6%8F%92%E4%BB%B6/#利用init破解权限和免注册com"},{"categories":["rust"],"content":"\rrust导出dll","date":"2020-02-02","objectID":"/rust%E5%AF%BC%E5%87%BAdll/:1:0","series":null,"tags":["rust","dll"],"title":"rust导出Dll","uri":"/rust%E5%AF%BC%E5%87%BAdll/#rust导出dll"},{"categories":["rust"],"content":"\r首先创建lib项目 cargo new addlib -lib ","date":"2020-02-02","objectID":"/rust%E5%AF%BC%E5%87%BAdll/:1:1","series":null,"tags":["rust","dll"],"title":"rust导出Dll","uri":"/rust%E5%AF%BC%E5%87%BAdll/#首先创建lib项目"},{"categories":["rust"],"content":"\r编辑lib.rs\rrust //添加一个标记 #[no_mangle]，防止编译器在编译的时候，重命名函数。 #[no_mangle] //pub 公开 extern,导出 //\"stdcall\"是调用约定ABI，rust支持stdcall，aapcs，cdecl，fastcall，vectorcall，Rust，rust-intrinsic，system，C，win64，sysv64 pub extern \"stdcall\" fn add(a: i32,b:i32) -\u003e i32 { return a+b; }\r","date":"2020-02-02","objectID":"/rust%E5%AF%BC%E5%87%BAdll/:1:2","series":null,"tags":["rust","dll"],"title":"rust导出Dll","uri":"/rust%E5%AF%BC%E5%87%BAdll/#编辑librs"},{"categories":["rust"],"content":"\r编辑cargo.toml，添加\rtoml [lib] name=\"addlib\" crate-type = [\"cdylib\"]\r","date":"2020-02-02","objectID":"/rust%E5%AF%BC%E5%87%BAdll/:1:3","series":null,"tags":["rust","dll"],"title":"rust导出Dll","uri":"/rust%E5%AF%BC%E5%87%BAdll/#编辑cargotoml添加"},{"categories":["rust"],"content":"\r终端运行\rsh cargo build --release\r编译成功之后会在相关目录生成动态库文件。 ","date":"2020-02-02","objectID":"/rust%E5%AF%BC%E5%87%BAdll/:1:4","series":null,"tags":["rust","dll"],"title":"rust导出Dll","uri":"/rust%E5%AF%BC%E5%87%BAdll/#终端运行"},{"categories":["rust"],"content":"\r官网下载初始化包官网 ","date":"2020-02-01","objectID":"/rust%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/:1:0","series":null,"tags":["rust","编程"],"title":"rust环境配置","uri":"/rust%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/#官网下载初始化包"},{"categories":["rust"],"content":"\r根据初始化包安装对应的工具 主要安装rustup和cargo工具链 ","date":"2020-02-01","objectID":"/rust%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/:2:0","series":null,"tags":["rust","编程"],"title":"rust环境配置","uri":"/rust%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/#根据初始化包安装对应的工具"},{"categories":["rust"],"content":"\r国内原因换源","date":"2020-02-01","objectID":"/rust%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/:3:0","series":null,"tags":["rust","编程"],"title":"rust环境配置","uri":"/rust%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/#国内原因换源"},{"categories":["rust"],"content":"\rrustup源 linux text $ # for bash $ echo 'export RUSTUP_DIST_SERVER=https://mirrors.tuna.tsinghua.edu.cn/rustup' \u003e\u003e ~/.bash_profile\rwindows 修改环境变量： 变量名为 text RUSTUP_DIST_SERVER\r变量值为 text https://mirrors.tuna.tsinghua.edu.cn/rustup\r","date":"2020-02-01","objectID":"/rust%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/:3:1","series":null,"tags":["rust","编程"],"title":"rust环境配置","uri":"/rust%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/#rustup源"},{"categories":["rust"],"content":"\rcargo源 windows text # 新建 %USERPROFILE%\\.cargo\\config [source.crates-io] replace-with = \"rustcc\" [source.rustcc] registry = \"https://code.aliyun.com/rustcc/crates.io-index\"\rlinux text tee $HOME/.cargo/config \u003c\u003c-'EOF' [source.crates-io] replace-with = \"rustcc\" [source.rustcc] registry = \"https://code.aliyun.com/rustcc/crates.io-index\"\r","date":"2020-02-01","objectID":"/rust%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/:3:2","series":null,"tags":["rust","编程"],"title":"rust环境配置","uri":"/rust%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/#cargo源"},{"categories":["rust"],"content":"\r配置ide 安装vscode后，安装rust(rls)插件,用cargo new hello_cargo新建工程文件，打开工程按照提示安装rls等工具。 调试环境，windows安装C/C++插件，linux安装codelldb插件 配置launch.json调试文件如下： text { \"version\": \"0.2.0\", \"configurations\": [ \"name\": \"Debug\", \"type\": \"cppvsdbg\", \"request\": \"launch\", //调试程序位置 \"program\": \"${workspaceFolder}/target/debug/YOUR_EXECUTABLE.exe\", \"args\": [], \"stopAtEntry\": false, \"externalConsole\": false, \"preLaunchTask\": \"cargo build\", \"type\": \"cppvsdbg\", // rust源码文件 \"sourceFileMap\": { \"/rustc/4560ea788cb760f0a34127156c78e2552949f734\": \"${env:HOME}${env:USERPROFILE}\\\\.rustup\\\\toolchains\\\\stable-x86_64-pc-windows-msvc\\\\lib\\\\rustlib\\\\src\\\\rust\" } ] }\rrust中文文档 ","date":"2020-02-01","objectID":"/rust%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/:4:0","series":null,"tags":["rust","编程"],"title":"rust环境配置","uri":"/rust%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/#配置ide"},{"categories":["ssh"],"content":"\rSSH服务器","date":"2019-11-13","objectID":"/windows%E5%BC%80%E5%90%AFssh%E6%9C%8D%E5%8A%A1%E5%99%A8/:0:0","series":null,"tags":["windows","ssh"],"title":"windows开启SSH服务器","uri":"/windows%E5%BC%80%E5%90%AFssh%E6%9C%8D%E5%8A%A1%E5%99%A8/#ssh服务器"},{"categories":["ssh"],"content":"\r安装 openssh 设置-应用-应用和功能-管理可选功能-添加功能-OpenSSH 服务器 ","date":"2019-11-13","objectID":"/windows%E5%BC%80%E5%90%AFssh%E6%9C%8D%E5%8A%A1%E5%99%A8/:1:0","series":null,"tags":["windows","ssh"],"title":"windows开启SSH服务器","uri":"/windows%E5%BC%80%E5%90%AFssh%E6%9C%8D%E5%8A%A1%E5%99%A8/#安装-openssh"},{"categories":["ssh"],"content":"\r开启SSH 服务PowerShell 管理员运行： 启动 SSH 服务net start sshd powershell net start sshd\r启动成功显示： OpenSSH SSH Server 服务正在启动 . OpenSSH SSH Server 服务已经启动成功。 停止 SSH 服务net stop sshd powershell net stop sshd\rOpenSSH SSH Server 服务已成功停止。 ##　在 Windows 中为 OpenSSH 配置默认 shell PowerShell 管理员运行： powershell New-ItemProperty -Path \"HKLM:\\SOFTWARE\\OpenSSH\" -Name DefaultShell -Value \"C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe\" -PropertyType String -Force\r","date":"2019-11-13","objectID":"/windows%E5%BC%80%E5%90%AFssh%E6%9C%8D%E5%8A%A1%E5%99%A8/:2:0","series":null,"tags":["windows","ssh"],"title":"windows开启SSH服务器","uri":"/windows%E5%BC%80%E5%90%AFssh%E6%9C%8D%E5%8A%A1%E5%99%A8/#开启ssh-服务"},{"categories":["ssh"],"content":"\rSSH客户端命令ssh username@127.0.0.1即ssh 用户名@用户ip ","date":"2019-11-13","objectID":"/windows%E5%BC%80%E5%90%AFssh%E6%9C%8D%E5%8A%A1%E5%99%A8/:0:0","series":null,"tags":["windows","ssh"],"title":"windows开启SSH服务器","uri":"/windows%E5%BC%80%E5%90%AFssh%E6%9C%8D%E5%8A%A1%E5%99%A8/#ssh客户端"},{"categories":["C++"],"content":"\r调用约定 _stdcall,_cdecl _stdcall调用 按C编译方式，_stdcall调用约定在输出函数名前面加下划线，后面加“@”符号和参数的字节数，形如_func@12 _cdecl调用 _cdecl是C/C++的缺省调用方式，参数采用从右到左的压栈方式，由调用者完成压栈操作 ，传送参数的内存栈由调用者维护。 _cedcl约定的函数只能被C/C++调用，每一个调用它的函数都包含清空堆栈的代码，所以产生的可执行文件大小会比调用_stdcall函数的大。 按C编译方式，_cdecl调用约定仅在输出函数名前面加下划线，形如_functionname。 区别 在跨（开发） 平台的调用中，我们都使用_stdcall（虽然有时是以WINAPI的样子出现）。当遇到这样的函数如 fprintf()它的参数是可变的，不定长的，被调用者事先无法知道参数的长度，事后的清除工作也无法正常的进行，因此，这种情况我们只能使用 _cdecl。如果你的程序中没有涉及可变参数，最好使用__stdcall关键字。 cpp //add.cpp int __stdcall Add(int a, int b) { return a + b; } //__stdcall可不写,但是要在项目中设置 ","date":"2019-11-08","objectID":"/vc-%E5%AF%BC%E5%87%BAdll%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95/:0:0","series":null,"tags":["c++","dll"],"title":"VC++导出Dll常见方法","uri":"/vc-%E5%AF%BC%E5%87%BAdll%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95/#调用约定-_stdcall_cdecl"},{"categories":["C++"],"content":"\r导出Add.dll方式有两种","date":"2019-11-08","objectID":"/vc-%E5%AF%BC%E5%87%BAdll%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95/:0:0","series":null,"tags":["c++","dll"],"title":"VC++导出Dll常见方法","uri":"/vc-%E5%AF%BC%E5%87%BAdll%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95/#导出adddll方式有两种"},{"categories":["C++"],"content":"\r1-模块定义(.def) 文件声明,函数名不变化\rdef LIBRARY Add EXPORTS Add @1\r","date":"2019-11-08","objectID":"/vc-%E5%AF%BC%E5%87%BAdll%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95/:1:0","series":null,"tags":["c++","dll"],"title":"VC++导出Dll常见方法","uri":"/vc-%E5%AF%BC%E5%87%BAdll%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95/#1-模块定义def-文件声明函数名不变化"},{"categories":["C++"],"content":"\r2-导出函数 _declspec(dllexport)\rh //add.h头文件 #ifndef ADD_H #define ADD_H #ifdef __cplusplus // if used by C++ code extern \"C\" { // we need to export the C interface #endif __declspec(dllexport) int Add(int a, int b); #ifdef __cplusplus } #endif #endif\r","date":"2019-11-08","objectID":"/vc-%E5%AF%BC%E5%87%BAdll%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95/:2:0","series":null,"tags":["c++","dll"],"title":"VC++导出Dll常见方法","uri":"/vc-%E5%AF%BC%E5%87%BAdll%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95/#2-导出函数-_declspecdllexport"},{"categories":["git"],"content":"\rgit push常见问题","date":"2019-10-08","objectID":"/git-psuh%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/:0:0","series":null,"tags":["git","error"],"title":"git push常见问题","uri":"/git-psuh%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/#git-push常见问题"},{"categories":["git"],"content":"\rfatal: refusing to merge unrelated histories在git pull或者git push中都有可能会遇到，这是因为两个分支没有取得关系，解决办法是在操作命令后面加--allow-unrelated-histories ","date":"2019-10-08","objectID":"/git-psuh%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/:1:0","series":null,"tags":["git","error"],"title":"git push常见问题","uri":"/git-psuh%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/#fatal-refusing-to-merge-unrelated-histories"},{"categories":["git"],"content":"\rerror: failed to push some refs to解决方案：首先git pull origin master --allow-unrelated-histories ","date":"2019-10-08","objectID":"/git-psuh%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/:2:0","series":null,"tags":["git","error"],"title":"git push常见问题","uri":"/git-psuh%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/#error-failed-to-push-some-refs-to"},{"categories":["JavaScript"],"content":"\r闭包","date":"2019-04-16","objectID":"/%E9%97%AD%E5%8C%85/:0:0","series":null,"tags":["JavaScript","编程"],"title":"闭包","uri":"/%E9%97%AD%E5%8C%85/#闭包"},{"categories":["JavaScript"],"content":"\r定义 闭包是由函数以及创建该函数的词法环境组合而成。这个环境包含了这个闭包创建时所能访问的所有局部变量。 ","date":"2019-04-16","objectID":"/%E9%97%AD%E5%8C%85/:1:0","series":null,"tags":["JavaScript","编程"],"title":"闭包","uri":"/%E9%97%AD%E5%8C%85/#定义"},{"categories":["JavaScript"],"content":"\r实质 将函数当作对象处理，栈（Stack）内存没有释放，没有完成GC操作 ","date":"2019-04-16","objectID":"/%E9%97%AD%E5%8C%85/:2:0","series":null,"tags":["JavaScript","编程"],"title":"闭包","uri":"/%E9%97%AD%E5%8C%85/#实质"},{"categories":["JavaScript"],"content":"\r实例","date":"2019-04-16","objectID":"/%E9%97%AD%E5%8C%85/:3:0","series":null,"tags":["JavaScript","编程"],"title":"闭包","uri":"/%E9%97%AD%E5%8C%85/#实例"},{"categories":["JavaScript"],"content":"\r共享函数定义\rjavascript function makeAdder(x) { return function(y) { return x + y; }; } var add5 = makeAdder(5); var add10 = makeAdder(10); //在makeAdder中共享函数定义 console.log(add5(2)); // 7 console.log(add10(2)); // 12 ","date":"2019-04-16","objectID":"/%E9%97%AD%E5%8C%85/:3:1","series":null,"tags":["JavaScript","编程"],"title":"闭包","uri":"/%E9%97%AD%E5%8C%85/#共享函数定义"},{"categories":["JavaScript"],"content":"\r模拟私有方法\rjavascript var makeCounter = function() { var privateCounter = 0; function changeBy(val) { privateCounter += val; } return { increment: function() { changeBy(1); }, decrement: function() { changeBy(-1); }, value: function() { return privateCounter; } } }; var Counter1 = makeCounter(); var Counter2 = makeCounter(); console.log(Counter1.value()); /* logs 0 */ Counter1.increment(); Counter1.increment(); console.log(Counter1.value()); /* logs 2 */ Counter1.decrement(); console.log(Counter1.value()); /* logs 1 */ console.log(Counter2.value()); /* logs 0 */\r","date":"2019-04-16","objectID":"/%E9%97%AD%E5%8C%85/:3:2","series":null,"tags":["JavaScript","编程"],"title":"闭包","uri":"/%E9%97%AD%E5%8C%85/#模拟私有方法"},{"categories":["JavaScript"],"content":"\r解决var作用域问题\rhtml \u003cp id=\"help\"\u003eHelpful notes will appear here\u003c/p\u003e \u003cp\u003eE-mail: \u003cinput type=\"text\" id=\"email\" name=\"email\"\u003e\u003c/p\u003e \u003cp\u003eName: \u003cinput type=\"text\" id=\"name\" name=\"name\"\u003e\u003c/p\u003e \u003cp\u003eAge: \u003cinput type=\"text\" id=\"age\" name=\"age\"\u003e\u003c/p\u003e \u003cscript\u003e function showHelp(help) { document.getElementById('help').innerHTML = help; } function setupHelp() { var helpText = [ {'id': 'email', 'help': 'Your e-mail address'}, {'id': 'name', 'help': 'Your full name'}, {'id': 'age', 'help': 'Your age (you must be over 16)'} ]; for (var i = 0; i \u003c helpText.length; i++) { var item = helpText[i]; document.getElementById(item.id).onfocus = function() { showHelp(item.help); } } } setupHelp(); \u003c/script\u003e\r代码运行后，循环在事件触发前执行完毕，item全部指向最后一项 解决方案：使用闭包创建私有变量 javascript function showHelp(help) { document.getElementById('help').innerHTML = help; } function setupHelp() { var helpText = [ {'id': 'email', 'help': 'Your e-mail address'}, {'id': 'name', 'help': 'Your full name'}, {'id': 'age', 'help': 'Your age (you must be over 16)'} ]; for (var i = 0; i \u003c helpText.length; i++) { (function() { var item = helpText[i]; document.getElementById(item.id).onfocus = function() { showHelp(item.help); } })(); // 马上把当前循环项的item与事件回调相关联起来 } } setupHelp();\rES6 let方案 javascript function showHelp(help) { document.getElementById('help').innerHTML = help; } function setupHelp() { var helpText = [ {'id': 'email', 'help': 'Your e-mail address'}, {'id': 'name', 'help': 'Your full name'}, {'id': 'age', 'help': 'Your age (you must be over 16)'} ]; for (var i = 0; i \u003c helpText.length; i++) { let item = helpText[i]; document.getElementById(item.id).onfocus = function() { showHelp(item.help); } } } setupHelp();\r","date":"2019-04-16","objectID":"/%E9%97%AD%E5%8C%85/:3:3","series":null,"tags":["JavaScript","编程"],"title":"闭包","uri":"/%E9%97%AD%E5%8C%85/#解决var作用域问题"},{"categories":["JavaScript"],"content":"\r性能问题使用闭包会加大内存消耗和减慢脚本的处理速度，因此应该尽量避免使用闭包。 ","date":"2019-04-16","objectID":"/%E9%97%AD%E5%8C%85/:4:0","series":null,"tags":["JavaScript","编程"],"title":"闭包","uri":"/%E9%97%AD%E5%8C%85/#性能问题"},{"categories":["JavaScript"],"content":"关于 ES6 中的箭头函数，网上有很多文章解释其作用和语法，如果你刚开始接触 ES6，可以从这里开始。任何事物都具有两面性，语言的新特性常常被误解、滥用，比如箭头函数的使用就存在很多误区。接下来，笔者会通过实例介绍该避免使用箭头函数的场景，以及在这些场景下该如何使用函数表达式（function expressions）、函数声明或者方法简写（shorthand method）来保障代码正确性和可读性。 ","date":"2019-04-13","objectID":"/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/:0:0","series":null,"tags":["JavaScript","编程"],"title":"箭头函数","uri":"/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/#"},{"categories":["JavaScript"],"content":"\r1. 定义对象方法JS 中对象方法的定义方式是在对象上定义一个指向函数的属性，当方法被调用的时候，方法内的 this 就会指向方法所属的对象。 1.1 定义字面量方法 因为箭头函数的语法很简洁，可能不少同学会忍不住用它来定义字面量方法，比如下面的例子 JS Bin： javascript const calculator = { array: [1, 2, 3], sum: () =\u003e { console.log(this === window); // =\u003e true return this.array.reduce((result, item) =\u003e result + item); } }; console.log(this === window); // =\u003e true // Throws \"TypeError: Cannot read property 'reduce' of undefined\" calculator.sum();\rcalculator.sum 使用箭头函数来定义，但是调用的时候会抛出 TypeError，因为运行时 this.array 是未定义的，调用 calculator.sum 的时候，执行上下文里面的 this 仍然指向的是 window，原因是箭头函数把函数上下文绑定到了 window 上，this.array 等价于 window.array，显然后者是未定义的。 解决的办法是，使用函数表达式或者方法简写（ES6 中已经支持）来定义方法，这样能确保 this 是在运行时是由包含它的上下文决定的，修正后的代码如下 JS Bin： javascript const calculator = { array: [1, 2, 3], sum() { console.log(this === calculator); // =\u003e true return this.array.reduce((result, item) =\u003e result + item); } }; calculator.sum(); // =\u003e 6 这样 calculator.sum 就变成了普通函数，执行时 this 就指向 calculator 对象，自然能得到正确的计算结果。 1.2 定义原型方法 同样的规则适用于原型方法（prototype method）的定义，使用箭头函数会导致运行时的执行上下文错误，比如下面的例子 JS Bin： javascript function Cat(name) { this.name = name; } Cat.prototype.sayCatName = () =\u003e { console.log(this === window); // =\u003e true return this.name; }; const cat = new Cat('Mew'); cat.sayCatName(); // =\u003e undefined 使用传统的函数表达式就能解决问题 JS Bin： javascript function Cat(name) { this.name = name; } Cat.prototype.sayCatName = function () { console.log(this === cat); // =\u003e true return this.name; }; const cat = new Cat('Mew'); cat.sayCatName(); // =\u003e 'Mew' sayCatName 变成普通函数之后，被调用时的执行上下文就会指向新创建的 cat 实例。 ","date":"2019-04-13","objectID":"/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/:1:0","series":null,"tags":["JavaScript","编程"],"title":"箭头函数","uri":"/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/#1-定义对象方法"},{"categories":["JavaScript"],"content":"\r2. 定义事件回调函数this 是 JS 中很强大的特性，可以通过多种方式改变函数执行上下文，JS 内部也有几种不同的默认上下文指向，但普适的规则是在谁上面调用函数 this 就指向谁，这样代码理解起来也很自然，读起来就像在说，某个对象上正在发生某件事情。 但是，箭头函数在声明的时候就绑定了执行上下文，要动态改变上下文是不可能的，在需要动态上下文的时候它的弊端就凸显出来。比如在客户端编程中常见的 DOM 事件回调函数（event listenner）绑定，触发回调函数时 this 指向当前发生事件的 DOM 节点，而动态上下文这个时候就非常有用，比如下面这段代码试图使用箭头函数来作事件回调函数 JS Bin： javascript const button = document.getElementById('myButton'); button.addEventListener('click', () =\u003e { console.log(this === window); // =\u003e true this.innerHTML = 'Clicked button'; });\r在全局上下文下定义的箭头函数执行时 this 会指向 window，当单击事件发生时，浏览器会尝试用 button 作为上下文来执行事件回调函数，但是箭头函数预定义的上下文是不能被修改的，这样 this.innerHTML 就等价于 window.innerHTML，而后者是没有任何意义的。 使用函数表达式就可以在运行时动态的改变 this，修正后的代码 JS Bin： javascript const button = document.getElementById('myButton'); button.addEventListener('click', function() { console.log(this === button); // =\u003e true this.innerHTML = 'Clicked button'; });\r当用户单击按钮时，事件回调函数中的 this 实际指向 button，这样的 this.innerHTML = ‘Clicked button’ 就能按照预期修改按钮中的文字。 ","date":"2019-04-13","objectID":"/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/:2:0","series":null,"tags":["JavaScript","编程"],"title":"箭头函数","uri":"/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/#2-定义事件回调函数"},{"categories":["JavaScript"],"content":"\r3. 定义构造函数构造函数中的 this 指向新创建的对象，当执行 new Car() 的时候，构造函数 Car 的上下文就是新创建的对象，也就是说 this instanceof Car === true。显然，箭头函数是不能用来做构造函数， 实际上 JS 会禁止你这么做，如果你这么做了，它就会抛出异常。 换句话说，箭头构造函数的执行并没有任何意义，并且是有歧义的。比如，当我们运行下面的代码 JS Bin： javascript const Message = (text) =\u003e { this.text = text; }; // Throws \"TypeError: Message is not a constructor\" const helloMessage = new Message('Hello World!');\r构造新的 Message 实例时，JS 引擎抛了错误，因为 Message 不是构造函数。在笔者看来，相比旧的 JS 引擎在出错时悄悄失败的设计，ES6 在出错时给出具体错误消息是非常不错的实践。可以通过使用函数表达式或者函数声明 来声明构造函数修复上面的例子 JS Bin： javascript const Message = function(text) { this.text = text; }; const helloMessage = new Message('Hello World!'); console.log(helloMessage.text); // =\u003e 'Hello World!' ","date":"2019-04-13","objectID":"/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/:3:0","series":null,"tags":["JavaScript","编程"],"title":"箭头函数","uri":"/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/#3-定义构造函数"},{"categories":["JavaScript"],"content":"\r4. 追求过短的代码箭头函数允许你省略参数两边的括号、函数体的花括号、甚至 return 关键词，这对编写更简短的代码非常有帮助。这让我想起大学计算机老师给学生留过的有趣作业：看谁能使用 C 语言编写出最短的函数来计算字符串的长度，这对学习和探索新语言特性是个不错的法子。但是，在实际的软件工程中，代码写完之后会被很多工程师阅读，真正的 write once, read many times，在代码可读性方面，最短的代码可能并不总是最好的。一定程度上，压缩了太多逻辑的简短代码，阅读起来就没有那么直观，比如下面的例子 JS Bin： javascript const multiply = (a, b) =\u003e b === undefined ? b =\u003e a * b : a * b; const double = multiply(2); double(3); // =\u003e 6 multiply(2, 3); // =\u003e 6 multiply 函数会返回两个数字的乘积或者返回一个可以继续调用的固定了一个参数的函数。代码看起来很简短，但大多数人第一眼看上去可能无法立即搞清楚它干了什么，怎么让这段代码可读性更高呢？有很多办法，可以在箭头函数中加上括号、条件判断、返回语句，或者使用普通的函数 JS Bin： javascript function multiply(a, b) { if (b === undefined) { return function (b) { return a * b; } } return a * b; } const double = multiply(2); double(3); // =\u003e 6 multiply(2, 3); // =\u003e 6 为了让代码可读性更高，在简短和啰嗦之间把握好平衡是非常有必要的。 ","date":"2019-04-13","objectID":"/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/:4:0","series":null,"tags":["JavaScript","编程"],"title":"箭头函数","uri":"/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/#4-追求过短的代码"},{"categories":["JavaScript"],"content":"\r5. 总结箭头函数无疑是 ES6 带来的重大改进，在正确的场合使用箭头函数能让代码变的简洁、短小，但某些方面的优势在另外一些方面可能就变成了劣势，在需要动态上下文的场景中使用箭头函数你要格外的小心，这些场景包括：定义对象方法、定义原型方法、定义构造函数、定义事件回调函数。 ","date":"2019-04-13","objectID":"/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/:5:0","series":null,"tags":["JavaScript","编程"],"title":"箭头函数","uri":"/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/#5-总结"},{"categories":["JavaScript"],"content":"\rJavaScript: Slice, Substring, or Substr的选择！","date":"2019-03-17","objectID":"/javascript%E5%AD%97%E7%AC%A6%E4%B8%B2string%E6%8F%90%E5%8F%96%E6%96%B9%E6%B3%95%E6%AF%94%E8%BE%83/:0:0","series":null,"tags":["JavaScript","编程"],"title":"JavaScript字符串String提取方法比较","uri":"/javascript%E5%AD%97%E7%AC%A6%E4%B8%B2string%E6%8F%90%E5%8F%96%E6%96%B9%E6%B3%95%E6%AF%94%E8%BE%83/#javascript-slice-substring-or-substr的选择"},{"categories":["JavaScript"],"content":"\r在JavaScript中，子字符串主要通过以下String方法之一提取：\rjs // slice // syntax: string.slice(start [, stop]) \"Good news, everyone!\".slice(5,9); // 'news' // substring // syntax: string.substring(start [, stop]) \"Good news, everyone!\".substring(5,9); // 'news' // substr // syntax: string.substr(start [, length]) \"Good news, everyone!\".substr(5,4); // 'news' ","date":"2019-03-17","objectID":"/javascript%E5%AD%97%E7%AC%A6%E4%B8%B2string%E6%8F%90%E5%8F%96%E6%96%B9%E6%B3%95%E6%AF%94%E8%BE%83/:1:0","series":null,"tags":["JavaScript","编程"],"title":"JavaScript字符串String提取方法比较","uri":"/javascript%E5%AD%97%E7%AC%A6%E4%B8%B2string%E6%8F%90%E5%8F%96%E6%96%B9%E6%B3%95%E6%AF%94%E8%BE%83/#在javascript中子字符串主要通过以下string方法之一提取"},{"categories":["JavaScript"],"content":"\r这三种方法都采用了开始索引和可选的结束索引（或长度）参数，但它们在某些重要方面有所不同： substr可以给出不一致的结果。现代浏览器允许使用负数索引，但IE8和更低版本将负开始索引视为0。 substring的参数是可逆的，因为它总是使用其最小参数值作为开始索引，最大值作为结束索引。substring将负开始索引视为0。 slice如果开始索引为负，则从字符串末尾开始切片。 ","date":"2019-03-17","objectID":"/javascript%E5%AD%97%E7%AC%A6%E4%B8%B2string%E6%8F%90%E5%8F%96%E6%96%B9%E6%B3%95%E6%AF%94%E8%BE%83/:2:0","series":null,"tags":["JavaScript","编程"],"title":"JavaScript字符串String提取方法比较","uri":"/javascript%E5%AD%97%E7%AC%A6%E4%B8%B2string%E6%8F%90%E5%8F%96%E6%96%B9%E6%B3%95%E6%AF%94%E8%BE%83/#这三种方法都采用了开始索引和可选的结束索引或长度参数但它们在某些重要方面有所不同"},{"categories":["JavaScript"],"content":"\r负数作为参数\rjs \"Good news, everyone!\".substring(-4); // \"Good news, everyone!\" \"Good news, everyone!\".substr(-4); // \"one!\" modern browsers, including IE9 // \"Good news, everyone!\" IE8 and lower \"Good news, everyone!\".slice(-4); // \"one!\" 由于所有三种方法都具有大致相同的性能，我的偏好是使用slice。它支持从字符串的末尾提取，我觉得在start index\u003e stop 时返回一个空字符串更遵循常人思维，比substring的参数交换更好。我避免使用substr，因为浏览器不一致。 ","date":"2019-03-17","objectID":"/javascript%E5%AD%97%E7%AC%A6%E4%B8%B2string%E6%8F%90%E5%8F%96%E6%96%B9%E6%B3%95%E6%AF%94%E8%BE%83/:3:0","series":null,"tags":["JavaScript","编程"],"title":"JavaScript字符串String提取方法比较","uri":"/javascript%E5%AD%97%E7%AC%A6%E4%B8%B2string%E6%8F%90%E5%8F%96%E6%96%B9%E6%B3%95%E6%AF%94%E8%BE%83/#负数作为参数"},{"categories":["技巧"],"content":"文章长期更新 ","date":"2019-01-08","objectID":"/%E5%9B%BE%E5%BA%8A%E8%AF%84%E6%B5%8B/:0:0","series":null,"tags":["图床"],"title":"图床选择","uri":"/%E5%9B%BE%E5%BA%8A%E8%AF%84%E6%B5%8B/#"},{"categories":["技巧"],"content":"\r公共图床排名 ","date":"2019-01-08","objectID":"/%E5%9B%BE%E5%BA%8A%E8%AF%84%E6%B5%8B/:0:0","series":null,"tags":["图床"],"title":"图床选择","uri":"/%E5%9B%BE%E5%BA%8A%E8%AF%84%E6%B5%8B/#公共图床排名"},{"categories":["技巧"],"content":"\r第一名 微博图床新浪微博图床无论是国内外速度还是CDN和HTTPS的支持都一样不少，浏览器也有相应的插件，我目前使用的是＂微博图床＂这个插件，相册上传位置可以在微相册中找到。缺点是微博开始限制外链。 评分 速度：★★★★★ 插件：★★★★★ CDN：★★★★★ 稳定性：★★★★ 费用: 免费 单张图片最大容量：20MB ","date":"2019-01-08","objectID":"/%E5%9B%BE%E5%BA%8A%E8%AF%84%E6%B5%8B/:1:0","series":null,"tags":["图床"],"title":"图床选择","uri":"/%E5%9B%BE%E5%BA%8A%E8%AF%84%E6%B5%8B/#第一名-微博图床"},{"categories":["技巧"],"content":"\r解决微博图床的防盗链问题","date":"2019-01-08","objectID":"/%E5%9B%BE%E5%BA%8A%E8%AF%84%E6%B5%8B/:1:1","series":null,"tags":["图床"],"title":"图床选择","uri":"/%E5%9B%BE%E5%BA%8A%E8%AF%84%E6%B5%8B/#解决微博图床的防盗链问题"},{"categories":["技巧"],"content":"\r1.修改域名前缀可以通过批量修改前缀来暂时恢复正常访问，新浪图片都是多台服务器寄存的，一般是 wx1.sinaimg.cn 这里我们需要将其替换成 fc.sinaimg.com ","date":"2019-01-08","objectID":"/%E5%9B%BE%E5%BA%8A%E8%AF%84%E6%B5%8B/:2:0","series":null,"tags":["图床"],"title":"图床选择","uri":"/%E5%9B%BE%E5%BA%8A%E8%AF%84%E6%B5%8B/#1修改域名前缀"},{"categories":["技巧"],"content":"\r2.利用图片缓存WordPress： https://i0.wp.com/图片地址 （图片地址要掉 https://） Weserv.nl： https://images.weserv.nl/?url=图片地址 百度 1： https://image.baidu.com/search/down?url=图片地址 百度 2： https://gimg2.baidu.com/image_search/\u0026app=2020\u0026src=图片地址 （图片地址要去掉 https://） ","date":"2019-01-08","objectID":"/%E5%9B%BE%E5%BA%8A%E8%AF%84%E6%B5%8B/:3:0","series":null,"tags":["图床"],"title":"图床选择","uri":"/%E5%9B%BE%E5%BA%8A%E8%AF%84%E6%B5%8B/#2利用图片缓存"},{"categories":["技巧"],"content":"\r第二名 imgur这是著名的老牌图床,国外稳定好，国内稳定性差。提供的上传工具也非常多。 评分 速度：★★★★ 插件：★★★★★ CDN：★★★★ 稳定性：★★★★★ 费用: 免费 单张图片最大容量：10MB ","date":"2019-01-08","objectID":"/%E5%9B%BE%E5%BA%8A%E8%AF%84%E6%B5%8B/:4:0","series":null,"tags":["图床"],"title":"图床选择","uri":"/%E5%9B%BE%E5%BA%8A%E8%AF%84%E6%B5%8B/#第二名-imgur"},{"categories":["技巧"],"content":"\r第三名 sm.ms大佬自建的图床，可以管理图库，可批量上传，无损，速度快，免费版只有5G 评分 速度：★★★★ 插件：★★★★ CDN：★★★★ 稳定性：★★★ 费用: 免费 单张图片最大容量：5MB ","date":"2019-01-08","objectID":"/%E5%9B%BE%E5%BA%8A%E8%AF%84%E6%B5%8B/:5:0","series":null,"tags":["图床"],"title":"图床选择","uri":"/%E5%9B%BE%E5%BA%8A%E8%AF%84%E6%B5%8B/#第三名-smms"},{"categories":["技巧"],"content":"\r其他方案","date":"2019-01-08","objectID":"/%E5%9B%BE%E5%BA%8A%E8%AF%84%E6%B5%8B/:0:0","series":null,"tags":["图床"],"title":"图床选择","uri":"/%E5%9B%BE%E5%BA%8A%E8%AF%84%E6%B5%8B/#其他方案"},{"categories":["技巧"],"content":"\r稳妥方案 七牛云对象云存储 腾讯云对象云存储 阿里云对象云存储 ","date":"2019-01-08","objectID":"/%E5%9B%BE%E5%BA%8A%E8%AF%84%E6%B5%8B/:1:0","series":null,"tags":["图床"],"title":"图床选择","uri":"/%E5%9B%BE%E5%BA%8A%E8%AF%84%E6%B5%8B/#稳妥方案"},{"categories":["技巧"],"content":"\r偏门方案 百度百家 京东 ","date":"2019-01-08","objectID":"/%E5%9B%BE%E5%BA%8A%E8%AF%84%E6%B5%8B/:2:0","series":null,"tags":["图床"],"title":"图床选择","uri":"/%E5%9B%BE%E5%BA%8A%E8%AF%84%E6%B5%8B/#偏门方案"},{"categories":["技巧"],"content":"\r整理的图片上传地址（不定期更新） 别人的整理 微博插件 ","date":"2019-01-08","objectID":"/%E5%9B%BE%E5%BA%8A%E8%AF%84%E6%B5%8B/:3:0","series":null,"tags":["图床"],"title":"图床选择","uri":"/%E5%9B%BE%E5%BA%8A%E8%AF%84%E6%B5%8B/#整理的图片上传地址不定期更新"},{"categories":null,"content":"\r","date":"0001-01-01","objectID":"/friends/:0:0","series":null,"tags":null,"title":"","uri":"/friends/#"}]